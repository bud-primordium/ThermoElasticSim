tests/
    test_cpp_interface.py
    test_deformation.py
    test_elasticity.py
    test_md.py
    test_mechanics.py
    test_nose_hoover.py
    test_optimizers.py
    test_potentials.py
    test_structure.py
    test_utils.py
    test_visualization.py
# tests/test_cpp_interface.py

import pytest
import numpy as np
from python.interfaces.cpp_interface import CppInterface
from python.structure import Atom, Cell
from python.potentials import LennardJonesPotential


@pytest.fixture
def lj_interface():
    return CppInterface("lennard_jones")


@pytest.fixture
def stress_calculator_interface():
    return CppInterface("stress_calculator")


@pytest.fixture
def nose_hoover_interface():
    return CppInterface("nose_hoover")


@pytest.fixture
def nose_hoover_chain_interface():
    return CppInterface("nose_hoover_chain")


def test_calculate_energy(lj_interface):
    """
    测试 C++ 实现的 Lennard-Jones 势能计算函数
    """
    num_atoms = 2
    positions = np.array(
        [0.0, 0.0, 0.0, 2.55, 0.0, 0.0], dtype=np.float64
    )  # 两个原子，距离 r = σ = 2.55 Å
    box_lengths = np.array([5.1, 5.1, 5.1], dtype=np.float64)  # 模拟盒子长度

    energy = lj_interface.calculate_energy(
        num_atoms,
        positions,
        epsilon=0.0103,
        sigma=2.55,
        cutoff=2.5 * 2.55,
        box_lengths=box_lengths,
    )

    # 检查能量是否为浮点数
    assert isinstance(energy, float), "Energy is not a float."

    # 根据 r = sigma, 势能应为 0
    expected_energy = 0.0

    assert np.isclose(
        energy, expected_energy, atol=1e-6
    ), f"Energy {energy} is not close to expected {expected_energy}."


def test_calculate_forces(lj_interface):
    """
    测试 C++ 实现的 Lennard-Jones 势能计算力函数
    """
    num_atoms = 2
    positions = np.array([0.0, 0.0, 0.0, 2.55, 0.0, 0.0], dtype=np.float64)
    box_lengths = np.array([5.1, 5.1, 5.1], dtype=np.float64)
    forces = np.zeros_like(positions, dtype=np.float64)

    lj_interface.calculate_forces(
        num_atoms,
        positions,
        forces,
        epsilon=0.0103,
        sigma=2.55,
        cutoff=2.5 * 2.55,
        box_lengths=box_lengths,
    )

    # 重新形状为 (num_atoms, 3)
    forces = forces.reshape((num_atoms, 3))

    # 计算期望的力
    epsilon = 0.0103

    # 理论上，在 r = sigma，力 = 24 * epsilon
    expected_force_theory = 24.0 * epsilon  # 0.2472 eV/Å

    # 检查力是否接近理论值
    np.testing.assert_allclose(forces[0, 0], expected_force_theory, atol=1e-6)
    np.testing.assert_allclose(forces[1, 0], -expected_force_theory, atol=1e-6)
    # 其他方向的力应为零
    np.testing.assert_allclose(forces[:, 1:], 0.0, atol=1e-6)


def test_nose_hoover(nose_hoover_interface):
    """
    测试 C++ 实现的 Nose-Hoover 恒温器函数
    """
    dt = 1.0
    num_atoms = 2
    masses = np.array([1.0, 1.0], dtype=np.float64)
    velocities = np.array([0.0, 0.0, 0.0, 1.0, 0.0, 0.0], dtype=np.float64)
    forces = np.array([0.0, 0.0, 0.0, -1.0, 0.0, 0.0], dtype=np.float64)
    xi = 0.0
    Q = 10.0
    target_temperature = 300.0

    # C++ 函数 expects a pointer to xi, so create a mutable array
    xi_array = np.array([xi], dtype=np.float64)

    updated_xi = nose_hoover_interface.nose_hoover(
        dt,
        num_atoms,
        masses,
        velocities,
        forces,
        xi_array,  # 传递数组
        Q,
        target_temperature,
    )

    # Check that xi has been updated
    assert isinstance(updated_xi, float), "xi is not a float."
    # 根据实现，xi 应该有变化
    assert (
        updated_xi != xi
    ), f"xi was not updated. Original: {xi}, Updated: {updated_xi}"


def test_nose_hoover_chain(nose_hoover_chain_interface):
    """
    测试 C++ 实现的 Nose-Hoover 链恒温器函数
    """
    dt = 1.0
    num_atoms = 2
    masses = np.array([1.0, 1.0], dtype=np.float64)
    velocities = np.array([0.0, 0.0, 0.0, 1.0, 0.0, 0.0], dtype=np.float64)
    forces = np.array([0.0, 0.0, 0.0, -1.0, 0.0, 0.0], dtype=np.float64)
    xi_chain = np.zeros(2, dtype=np.float64)  # 假设链长度为 2
    Q = np.array([10.0, 10.0], dtype=np.float64)
    chain_length = 2
    target_temperature = 300.0

    nose_hoover_chain_interface.nose_hoover_chain(
        dt,
        num_atoms,
        masses,
        velocities,
        forces,
        xi_chain,
        Q,
        chain_length,
        target_temperature,
    )

    # Check that xi_chain has been updated
    assert isinstance(xi_chain, np.ndarray), "xi_chain is not a numpy array."
    assert xi_chain.shape == (chain_length,), "xi_chain shape mismatch."
    # 检查是否有变化
    assert not np.all(xi_chain == 0.0), "xi_chain was not updated."


# tests/test_deformation.py

import pytest
import numpy as np
from python.deformation import Deformer


def test_generate_deformation_matrices():
    """
    @brief 测试生成变形矩阵的方法
    """
    delta = 0.01  # 1% 的应变
    deformer = Deformer(delta)
    deformation_matrices = deformer.generate_deformation_matrices()

    # 检查是否生成了 6 个变形矩阵
    assert len(deformation_matrices) == 6

    # 检查每个变形矩阵的正确性
    for i, F in enumerate(deformation_matrices):
        # 检查矩阵是否为 3x3
        assert F.shape == (3, 3)

        # 检查矩阵是否为单位矩阵加上微小变形
        expected_F = np.identity(3)
        if i < 3:
            expected_F[i, i] += delta
        else:
            shear_indices = [(0, 1), (0, 2), (1, 2)]
            idx = i - 3
            i_shear, j_shear = shear_indices[idx]
            expected_F[i_shear, j_shear] += delta / 2
            expected_F[j_shear, i_shear] += delta / 2
        np.testing.assert_array_almost_equal(F, expected_F, decimal=6)


def test_apply_deformation(cell_fixture):
    """
    @brief 测试对晶胞施加变形矩阵的方法
    """
    delta = 0.01
    deformer = Deformer(delta)
    deformation_matrix = deformer.generate_deformation_matrices()[0]  # ε_xx
    original_lattice = cell_fixture.lattice_vectors.copy()
    original_positions = [atom.position.copy() for atom in cell_fixture.atoms]

    deformer.apply_deformation(cell_fixture, deformation_matrix)

    # 检查晶格矢量是否正确更新
    expected_lattice = np.dot(original_lattice, deformation_matrix.T)
    np.testing.assert_array_almost_equal(
        cell_fixture.lattice_vectors, expected_lattice, decimal=6
    )

    # 检查原子位置是否正确更新
    for original_pos, atom in zip(original_positions, cell_fixture.atoms):
        expected_pos = np.dot(deformation_matrix, original_pos)
        np.testing.assert_array_almost_equal(atom.position, expected_pos, decimal=6)


@pytest.fixture
def cell_fixture():
    """
    @fixture 创建一个简单的晶胞，用于测试
    """
    from python.structure import Atom, Cell

    mass = 26.9815  # amu
    position = np.array([0.0, 0.0, 0.0])
    atom = Atom(id=0, symbol="Al", mass=mass, position=position)
    lattice_vectors = np.eye(3) * 4.05  # Å
    cell = Cell(lattice_vectors, [atom], pbc_enabled=True)
    return cell


# tests/test_elasticity.py

import pytest
import numpy as np
from python.structure import Atom, Cell
from python.potentials import LennardJonesPotential
from python.elasticity import ElasticConstantsCalculator
import logging

# Configure logging
logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)

def test_elastic_constants_calculator():
    """
    @brief 测试 ElasticConstantsCalculator 计算弹性常数
    """
    # Create a more complex cell, e.g., face-centered cubic (FCC) lattice, with repetitions to increase atom count
    atoms = []
    lattice_constant = 5.1  # Å
    repetitions = 2  # 2x2x2 unit cells
    for i in range(repetitions):
        for j in range(repetitions):
            for k in range(repetitions):
                base = np.array([i, j, k]) * lattice_constant
                positions = [
                    base + np.array([0.0, 0.0, 0.0]),
                    base + np.array([0.0, 0.5, 0.5]),
                    base + np.array([0.5, 0.0, 0.5]),
                    base + np.array([0.5, 0.5, 0.0]),
                ]
                for pos in positions:
                    atoms.append(Atom(id=len(atoms), mass=26.9815, position=pos, symbol="Al"))
    
    lattice_vectors = np.eye(3) * lattice_constant * repetitions  # Expanded lattice vectors
    cell = Cell(lattice_vectors=lattice_vectors, atoms=atoms, pbc_enabled=True)
    
    # Define Lennard-Jones potential
    epsilon = 0.0103  # eV
    sigma = 2.55  # Å
    cutoff = 2.5 * sigma  # Å
    lj_potential = LennardJonesPotential(epsilon=epsilon, sigma=sigma, cutoff=cutoff)
    
    # Create ElasticConstantsCalculator instance
    elastic_calculator = ElasticConstantsCalculator(
        cell=cell, potential=lj_potential, delta=1e-3, optimizer_type="BFGS"
    )
    
    # Calculate elastic constants
    C_in_GPa = elastic_calculator.calculate_elastic_constants()
    
    # Output computed elastic constants
    logger.debug("Computed Elastic Constants (GPa):")
    logger.debug(C_in_GPa)
    
    # Check that C_in_GPa is a 6x6 matrix
    assert C_in_GPa.shape == (6, 6), "弹性常数矩阵形状不匹配。"
    
    # Check symmetry
    symmetry = np.allclose(C_in_GPa, C_in_GPa.T, atol=1e-3)
    logger.debug(f"Symmetry check: {symmetry}")
    assert symmetry, "弹性常数矩阵不是对称的。"
    
    # Check that diagonal elements are positive
    for i in range(6):
        logger.debug(f"C_in_GPa[{i},{i}] = {C_in_GPa[i, i]}")
        assert C_in_GPa[i, i] > 0, f"弹性常数 C[{i},{i}] 不是正值。"
    
    # Optionally, check off-diagonal elements are within reasonable ranges
    for i in range(6):
        for j in range(i+1, 6):
            logger.debug(f"C_in_GPa[{i},{j}] = {C_in_GPa[i, j]}")
            assert 0.0 <= C_in_GPa[i, j] <= 100.0, f"弹性常数 C[{i},{j}] 不在合理范围内。"
    
    # Further check the elastic constants are within expected ranges
    # For example, diagonal elements (C11, C22, ...) typically 50-100 GPa
    # Shear moduli (C44, C55, C66) typically 10-30 GPa
    # Adjust these ranges based on your system's properties
    for i in range(3):
        logger.debug(f"C_in_GPa[{i},{i}] = {C_in_GPa[i, i]}")
        assert 50.0 <= C_in_GPa[i, i] <= 100.0, f"C[{i},{i}] = {C_in_GPa[i, i]} GPa 不在预期范围内。"
    for i in range(3,6):
        logger.debug(f"C_in_GPa[{i},{i}] = {C_in_GPa[i, i]}")
        assert 10.0 <= C_in_GPa[i, i] <= 30.0, f"C[{i},{i}] = {C_in_GPa[i, i]} GPa 不在预期范围内。"


# tests/test_md.py

import pytest
import numpy as np

from python.md_simulator import MDSimulator
from python.integrators import VelocityVerletIntegrator
from python.thermostats import NoseHooverThermostat

from python.structure import Atom, Cell
from python.potentials import LennardJonesPotential


@pytest.fixture
def simple_cell(pbc_enabled=True):
    """
    @fixture 创建一个简单的晶胞，包含两个原子。
    """
    lattice_vectors = np.eye(3) * 6.0 if pbc_enabled else np.eye(3) * 1e8  # Å
    mass = 26.9815  # amu (Aluminum)
    position1 = np.array([0.0, 0.0, 0.0])
    position2 = np.array([2.55, 0.0, 0.0])  # 与原子1相距 σ = 2.55 Å
    atom1 = Atom(id=0, symbol="Al", mass=mass, position=position1)
    atom2 = Atom(id=1, symbol="Al", mass=mass, position=position2)
    cell = Cell(
        lattice_vectors=lattice_vectors, atoms=[atom1, atom2], pbc_enabled=pbc_enabled
    )
    return cell


@pytest.fixture
def lj_potential():
    """
    @fixture 定义 Lennard-Jones 势。
    """
    epsilon = 0.0103  # eV
    sigma = 2.55  # Å
    cutoff = 2.5 * sigma
    return LennardJonesPotential(epsilon=epsilon, sigma=sigma, cutoff=cutoff)


@pytest.fixture
def integrator():
    """
    @fixture 定义积分器。
    """
    return VelocityVerletIntegrator()


@pytest.fixture
def thermostat():
    """
    @fixture 定义恒温器。
    """
    return NoseHooverThermostat(target_temperature=300, time_constant=100)


def test_md_simulation(simple_cell, lj_potential, integrator):
    """
    @brief 测试分子动力学模拟器的运行。
    """
    md_simulator = MDSimulator(
        cell=simple_cell,
        potential=lj_potential,
        integrator=integrator,
        thermostat=None,
    )
    md_simulator.run(steps=10, dt=1.0)  # dt 单位为 fs

    # 检查原子的位置和速度是否发生变化
    atom1 = simple_cell.atoms[0]
    atom2 = simple_cell.atoms[1]
    assert not np.allclose(atom1.position, [0.0, 0.0, 0.0]), "原子1的位置未发生变化。"
    assert not np.allclose(atom2.position, [2.55, 0.0, 0.0]), "原子2的位置未发生变化。"
    assert not np.allclose(atom1.velocity, [0.0, 0.0, 0.0]), "原子1的速度未发生变化。"
    assert not np.allclose(atom2.velocity, [0.0, 0.0, 0.0]), "原子2的速度未发生变化。"


def test_md_simulation_with_thermostat(
    simple_cell, lj_potential, integrator, thermostat
):
    """
    @brief 测试分子动力学模拟器的运行，带恒温器。
    """
    md_simulator = MDSimulator(
        cell=simple_cell,
        potential=lj_potential,
        integrator=integrator,
        thermostat=thermostat,
    )
    md_simulator.run(steps=10, dt=1.0)  # dt 单位为 fs

    # 检查原子的位置和速度是否发生变化
    atom1 = simple_cell.atoms[0]
    atom2 = simple_cell.atoms[1]
    assert not np.allclose(atom1.position, [0.0, 0.0, 0.0]), "原子1的位置未发生变化。"
    assert not np.allclose(atom2.position, [2.55, 0.0, 0.0]), "原子2的位置未发生变化。"
    assert not np.allclose(atom1.velocity, [0.0, 0.0, 0.0]), "原子1的速度未发生变化。"
    assert not np.allclose(atom2.velocity, [0.0, 0.0, 0.0]), "原子2的速度未发生变化。"

    # 检查 xi 是否被更新
    assert thermostat.xi[0] != 0.0, "xi 未被更新。"


# tests/test_mechanics.py

import pytest
import numpy as np
from python.structure import Atom, Cell
from python.potentials import LennardJonesPotential
from python.elasticity import (
    ElasticConstantsSolver,
    StrainCalculator,
)  # 确保导入 StrainCalculator
from python.mechanics import StressCalculatorLJ
from python.utils import TensorConverter, AMU_TO_EVFSA2
import logging

# Configure logging
logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)


@pytest.fixture
def single_atom_cell():
    atoms = [
        Atom(
            id=0,
            mass_amu=26.9815,
            position=np.array([0.0, 0.0, 0.0]),
            symbol="Al",
        )
    ]
    lattice_vectors = np.eye(3) * 5.1
    return Cell(lattice_vectors=lattice_vectors, atoms=atoms, pbc_enabled=True)


@pytest.fixture
def lj_potential_single():
    return LennardJonesPotential(epsilon=0.0103, sigma=2.55, cutoff=2.5 * 2.55)


def test_stress_calculation(single_atom_cell, lj_potential_single):
    """
    @brief 测试应力计算器的功能。
    """
    stress_calculator = StressCalculatorLJ()
    # 计算力
    lj_potential_single.calculate_forces(single_atom_cell)
    # 计算应力
    stress_tensor = stress_calculator.compute_stress(
        single_atom_cell, lj_potential_single
    )
    # 由于只有一个原子，理论上应力张量应为零
    expected_stress = np.zeros((3, 3))
    np.testing.assert_array_almost_equal(stress_tensor, expected_stress, decimal=6)


def test_elastic_constants_solver():
    """
    @brief 测试弹性常数求解器的功能。
    """
    strains = [
        np.array([0.0, 0.0, 0.0, 0.0, 0.0, 0.0]),
        np.array([0.01, 0.0, 0.0, 0.0, 0.0, 0.0]),
        np.array([0.0, 0.01, 0.0, 0.0, 0.0, 0.0]),
        np.array([0.0, 0.0, 0.01, 0.0, 0.0, 0.0]),
        np.array([0.0, 0.0, 0.0, 0.01, 0.0, 0.0]),
        np.array([0.0, 0.0, 0.0, 0.0, 0.01, 0.0]),
        np.array([0.0, 0.0, 0.0, 0.0, 0.0, 0.01]),
    ]
    stresses = [
        np.array([0.0, 0.0, 0.0, 0.0, 0.0, 0.0]),
        np.array([69.0, 0.0, 0.0, 0.0, 0.0, 0.0]),
        np.array([0.0, 69.0, 0.0, 0.0, 0.0, 0.0]),
        np.array([0.0, 0.0, 69.0, 0.0, 0.0, 0.0]),
        np.array([0.0, 0.0, 0.0, 23.0, 0.0, 0.0]),
        np.array([0.0, 0.0, 0.0, 0.0, 23.0, 0.0]),
        np.array([0.0, 0.0, 0.0, 0.0, 0.0, 23.0]),
    ]
    solver = ElasticConstantsSolver()
    C = solver.solve(strains, stresses)
    # 检查 C 是否为 6x6 矩阵
    assert C.shape == (6, 6), "Elastic constants matrix shape mismatch."
    # 预期弹性常数矩阵（修正后的值）
    expected_C = np.array(
        [
            [6900.0, 0.0, 0.0, 0.0, 0.0, 0.0],
            [0.0, 6900.0, 0.0, 0.0, 0.0, 0.0],
            [0.0, 0.0, 6900.0, 0.0, 0.0, 0.0],
            [0.0, 0.0, 0.0, 2300.0, 0.0, 0.0],
            [0.0, 0.0, 0.0, 0.0, 2300.0, 0.0],
            [0.0, 0.0, 0.0, 0.0, 0.0, 2300.0],
        ]
    )
    # 检查弹性常数矩阵是否接近预期值
    np.testing.assert_array_almost_equal(C, expected_C, decimal=2)


def test_force_direction():
    """
    @brief 验证力的方向是否为负梯度方向。
    """
    # 创建一个简单的晶胞
    atoms = [
        Atom(id=0, mass=26.9815, position=np.array([0.0, 0.0, 0.0]), symbol="Al"),
        Atom(id=1, mass=26.9815, position=np.array([2.55, 2.55, 2.55]), symbol="Al"),
    ]
    lattice_vectors = np.eye(3) * 5.1  # 示例晶格向量
    cell = Cell(lattice_vectors=lattice_vectors, atoms=atoms, pbc_enabled=True)

    # 定义 Lennard-Jones 势
    epsilon = 0.0103  # eV
    sigma = 2.55  # Å
    cutoff = 2.5 * sigma  # Å
    lj_potential = LennardJonesPotential(epsilon=epsilon, sigma=sigma, cutoff=cutoff)

    # 计算初始能量和力
    initial_energy = lj_potential.calculate_energy(cell)
    initial_force = cell.get_forces()

    # 计算能量的数值梯度近似
    delta = 1e-5
    expected_force = np.zeros_like(initial_force)
    for i in range(cell.num_atoms):
        for dim in range(3):
            # 正向微小位移
            displaced = cell.copy()
            displaced.atoms[i].position[dim] += delta
            energy_displaced = lj_potential.calculate_energy(displaced)
            # 负梯度近似
            expected_force[i, dim] = -(energy_displaced - initial_energy) / delta

    # 检查力方向是否接近负梯度方向
    np.testing.assert_array_almost_equal(initial_force, expected_force, decimal=3)


def test_strain_calculation():
    """
    @brief 测试 StrainCalculator 计算应变的正确性。
    """
    # 创建一个样本变形矩阵 F
    delta = 1e-3  # 0.1% 应变
    F = np.array([[1 + delta, 0, 0], [0, 1 + delta, 0], [0, 0, 1 + delta]])

    # 预期的应变张量: epsilon = (F + F^T)/2 - I = delta * I
    expected_strain = np.array([delta, delta, delta, 0, 0, 0])  # Voigt 表示法

    # 初始化 StrainCalculator
    strain_calculator = StrainCalculator()

    # 计算应变
    strain_voigt = strain_calculator.compute_strain(F)

    logger.debug(f"Computed strain (Voigt): {strain_voigt}")
    logger.debug(f"Expected strain (Voigt): {expected_strain}")

    # 检查计算的应变是否为 NumPy 数组
    assert isinstance(strain_voigt, np.ndarray), "应变向量应为 NumPy 数组。"

    # 检查应变向量的形状
    assert strain_voigt.shape == (6,), "应变向量的形状应为 (6,)。"

    # 检查计算的应变是否与预期值匹配
    np.testing.assert_array_almost_equal(strain_voigt, expected_strain, decimal=6)


# tests/test_nose_hoover.py

import pytest
import numpy as np
from python.thermostats import NoseHooverThermostat
from python.structure import Atom, Cell
from python.utils import AMU_TO_EVFSA2


@pytest.fixture
def nose_hoover_thermostat():
    """
    @fixture 定义 Nose-Hoover 恒温器。
    """
    return NoseHooverThermostat(target_temperature=300, time_constant=100)


def test_nose_hoover_apply(nose_hoover_thermostat):
    """
    @brief 测试 Nose-Hoover 恒温器的 apply 方法。
    """
    # 创建一个简单的晶胞，包含两个原子
    atoms = [
        Atom(
            id=0,
            symbol="Al",
            mass_amu=26.9815,  # 转换为 eV/fs^2
            position=np.array([0.0, 0.0, 0.0]),
            velocity=np.array([1.0, 0.0, 0.0]),
        ),
        Atom(
            id=1,
            symbol="Al",
            mass_amu=26.9815,  # 转换为 eV/fs^2
            position=np.array([2.55, 0.0, 0.0]),
            velocity=np.array([-1.0, 0.0, 0.0]),
        ),
    ]

    # 初始化力
    for atom in atoms:
        atom.force = np.array([0.0, 0.0, 0.0])

    # 应用恒温器
    dt = 1.0  # fs
    nose_hoover_thermostat.apply(atoms, dt)

    # 检查 xi 是否被更新
    assert nose_hoover_thermostat.xi[0] != 0.0, "xi 未被更新。"

    # 检查速度是否被更新（根据恒温器的实现，速度应被缩放）
    # 由于初始力为零，速度应只受 xi 影响，具体变化取决于 C++ 实现
    # 这里只检查速度是否发生变化
    assert not np.allclose(atoms[0].velocity, [1.0, 0.0, 0.0]), "原子1的速度未被更新。"
    assert not np.allclose(atoms[1].velocity, [-1.0, 0.0, 0.0]), "原子2的速度未被更新。"


# tests/test_optimizers.py

import pytest
import numpy as np
from python.structure import Atom, Cell
from python.potentials import LennardJonesPotential
from python.optimizers import GradientDescentOptimizer, BFGSOptimizer
from python.elasticity import ElasticConstantsSolver  # 确保导入


@pytest.fixture
def lj_potential_optim():
    return LennardJonesPotential(epsilon=0.0103, sigma=2.55, cutoff=2.5 * 2.55)


def test_gradient_descent_optimizer(lj_potential_optim):
    """
    @brief 测试梯度下降优化器。
    """
    optimizer = GradientDescentOptimizer(max_steps=100, tol=1e-5, step_size=1e-3)
    # 创建一个简单的晶胞
    atoms = [
        Atom(id=0, mass=26.9815, position=np.array([0.0, 0.0, 0.0]), symbol="Al"),
        Atom(id=1, mass=26.9815, position=np.array([2.55, 0.0, 0.0]), symbol="Al"),
    ]
    lattice_vectors = np.eye(3) * 5.1
    cell = Cell(lattice_vectors=lattice_vectors, atoms=atoms, pbc_enabled=True)
    optimizer.optimize(cell, lj_potential_optim)
    # 检查优化是否收敛
    assert optimizer.converged, "梯度下降优化器未收敛"


def test_bfgs_optimizer(lj_potential_optim):
    """
    @brief 测试 BFGS 优化器。
    """
    optimizer = BFGSOptimizer(tol=1e-5)
    # 创建一个简单的晶胞
    atoms = [
        Atom(id=0, mass=26.9815, position=np.array([0.0, 0.0, 0.0]), symbol="Al"),
        Atom(id=1, mass=26.9815, position=np.array([2.55, 0.0, 0.0]), symbol="Al"),
    ]
    lattice_vectors = np.eye(3) * 5.1
    cell = Cell(lattice_vectors=lattice_vectors, atoms=atoms, pbc_enabled=True)
    optimizer.optimize(cell, lj_potential_optim)
    # 检查优化是否收敛
    assert optimizer.converged, "BFGS 优化器未收敛"


def test_optimizer_convergence():
    """
    @brief 测试优化器的收敛性。
    """
    optimizer = GradientDescentOptimizer(max_steps=1000, tol=1e-6, step_size=1e-3)
    # 创建一个简单的晶胞
    atoms = [
        Atom(id=0, mass=26.9815, position=np.array([0.0, 0.0, 0.0]), symbol="Al"),
        Atom(id=1, mass=26.9815, position=np.array([2.55, 0.0, 0.0]), symbol="Al"),
    ]
    lattice_vectors = np.eye(3) * 5.1
    cell = Cell(lattice_vectors=lattice_vectors, atoms=atoms, pbc_enabled=True)
    lj_potential = LennardJonesPotential(epsilon=0.0103, sigma=2.55, cutoff=2.5 * 2.55)
    optimizer.optimize(cell, lj_potential)
    # 检查优化是否收敛
    assert optimizer.converged, "优化器未能收敛"


# tests/test_potentials.py

import pytest
import numpy as np
from python.potentials import LennardJonesPotential
from python.structure import Atom, Cell


@pytest.fixture
def lj_potential():
    """
    @fixture 定义 Lennard-Jones 势
    """
    epsilon = 0.0103  # eV
    sigma = 2.55  # Å
    cutoff = 2.5 * sigma
    return LennardJonesPotential(epsilon=epsilon, sigma=sigma, cutoff=cutoff)


@pytest.fixture
def two_atom_cell():
    """
    @fixture 创建一个简单的系统，包含两个原子
    """
    lattice_vectors = np.eye(3) * 4.05  # Å
    mass = 26.9815  # amu
    position1 = np.array([0.0, 0.0, 0.0])
    position2 = np.array([2.025, 0.0, 0.0])  # 2.025 Å
    atom1 = Atom(id=0, symbol="Al", mass=mass, position=position1)
    atom2 = Atom(id=1, symbol="Al", mass=mass, position=position2)
    cell = Cell(lattice_vectors, [atom1, atom2], pbc_enabled=True)
    return cell


def test_force_calculation(lj_potential, two_atom_cell):
    """
    @brief 测试 Lennard-Jones 势的力计算功能
    """
    lj_potential.calculate_forces(two_atom_cell)
    # 检查力是否非零且相反
    force1 = two_atom_cell.atoms[0].force
    force2 = two_atom_cell.atoms[1].force
    np.testing.assert_array_almost_equal(force1, -force2, decimal=10)
    assert not np.allclose(force1, 0)


def test_energy_calculation(lj_potential, two_atom_cell):
    """
    @brief 测试 Lennard-Jones 势的能量计算功能
    """
    energy = lj_potential.calculate_energy(two_atom_cell)
    # 由于只有两个原子且对称位置，能量应等于 4 * epsilon * ( (sigma/r)^12 - (sigma/r)^6 )
    r = np.linalg.norm(
        two_atom_cell.atoms[1].position - two_atom_cell.atoms[0].position
    )
    expected_energy = (
        4.0
        * lj_potential.epsilon
        * ((lj_potential.sigma / r) ** 12 - (lj_potential.sigma / r) ** 6)
    )
    # 由于能量计算可能包括截断修正，此处仅为基本验证
    np.testing.assert_almost_equal(energy, expected_energy, decimal=10)


# tests/test_structure.py

import pytest
import numpy as np
from python.structure import Atom, Cell


@pytest.fixture
def atom():
    """
    @fixture 创建一个原子实例
    """
    position = np.array([0.0, 0.0, 0.0])
    mass = 26.9815  # amu
    return Atom(id=0, symbol="Al", mass=mass, position=position)


@pytest.fixture
def cell(atom):
    """
    @fixture 创建一个晶胞实例，包含一个原子
    """
    lattice_vectors = np.eye(3) * 4.05  # Å
    return Cell(lattice_vectors, [atom], pbc_enabled=True)


def test_atom_creation(atom):
    """
    @brief 测试原子的创建
    """
    assert atom.id == 0
    assert atom.symbol == "Al"
    np.testing.assert_array_equal(atom.position, np.array([0.0, 0.0, 0.0]))
    assert atom.mass == 26.9815


def test_cell_creation(cell, atom):
    """
    @brief 测试晶胞的创建
    """
    np.testing.assert_array_equal(cell.lattice_vectors, np.eye(3) * 4.05)
    assert len(cell.atoms) == 1
    assert cell.atoms[0] == atom


def test_volume_calculation(cell):
    """
    @brief 测试晶胞体积的计算
    """
    expected_volume = np.linalg.det(cell.lattice_vectors)
    calculated_volume = cell.calculate_volume()
    assert np.isclose(calculated_volume, expected_volume)


def test_apply_periodic_boundary(cell):
    """
    @brief 测试周期性边界条件的应用
    """
    lattice_constant = cell.lattice_vectors[0, 0]  # 假设晶格为立方
    position = np.array(
        [lattice_constant + 1.0, -1.0, lattice_constant + 1.0]
    )  # 超出晶胞范围的坐标
    new_position = cell.apply_periodic_boundary(position)
    # 检查新位置是否在 [0, lattice_constant) 范围内
    assert np.all(new_position >= 0)
    assert np.all(new_position < lattice_constant)


# tests/test_utils.py

import pytest
import numpy as np
from python.utils import TensorConverter, DataCollector
from python.structure import Atom, Cell


def test_tensor_converter_to_voigt():
    """
    @brief 测试 TensorConverter 的 to_voigt 方法
    """
    tensor = np.array([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0]])
    expected_voigt = np.array([1.0, 5.0, 9.0, 6.0, 3.0, 2.0])
    voigt = TensorConverter.to_voigt(tensor)
    np.testing.assert_array_almost_equal(voigt, expected_voigt, decimal=6)


@pytest.fixture
def cell_fixture():
    """
    @fixture 创建一个简单的晶胞，用于数据收集测试
    """
    lattice_vectors = np.eye(3) * 4.05  # Å
    mass = 26.9815  # amu
    position = np.array([0.0, 0.0, 0.0])
    atom = Atom(id=0, symbol="Al", mass=mass, position=position)
    cell = Cell(lattice_vectors, [atom], pbc_enabled=True)
    return cell


def test_data_collector(cell_fixture):
    """
    @brief 测试 DataCollector 的数据收集功能
    """
    collector = DataCollector()
    collector.collect(cell_fixture)
    assert len(collector.data) == 1
    collected = collector.data[0]
    assert "positions" in collected
    assert "velocities" in collected
    assert len(collected["positions"]) == 1
    assert len(collected["velocities"]) == 1
    np.testing.assert_array_equal(
        collected["positions"][0], cell_fixture.atoms[0].position
    )
    np.testing.assert_array_equal(
        collected["velocities"][0], cell_fixture.atoms[0].velocity
    )


# tests/test_visualization.py

import pytest
from python.visualization import Visualizer
from python.structure import Cell, Atom
import numpy as np
import matplotlib
import os

matplotlib.use("Agg")  # 使用无头后端，防止弹出图形窗口
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D  # 导入 Axes3D
from matplotlib.collections import PathCollection  # 导入 PathCollection 类


def test_plot_cell_structure(tmp_path):
    """
    @brief 测试 Visualizer.plot_cell_structure 函数
    """
    # 创建一个简单的晶胞
    atoms = [
        Atom(id=0, mass=26.9815, position=np.array([0.0, 0.0, 0.0]), symbol="Al"),
        Atom(
            id=1, mass=26.9815, position=np.array([2.55, 2.55, 2.55]), symbol="Al"
        ),  # sigma=2.55 Å
    ]
    lattice_vectors = np.eye(3) * 5.1  # 示例晶格向量
    cell = Cell(atoms=atoms, lattice_vectors=lattice_vectors)

    # 创建 Visualizer 实例
    visualizer = Visualizer()

    # 调用绘图函数，捕获图形对象
    try:
        fig, ax = visualizer.plot_cell_structure(cell, show=False)
        assert isinstance(fig, plt.Figure), "返回的对象不是 Matplotlib Figure"
        assert isinstance(ax, Axes3D), "返回的对象不是 Matplotlib Axes3D"

        # 检查是否绘制了正确数量的原子
        scatter = [
            child for child in ax.get_children() if isinstance(child, PathCollection)
        ]
        total_points = 0  # 记录所有散点的数量
        for path_collection in scatter:
            offsets = path_collection._offsets3d
            x_data, y_data, z_data = offsets
            total_points += len(x_data)

        # 检查总的原子散点数是否匹配
        assert total_points == len(
            atoms
        ), f"Expected {len(atoms)} atoms plotted, found {total_points}"

        # 保存图形到指定文件夹
        plot_path = tmp_path / "cell_structure.png"
        fig.savefig(plot_path)
        assert os.path.exists(plot_path), "Plot file was not saved successfully."

    except Exception as e:
        pytest.fail(f"绘图函数抛出异常: {e}")


def test_plot_stress_strain():
    """
    @brief 测试 Visualizer.plot_stress_strain 函数，使用随机数据
    """
    strain_data = np.random.rand(10, 6)  # 生成随机应变数据
    stress_data = np.random.rand(10, 6)  # 生成随机应力数据

    # 创建 Visualizer 实例
    visualizer = Visualizer()

    try:
        fig, ax = visualizer.plot_stress_strain(strain_data, stress_data, show=False)
        assert isinstance(fig, plt.Figure), "返回的对象不是 Matplotlib Figure"
        assert isinstance(ax, plt.Axes), "返回的对象不是 Matplotlib Axes"
    except Exception as e:
        pytest.fail(f"绘图函数抛出异常: {e}")


def test_plot_stress_strain_with_zero_data():
    """
    @brief 测试 Visualizer.plot_stress_strain 函数，使用全零数据
    """
    strain_data = np.zeros((10, 6))  # 全零应变数据
    stress_data = np.zeros((10, 6))  # 全零应力数据

    # 创建 Visualizer 实例
    visualizer = Visualizer()

    try:
        fig, ax = visualizer.plot_stress_strain(strain_data, stress_data, show=False)
        assert isinstance(fig, plt.Figure), "返回的对象不是 Matplotlib Figure"
        assert isinstance(ax, plt.Axes), "返回的对象不是 Matplotlib Axes"
    except Exception as e:
        pytest.fail(f"绘图函数抛出异常: {e}")


def test_plot_stress_strain_with_mismatched_data():
    """
    @brief 测试 Visualizer.plot_stress_strain 函数，使用不匹配大小的数据
    """
    strain_data = np.random.rand(10, 6)  # 10x6 的应变数据
    stress_data = np.random.rand(8, 6)  # 8x6 的应力数据，不匹配

    # 创建 Visualizer 实例
    visualizer = Visualizer()

    with pytest.raises(ValueError):
        visualizer.plot_stress_strain(strain_data, stress_data)


def test_plot_empty_cell_structure():
    """
    @brief 测试空晶胞结构的绘图行为
    """
    atoms = []  # 空原子列表
    lattice_vectors = np.eye(3) * 5.1  # 示例晶格向量
    cell = Cell(atoms=atoms, lattice_vectors=lattice_vectors)

    # 创建 Visualizer 实例
    visualizer = Visualizer()

    # 调用绘图函数，捕获图形对象
    fig, ax = visualizer.plot_cell_structure(cell, show=False)
    assert isinstance(fig, plt.Figure), "返回的对象不是 Matplotlib Figure"
    assert isinstance(ax, Axes3D), "返回的对象不是 Matplotlib Axes3D"

    # 检查没有绘制任何原子
    scatter = [
        child for child in ax.get_children() if isinstance(child, PathCollection)
    ]
    assert len(scatter) == 0, "在空晶胞结构中不应有任何原子绘制"


