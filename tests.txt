tests/
    test_cpp_interface.py
    test_deformation.py
    test_elasticity.py
    test_lj.py
    test_md.py
    test_mechanics.py
    test_nose_hoover.py
    test_optimizers.py
    test_pbc.py
    test_potentials.py
    test_structure.py
    test_utils.py
    test_visualization.py
# tests/test_cpp_interface.py

import pytest
import numpy as np
from python.interfaces.cpp_interface import CppInterface
from python.structure import Atom, Cell
from python.potentials import LennardJonesPotential


@pytest.fixture
def lj_interface():
    return CppInterface("lennard_jones")


@pytest.fixture
def stress_calculator_interface():
    return CppInterface("stress_calculator")


@pytest.fixture
def nose_hoover_interface():
    return CppInterface("nose_hoover")


@pytest.fixture
def nose_hoover_chain_interface():
    return CppInterface("nose_hoover_chain")


def test_calculate_energy(lj_interface):
    """
    测试 C++ 实现的 Lennard-Jones 势能计算函数
    """
    num_atoms = 2
    positions = np.array(
        [0.0, 0.0, 0.0, 2.55, 0.0, 0.0], dtype=np.float64
    )  # 两个原子，距离 r = σ = 2.55 Å
    box_lengths = np.array([5.1, 5.1, 5.1], dtype=np.float64)  # 模拟盒子长度

    energy = lj_interface.calculate_energy(
        num_atoms,
        positions,
        epsilon=0.0103,
        sigma=2.55,
        cutoff=2.5 * 2.55,
        box_lengths=box_lengths,
    )

    # 检查能量是否为浮点数
    assert isinstance(energy, float), "Energy is not a float."

    # 根据 r = sigma, 势能应为 0
    expected_energy = 0.0

    assert np.isclose(
        energy, expected_energy, atol=1e-6
    ), f"Energy {energy} is not close to expected {expected_energy}."


def test_calculate_forces(lj_interface):
    """
    测试 C++ 实现的 Lennard-Jones 势能计算力函数
    """
    num_atoms = 2
    positions = np.array([0.0, 0.0, 0.0, 2.55, 0.0, 0.0], dtype=np.float64)
    box_lengths = np.array([5.1, 5.1, 5.1], dtype=np.float64)
    forces = np.zeros_like(positions, dtype=np.float64)

    lj_interface.calculate_forces(
        num_atoms,
        positions,
        forces,
        epsilon=0.0103,
        sigma=2.55,
        cutoff=2.5 * 2.55,
        box_lengths=box_lengths,
    )

    # 重新形状为 (num_atoms, 3)
    forces = forces.reshape((num_atoms, 3))

    # 计算期望的力
    epsilon = 0.0103

    # 理论上，在 r = sigma，力 = 24 * epsilon
    expected_force_theory = 24.0 * epsilon  # 0.2472 eV/Å

    # 检查力是否接近理论值
    np.testing.assert_allclose(forces[0, 0], expected_force_theory, atol=1e-6)
    np.testing.assert_allclose(forces[1, 0], -expected_force_theory, atol=1e-6)
    # 其他方向的力应为零
    np.testing.assert_allclose(forces[:, 1:], 0.0, atol=1e-6)


def test_nose_hoover(nose_hoover_interface):
    """
    测试 C++ 实现的 Nose-Hoover 恒温器函数
    """
    dt = 1.0
    num_atoms = 2
    masses = np.array([1.0, 1.0], dtype=np.float64)
    velocities = np.array([0.0, 0.0, 0.0, 1.0, 0.0, 0.0], dtype=np.float64)
    forces = np.array([0.0, 0.0, 0.0, -1.0, 0.0, 0.0], dtype=np.float64)
    xi = 0.0
    Q = 10.0
    target_temperature = 300.0

    # C++ 函数 expects a pointer to xi, so create a mutable array
    xi_array = np.array([xi], dtype=np.float64)

    updated_xi = nose_hoover_interface.nose_hoover(
        dt,
        num_atoms,
        masses,
        velocities,
        forces,
        xi_array,  # 传递数组
        Q,
        target_temperature,
    )

    # Check that xi has been updated
    assert isinstance(updated_xi, float), "xi is not a float."
    # 根据实现，xi 应该有变化
    assert (
        updated_xi != xi
    ), f"xi was not updated. Original: {xi}, Updated: {updated_xi}"


def test_nose_hoover_chain(nose_hoover_chain_interface):
    """
    测试 C++ 实现的 Nose-Hoover 链恒温器函数
    """
    dt = 1.0
    num_atoms = 2
    masses = np.array([1.0, 1.0], dtype=np.float64)
    velocities = np.array([0.0, 0.0, 0.0, 1.0, 0.0, 0.0], dtype=np.float64)
    forces = np.array([0.0, 0.0, 0.0, -1.0, 0.0, 0.0], dtype=np.float64)
    xi_chain = np.zeros(2, dtype=np.float64)  # 假设链长度为 2
    Q = np.array([10.0, 10.0], dtype=np.float64)
    chain_length = 2
    target_temperature = 300.0

    nose_hoover_chain_interface.nose_hoover_chain(
        dt,
        num_atoms,
        masses,
        velocities,
        forces,
        xi_chain,
        Q,
        chain_length,
        target_temperature,
    )

    # Check that xi_chain has been updated
    assert isinstance(xi_chain, np.ndarray), "xi_chain is not a numpy array."
    assert xi_chain.shape == (chain_length,), "xi_chain shape mismatch."
    # 检查是否有变化
    assert not np.all(xi_chain == 0.0), "xi_chain was not updated."


# tests/test_deformation.py

import pytest
import numpy as np
from python.deformation import Deformer


def test_generate_deformation_matrices():
    """
    @brief 测试生成变形矩阵的方法
    """
    delta = 0.01  # 1% 的应变
    deformer = Deformer(delta)
    deformation_matrices = deformer.generate_deformation_matrices()

    # 检查是否生成了 6 个变形矩阵
    assert len(deformation_matrices) == 6

    # 检查每个变形矩阵的正确性
    for i, F in enumerate(deformation_matrices):
        # 检查矩阵是否为 3x3
        assert F.shape == (3, 3)

        # 检查矩阵是否为单位矩阵加上微小变形
        expected_F = np.identity(3)
        if i < 3:
            expected_F[i, i] += delta
        else:
            shear_indices = [(0, 1), (0, 2), (1, 2)]
            idx = i - 3
            i_shear, j_shear = shear_indices[idx]
            expected_F[i_shear, j_shear] += delta / 2
            expected_F[j_shear, i_shear] += delta / 2
        np.testing.assert_array_almost_equal(F, expected_F, decimal=6)


def test_apply_deformation(cell_fixture):
    """
    @brief 测试对晶胞施加变形矩阵的方法
    """
    delta = 0.01
    deformer = Deformer(delta)
    deformation_matrix = deformer.generate_deformation_matrices()[0]  # ε_xx
    original_lattice = cell_fixture.lattice_vectors.copy()
    original_positions = [atom.position.copy() for atom in cell_fixture.atoms]

    deformer.apply_deformation(cell_fixture, deformation_matrix)

    # 检查晶格矢量是否正确更新
    expected_lattice = np.dot(original_lattice, deformation_matrix.T)
    np.testing.assert_array_almost_equal(
        cell_fixture.lattice_vectors, expected_lattice, decimal=6
    )

    # 检查原子位置是否正确更新
    for original_pos, atom in zip(original_positions, cell_fixture.atoms):
        expected_pos = np.dot(deformation_matrix, original_pos)
        np.testing.assert_array_almost_equal(atom.position, expected_pos, decimal=6)


@pytest.fixture
def cell_fixture():
    """
    @fixture 创建一个简单的晶胞，用于测试
    """
    from python.structure import Atom, Cell

    mass_amu = 26.9815  # amu
    position = np.array([0.0, 0.0, 0.0])
    atom = Atom(id=0, symbol="Al", mass_amu=mass_amu, position=position)
    lattice_vectors = np.eye(3) * 4.05  # Å
    cell = Cell(lattice_vectors, [atom], pbc_enabled=True)
    return cell


# tests/test_elasticity.py

import pytest
import numpy as np
from datetime import datetime
from python.structure import Atom, Cell
from python.potentials import LennardJonesPotential
from python.elasticity import ElasticConstantsCalculator
import logging

# 配置日志
logging.basicConfig(
    level=logging.DEBUG, format="%(asctime)s - %(name)s - %(levelname)s - %(message)s"
)
logger = logging.getLogger(__name__)


@pytest.fixture(scope="session", autouse=True)
def configure_logging():
    """
    配置日志以在测试期间输出到控制台和文件。
    """
    logger = logging.getLogger()
    logger.setLevel(logging.DEBUG)  # 设置全局日志级别

    # 创建控制台处理器
    ch = logging.StreamHandler()
    ch.setLevel(logging.DEBUG)  # 控制台日志级别
    formatter = logging.Formatter(
        "%(asctime)s - %(name)s - %(levelname)s - %(message)s"
    )
    ch.setFormatter(formatter)
    logger.addHandler(ch)

    # 获取当前时间并格式化为字符串
    current_time = datetime.now().strftime("%Y%m%d_%H%M%S")
    log_filename = f"test_elasticity_{current_time}.log"  # 生成带时间戳的日志文件名

    # 创建文件处理器
    fh = logging.FileHandler(log_filename, encoding="utf-8")
    fh.setLevel(logging.DEBUG)  # 文件日志级别
    fh.setFormatter(formatter)
    logger.addHandler(fh)

    yield

    # 测试结束后移除处理器
    logger.removeHandler(ch)
    logger.removeHandler(fh)


def test_elastic_constants_calculator():
    """
    @brief 测试 ElasticConstantsCalculator 计算弹性常数
    """
    logger = logging.getLogger(__name__)
    logger.debug("Starting Elastic Constants Calculator Test.")

    # 创建更复杂的晶胞，例如面心立方 (FCC) 晶格，增加原子数量
    atoms = []
    lattice_constant = 5.1  # Å
    repetitions = 2  # 2x2x2 单位晶胞
    for i in range(repetitions):
        for j in range(repetitions):
            for k in range(repetitions):
                base = np.array([i, j, k]) * lattice_constant
                positions = [
                    base + np.array([0.0, 0.0, 0.0]),
                    base + np.array([0.0, 0.5, 0.5]),
                    base + np.array([0.5, 0.0, 0.5]),
                    base + np.array([0.5, 0.5, 0.0]),
                ]
                for pos in positions:
                    atoms.append(
                        Atom(id=len(atoms), symbol="Al", mass_amu=26.9815, position=pos)
                    )

    lattice_vectors = np.eye(3) * lattice_constant * repetitions  # 扩展晶胞大小
    cell = Cell(lattice_vectors=lattice_vectors, atoms=atoms, pbc_enabled=True)
    logger.debug(f"Created cell with {len(atoms)} atoms.")

    # 定义 Lennard-Jones 势能
    epsilon = 0.0103  # eV
    sigma = 2.55  # Å
    cutoff = 2.5 * sigma  # Å
    lj_potential = LennardJonesPotential(epsilon=epsilon, sigma=sigma, cutoff=cutoff)
    logger.debug("Initialized Lennard-Jones potential.")

    # 创建 ElasticConstantsCalculator 实例
    elastic_calculator = ElasticConstantsCalculator(
        cell=cell,
        potential=lj_potential,
        delta=1e-3,
        optimizer_type="GD",  # 使用梯度下降优化器
    )
    logger.debug(
        "Initialized ElasticConstantsCalculator with Gradient Descent Optimizer."
    )

    # 计算弹性常数
    C_in_GPa = elastic_calculator.calculate_elastic_constants()
    logger.debug("Elastic constants calculation completed.")

    # 输出计算的弹性常数
    logger.debug("Computed Elastic Constants (GPa):")
    logger.debug(C_in_GPa)

    # 检查 C_in_GPa 是一个 6x6 的矩阵
    assert C_in_GPa.shape == (6, 6), "弹性常数矩阵形状不匹配。"
    logger.debug("Shape of Elastic Constants matrix is correct (6x6).")

    # 检查对称性
    symmetry = np.allclose(C_in_GPa, C_in_GPa.T, atol=1e-3)
    logger.debug(f"Symmetry check: {symmetry}")
    assert symmetry, "弹性常数矩阵不是对称的。"

    # 检查对角元素为正
    for i in range(6):
        logger.debug(f"C_in_GPa[{i},{i}] = {C_in_GPa[i, i]}")
        assert C_in_GPa[i, i] > 0, f"弹性常数 C[{i},{i}] 不是正值。"

    # 检查非对角元素在合理范围内
    for i in range(6):
        for j in range(i + 1, 6):
            logger.debug(f"C_in_GPa[{i},{j}] = {C_in_GPa[i, j]}")
            assert (
                0.0 <= C_in_GPa[i, j] <= 100.0
            ), f"弹性常数 C[{i},{j}] 不在合理范围内。"

    # 进一步检查弹性常数是否在预期范围内
    # 例如，对角元素 (C11, C22, ...) 通常在 50-100 GPa
    # 剪切模量 (C44, C55, C66) 通常在 10-30 GPa
    for i in range(3):
        logger.debug(f"C_in_GPa[{i},{i}] = {C_in_GPa[i, i]}")
        assert (
            50.0 <= C_in_GPa[i, i] <= 100.0
        ), f"C[{i},{i}] = {C_in_GPa[i, i]} GPa 不在预期范围内。"
    for i in range(3, 6):
        logger.debug(f"C_in_GPa[{i},{i}] = {C_in_GPa[i, i]}")
        assert (
            10.0 <= C_in_GPa[i, i] <= 30.0
        ), f"C[{i},{i}] = {C_in_GPa[i, i]} GPa 不在预期范围内。"

    logger.debug("Elastic Constants Calculator Test Passed.")


# tests/test_lj.py

import pytest
import numpy as np
import logging
from python.structure import Atom, Cell
from python.potentials import LennardJonesPotential


# 配置日志
@pytest.fixture(scope="session", autouse=True)
def configure_logging():
    """
    配置日志以在测试期间输出到控制台和文件。
    """
    logger = logging.getLogger()
    logger.setLevel(logging.DEBUG)  # 设置全局日志级别

    # 创建控制台处理器
    ch = logging.StreamHandler()
    ch.setLevel(logging.DEBUG)  # 控制台日志级别
    formatter = logging.Formatter(
        "%(asctime)s - %(name)s - %(levelname)s - %(message)s"
    )
    ch.setFormatter(formatter)
    logger.addHandler(ch)

    # 创建文件处理器
    fh = logging.FileHandler("test_potential.log", encoding="utf-8")
    fh.setLevel(logging.DEBUG)  # 文件日志级别
    fh.setFormatter(formatter)
    logger.addHandler(fh)

    yield
    # 测试结束后，可以在这里添加清理代码（如果需要）


def test_lj_potential_at_r_m():
    """
    @brief 测试 Lennard-Jones 势在 r = r_m (2^(1/6)*sigma) 时的势能和力。
    """
    logger = logging.getLogger(__name__)
    epsilon = 0.0103  # eV
    sigma = 2.55  # Å
    cutoff = 2.5 * sigma
    lj_potential = LennardJonesPotential(epsilon=epsilon, sigma=sigma, cutoff=cutoff)

    # 计算 r_m = 2^(1/6) * sigma
    r_m = 2 ** (1 / 6) * sigma

    # 创建两个原子，距离为 r_m
    atoms = [
        Atom(
            id=0,
            mass_amu=26.9815,
            position=np.array([0.0, 0.0, 0.0]),
            symbol="Al",
        ),
        Atom(
            id=1,
            mass_amu=26.9815,
            position=np.array([r_m, 0.0, 0.0]),
            symbol="Al",
        ),
    ]
    lattice_vectors = np.eye(3) * (sigma * 3)  # 确保盒子足够大
    cell = Cell(lattice_vectors=lattice_vectors, atoms=atoms, pbc_enabled=True)

    # 计算势能和力
    energy = lj_potential.calculate_energy(cell)
    lj_potential.calculate_forces(cell)
    forces = cell.get_forces()

    # 断言
    assert np.isclose(
        energy, -epsilon, atol=1e-6
    ), f"Energy at r_m should be -epsilon, got {energy}"
    assert np.allclose(
        forces, 0.0, atol=1e-6
    ), f"Forces at r_m should be zero, got {forces}"
    logger.debug(f"LJ Potential at r_m: Energy = {energy} eV, Forces = {forces}")


# tests/test_md.py

import pytest
import numpy as np

from python.md_simulator import MDSimulator
from python.integrators import VelocityVerletIntegrator
from python.thermostats import NoseHooverThermostat

from python.structure import Atom, Cell
from python.potentials import LennardJonesPotential


@pytest.fixture
def simple_cell(pbc_enabled=True):
    """
    @fixture 创建一个简单的晶胞，包含两个原子。
    """
    lattice_vectors = np.eye(3) * 6.0 if pbc_enabled else np.eye(3) * 1e8  # Å
    mass_amu = 26.9815  # amu (Aluminum)
    position1 = np.array([0.0, 0.0, 0.0])
    position2 = np.array([2.55, 0.0, 0.0])  # 与原子1相距 σ = 2.55 Å
    atom1 = Atom(id=0, symbol="Al", mass_amu=mass_amu, position=position1)
    atom2 = Atom(id=1, symbol="Al", mass_amu=mass_amu, position=position2)
    cell = Cell(
        lattice_vectors=lattice_vectors, atoms=[atom1, atom2], pbc_enabled=pbc_enabled
    )
    return cell


@pytest.fixture
def lj_potential():
    """
    @fixture 定义 Lennard-Jones 势。
    """
    epsilon = 0.0103  # eV
    sigma = 2.55  # Å
    cutoff = 2.5 * sigma
    return LennardJonesPotential(epsilon=epsilon, sigma=sigma, cutoff=cutoff)


@pytest.fixture
def integrator():
    """
    @fixture 定义积分器。
    """
    return VelocityVerletIntegrator()


@pytest.fixture
def thermostat():
    """
    @fixture 定义恒温器。
    """
    return NoseHooverThermostat(target_temperature=300, time_constant=100)


def test_md_simulation(simple_cell, lj_potential, integrator):
    """
    @brief 测试分子动力学模拟器的运行。
    """
    md_simulator = MDSimulator(
        cell=simple_cell,
        potential=lj_potential,
        integrator=integrator,
        thermostat=None,
    )
    md_simulator.run(steps=10, dt=1.0)  # dt 单位为 fs

    # 检查原子的位置和速度是否发生变化
    atom1 = simple_cell.atoms[0]
    atom2 = simple_cell.atoms[1]
    assert not np.allclose(atom1.position, [0.0, 0.0, 0.0]), "原子1的位置未发生变化。"
    assert not np.allclose(atom2.position, [2.55, 0.0, 0.0]), "原子2的位置未发生变化。"
    assert not np.allclose(atom1.velocity, [0.0, 0.0, 0.0]), "原子1的速度未发生变化。"
    assert not np.allclose(atom2.velocity, [0.0, 0.0, 0.0]), "原子2的速度未发生变化。"


def test_md_simulation_with_thermostat(
    simple_cell, lj_potential, integrator, thermostat
):
    """
    @brief 测试分子动力学模拟器的运行，带恒温器。
    """
    md_simulator = MDSimulator(
        cell=simple_cell,
        potential=lj_potential,
        integrator=integrator,
        thermostat=thermostat,
    )
    md_simulator.run(steps=10, dt=1.0)  # dt 单位为 fs

    # 检查原子的位置和速度是否发生变化
    atom1 = simple_cell.atoms[0]
    atom2 = simple_cell.atoms[1]
    assert not np.allclose(atom1.position, [0.0, 0.0, 0.0]), "原子1的位置未发生变化。"
    assert not np.allclose(atom2.position, [2.55, 0.0, 0.0]), "原子2的位置未发生变化。"
    assert not np.allclose(atom1.velocity, [0.0, 0.0, 0.0]), "原子1的速度未发生变化。"
    assert not np.allclose(atom2.velocity, [0.0, 0.0, 0.0]), "原子2的速度未发生变化。"

    # 检查 xi 是否被更新
    assert thermostat.xi[0] != 0.0, "xi 未被更新。"


# tests/test_mechanics.py

import pytest
import numpy as np
from python.structure import Atom, Cell
from python.potentials import LennardJonesPotential
from python.elasticity import (
    ElasticConstantsSolver,
    StrainCalculator,
)  # 确保导入 StrainCalculator
from python.mechanics import StressCalculatorLJ


@pytest.fixture
def single_atom_cell():
    atoms = [
        Atom(
            id=0,
            mass_amu=26.9815,
            position=np.array([0.0, 0.0, 0.0]),
            symbol="Al",
        )
    ]
    lattice_vectors = np.eye(3) * 5.1
    return Cell(lattice_vectors=lattice_vectors, atoms=atoms, pbc_enabled=True)


@pytest.fixture
def lj_potential_single():
    return LennardJonesPotential(epsilon=0.0103, sigma=2.55, cutoff=2.5 * 2.55)


def test_stress_calculation(single_atom_cell, lj_potential_single):
    """
    @brief 测试应力计算器的功能。
    """
    stress_calculator = StressCalculatorLJ()
    # 计算力
    lj_potential_single.calculate_forces(single_atom_cell)
    # 计算应力
    stress_tensor = stress_calculator.compute_stress(
        single_atom_cell, lj_potential_single
    )
    # 由于只有一个原子，理论上应力张量应为零
    expected_stress = np.zeros((3, 3))
    np.testing.assert_array_almost_equal(stress_tensor, expected_stress, decimal=6)


def test_elastic_constants_solver():
    """
    @brief 测试弹性常数求解器的功能。
    """
    strains = [
        np.array([0.0, 0.0, 0.0, 0.0, 0.0, 0.0]),
        np.array([0.01, 0.0, 0.0, 0.0, 0.0, 0.0]),
        np.array([0.0, 0.01, 0.0, 0.0, 0.0, 0.0]),
        np.array([0.0, 0.0, 0.01, 0.0, 0.0, 0.0]),
        np.array([0.0, 0.0, 0.0, 0.01, 0.0, 0.0]),
        np.array([0.0, 0.0, 0.0, 0.0, 0.01, 0.0]),
        np.array([0.0, 0.0, 0.0, 0.0, 0.0, 0.01]),
    ]
    stresses = [
        np.array([0.0, 0.0, 0.0, 0.0, 0.0, 0.0]),
        np.array([69.0, 0.0, 0.0, 0.0, 0.0, 0.0]),
        np.array([0.0, 69.0, 0.0, 0.0, 0.0, 0.0]),
        np.array([0.0, 0.0, 69.0, 0.0, 0.0, 0.0]),
        np.array([0.0, 0.0, 0.0, 23.0, 0.0, 0.0]),
        np.array([0.0, 0.0, 0.0, 0.0, 23.0, 0.0]),
        np.array([0.0, 0.0, 0.0, 0.0, 0.0, 23.0]),
    ]
    solver = ElasticConstantsSolver()
    C = solver.solve(strains, stresses)
    # 检查 C 是否为 6x6 矩阵
    assert C.shape == (6, 6), "Elastic constants matrix shape mismatch."
    # 预期弹性常数矩阵（修正后的值）
    expected_C = np.array(
        [
            [6900.0, 0.0, 0.0, 0.0, 0.0, 0.0],
            [0.0, 6900.0, 0.0, 0.0, 0.0, 0.0],
            [0.0, 0.0, 6900.0, 0.0, 0.0, 0.0],
            [0.0, 0.0, 0.0, 2300.0, 0.0, 0.0],
            [0.0, 0.0, 0.0, 0.0, 2300.0, 0.0],
            [0.0, 0.0, 0.0, 0.0, 0.0, 2300.0],
        ]
    )
    # 检查弹性常数矩阵是否接近预期值
    np.testing.assert_array_almost_equal(C, expected_C, decimal=2)


def test_force_direction():
    """
    @brief 验证力的方向是否为负梯度方向。
    """
    # 创建一个简单的晶胞
    atoms = [
        Atom(id=0, mass_amu=26.9815, position=np.array([0.0, 0.0, 0.0]), symbol="Al"),
        Atom(
            id=1, mass_amu=26.9815, position=np.array([2.55, 2.55, 2.55]), symbol="Al"
        ),
    ]
    lattice_vectors = np.eye(3) * 5.1  # 示例晶格向量
    cell = Cell(lattice_vectors=lattice_vectors, atoms=atoms, pbc_enabled=True)

    # 定义 Lennard-Jones 势
    epsilon = 0.0103  # eV
    sigma = 2.55  # Å
    cutoff = 2.5 * sigma  # Å
    lj_potential = LennardJonesPotential(epsilon=epsilon, sigma=sigma, cutoff=cutoff)

    # 计算初始能量和力
    initial_energy = lj_potential.calculate_energy(cell)
    initial_force = cell.get_forces()

    # 计算能量的数值梯度近似
    delta = 1e-5
    expected_force = np.zeros_like(initial_force)
    for i in range(cell.num_atoms):
        for dim in range(3):
            # 正向微小位移
            displaced = cell.copy()
            displaced.atoms[i].position[dim] += delta
            energy_displaced = lj_potential.calculate_energy(displaced)
            # 负梯度近似
            expected_force[i, dim] = -(energy_displaced - initial_energy) / delta

    # 检查力方向是否接近负梯度方向
    np.testing.assert_array_almost_equal(initial_force, expected_force, decimal=3)


def test_strain_calculation():
    """
    @brief 测试 StrainCalculator 计算应变的正确性。
    """
    # 创建一个样本变形矩阵 F
    delta = 1e-3  # 0.1% 应变
    F = np.array([[1 + delta, 0, 0], [0, 1 + delta, 0], [0, 0, 1 + delta]])

    # 预期的应变张量: epsilon = (F + F^T)/2 - I = delta * I
    expected_strain = np.array([delta, delta, delta, 0, 0, 0])  # Voigt 表示法

    # 初始化 StrainCalculator
    strain_calculator = StrainCalculator()

    # 计算应变
    strain_voigt = strain_calculator.compute_strain(F)

    # 检查计算的应变是否为 NumPy 数组
    assert isinstance(strain_voigt, np.ndarray), "应变向量应为 NumPy 数组。"

    # 检查应变向量的形状
    assert strain_voigt.shape == (6,), "应变向量的形状应为 (6,)。"

    # 检查计算的应变是否与预期值匹配
    np.testing.assert_array_almost_equal(strain_voigt, expected_strain, decimal=6)


# tests/test_nose_hoover.py

import pytest
import numpy as np
from python.thermostats import NoseHooverThermostat
from python.structure import Atom, Cell
from python.utils import AMU_TO_EVFSA2


@pytest.fixture
def nose_hoover_thermostat():
    """
    @fixture 定义 Nose-Hoover 恒温器。
    """
    return NoseHooverThermostat(target_temperature=300, time_constant=100)


def test_nose_hoover_apply(nose_hoover_thermostat):
    """
    @brief 测试 Nose-Hoover 恒温器的 apply 方法。
    """
    # 创建一个简单的晶胞，包含两个原子
    atoms = [
        Atom(
            id=0,
            symbol="Al",
            mass_amu=26.9815,  # 转换为 eV/fs^2
            position=np.array([0.0, 0.0, 0.0]),
            velocity=np.array([1.0, 0.0, 0.0]),
        ),
        Atom(
            id=1,
            symbol="Al",
            mass_amu=26.9815,  # 转换为 eV/fs^2
            position=np.array([2.55, 0.0, 0.0]),
            velocity=np.array([-1.0, 0.0, 0.0]),
        ),
    ]

    # 初始化力
    for atom in atoms:
        atom.force = np.array([0.0, 0.0, 0.0])

    # 应用恒温器
    dt = 1.0  # fs
    nose_hoover_thermostat.apply(atoms, dt)

    # 检查 xi 是否被更新
    assert nose_hoover_thermostat.xi[0] != 0.0, "xi 未被更新。"

    # 检查速度是否被更新（根据恒温器的实现，速度应被缩放）
    # 由于初始力为零，速度应只受 xi 影响，具体变化取决于 C++ 实现
    # 这里只检查速度是否发生变化
    assert not np.allclose(atoms[0].velocity, [1.0, 0.0, 0.0]), "原子1的速度未被更新。"
    assert not np.allclose(atoms[1].velocity, [-1.0, 0.0, 0.0]), "原子2的速度未被更新。"


import pytest
import numpy as np
import logging
from python.structure import Atom, Cell
from python.potentials import LennardJonesPotential
from python.optimizers import (
    GradientDescentOptimizer,
    BFGSOptimizer,
    LBFGSOptimizer,
)


# 配置日志
@pytest.fixture(scope="session", autouse=True)
def configure_logging():
    """
    配置日志以在测试期间输出到控制台和文件。
    """
    logger = logging.getLogger()
    logger.setLevel(logging.DEBUG)  # 设置全局日志级别

    # 创建控制台处理器
    ch = logging.StreamHandler()
    ch.setLevel(logging.DEBUG)  # 控制台日志级别
    formatter = logging.Formatter(
        "%(asctime)s - %(name)s - %(levelname)s - %(message)s"
    )
    ch.setFormatter(formatter)
    logger.addHandler(ch)

    # 创建文件处理器
    fh = logging.FileHandler("test_optimizers.log", encoding="utf-8")
    fh.setLevel(logging.DEBUG)  # 文件日志级别
    fh.setFormatter(formatter)
    logger.addHandler(fh)

    yield


@pytest.fixture
def lj_potential_optim():
    """
    创建一个 Lennard-Jones 势能对象，用于优化测试。
    """
    return LennardJonesPotential(epsilon=0.0103, sigma=2.55, cutoff=2.5 * 2.55)


@pytest.fixture
def cell_with_multiple_atoms():
    """
    创建一个包含多个原子的晶胞，模拟更复杂的系统。
    """
    sigma = 2.55
    r_m = 2 ** (1 / 6) * sigma
    delta = 0.1  # Å

    atoms = [
        Atom(
            id=i,
            mass_amu=26.9815,
            position=np.array([i * (r_m + delta), 0.0, 0.0]),
            symbol="Al",
        )
        for i in range(4)  # 增加多个原子
    ]
    lattice_vectors = np.eye(3) * (sigma * 6)  # 增加晶胞大小
    cell = Cell(lattice_vectors=lattice_vectors, atoms=atoms, pbc_enabled=False)
    return cell


def test_gradient_descent_optimizer(lj_potential_optim, cell_with_multiple_atoms):
    """
    测试梯度下降优化器，使用多个原子，无周期性边界条件。
    """
    logger = logging.getLogger(__name__)
    optimizer = GradientDescentOptimizer(
        max_steps=10000, tol=1e-3, step_size=1e-2, energy_tol=1e-4
    )
    cell = cell_with_multiple_atoms

    optimizer.optimize(cell, lj_potential_optim)

    assert optimizer.converged, "Gradient Descent Optimizer did not converge"

    energy = lj_potential_optim.calculate_energy(cell)
    forces = cell.get_forces()
    logger.debug(f"Gradient Descent - Post-optimization Energy: {energy:.6f} eV")
    logger.debug(f"Gradient Descent - Post-optimization Forces: {forces}")


# def test_bfgs_optimizer(lj_potential_optim, cell_with_multiple_atoms):
#     """
#     @brief 测试 BFGS 优化器。
#     """
#     logger = logging.getLogger(__name__)
#     optimizer = BFGSOptimizer(tol=1e-3, maxiter=10000)
#     cell = cell_with_multiple_atoms

#     logger.debug("开始 BFGS 优化测试...")

#     optimizer.optimize(cell, lj_potential_optim)

#     # 检查优化是否收敛
#     assert optimizer.converged, "BFGS Optimizer did not converge"

#     # 输出优化后的能量和力
#     energy = lj_potential_optim.calculate_energy(cell)
#     forces = cell.get_forces()
#     logger.debug(f"BFGS Optimizer - Post-optimization Energy: {energy:.6f} eV")
#     logger.debug(f"BFGS Optimizer - Post-optimization Forces: {forces}")

#     logger.debug("BFGS 优化测试结束。")


# def test_lbfgs_optimizer(lj_potential_optim, cell_with_multiple_atoms):
#     """
#     @brief 测试 L-BFGS 优化器。
#     """
#     logger = logging.getLogger(__name__)
#     optimizer = LBFGSOptimizer(tol=1e-3, maxiter=10000)
#     cell = cell_with_multiple_atoms

#     logger.debug("开始 L-BFGS 优化测试...")

#     optimizer.optimize(cell, lj_potential_optim)

#     # 检查优化是否收敛
#     assert optimizer.converged, "L-BFGS Optimizer did not converge"

#     # 输出优化后的能量和力
#     energy = lj_potential_optim.calculate_energy(cell)
#     forces = cell.get_forces()
#     logger.debug(f"L-BFGS Optimizer - Post-optimization Energy: {energy:.6f} eV")
#     logger.debug(f"L-BFGS Optimizer - Post-optimization Forces: {forces}")

#     logger.debug("L-BFGS 优化测试结束。")


# tests/test_pbc.py

import pytest
import numpy as np
from python.structure import Atom, Cell
import logging
from datetime import datetime

# 配置日志
logging.basicConfig(
    level=logging.DEBUG, format="%(asctime)s - %(name)s - %(levelname)s - %(message)s"
)
logger = logging.getLogger(__name__)


@pytest.fixture(scope="session", autouse=True)
def configure_logging():
    """
    配置日志以在测试期间输出到控制台和文件。
    """
    logger = logging.getLogger()
    logger.setLevel(logging.DEBUG)  # 设置全局日志级别

    # 创建控制台处理器
    ch = logging.StreamHandler()
    ch.setLevel(logging.DEBUG)  # 控制台日志级别
    formatter = logging.Formatter(
        "%(asctime)s - %(name)s - %(levelname)s - %(message)s"
    )
    ch.setFormatter(formatter)
    logger.addHandler(ch)

    # 获取当前时间并格式化为字符串
    current_time = datetime.now().strftime("%Y%m%d_%H%M%S")
    log_filename = f"test_pbc_{current_time}.log"  # 生成带时间戳的日志文件名

    # 创建文件处理器
    fh = logging.FileHandler(log_filename, encoding="utf-8")
    fh.setLevel(logging.DEBUG)  # 文件日志级别
    fh.setFormatter(formatter)
    logger.addHandler(fh)

    yield

    # 测试结束后移除处理器
    logger.removeHandler(ch)
    logger.removeHandler(fh)


def test_apply_periodic_boundary():
    """
    @brief 测试 Cell.apply_periodic_boundary 方法是否正确应用周期性边界条件。
    """
    atoms = [
        Atom(
            id=0, symbol="Al", mass_amu=26.9815, position=[6.0, 6.0, 6.0], velocity=None
        ),
    ]
    lattice_vectors = np.eye(3) * 5.0  # 盒子长度为 5 Å
    cell = Cell(lattice_vectors=lattice_vectors, atoms=atoms, pbc_enabled=True)

    # 应用 PBC
    new_position = cell.apply_periodic_boundary(atoms[0].position)
    expected_position = np.array([1.0, 1.0, 1.0])  # 6 % 5 = 1
    assert np.allclose(
        new_position, expected_position
    ), f"Expected {expected_position}, got {new_position}"
    logger.debug(f"PBC applied correctly: {new_position} == {expected_position}")

    # 测试未启用 PBC
    cell_no_pbc = Cell(lattice_vectors=lattice_vectors, atoms=atoms, pbc_enabled=False)
    new_position_no_pbc = cell_no_pbc.apply_periodic_boundary(atoms[0].position)
    expected_position_no_pbc = np.array([6.0, 6.0, 6.0])
    assert np.allclose(
        new_position_no_pbc, expected_position_no_pbc
    ), f"Expected {expected_position_no_pbc}, got {new_position_no_pbc}"
    logger.debug(
        f"PBC not applied correctly: {new_position_no_pbc} == {expected_position_no_pbc}"
    )


# tests/test_potentials.py

import pytest
import numpy as np
from python.potentials import LennardJonesPotential
from python.structure import Atom, Cell


@pytest.fixture
def lj_potential():
    """
    @fixture 定义 Lennard-Jones 势
    """
    epsilon = 0.0103  # eV
    sigma = 2.55  # Å
    cutoff = 2.5 * sigma
    return LennardJonesPotential(epsilon=epsilon, sigma=sigma, cutoff=cutoff)


@pytest.fixture
def two_atom_cell():
    """
    @fixture 创建一个简单的系统，包含两个原子
    """
    lattice_vectors = np.eye(3) * 4.05  # Å
    mass_amu = 26.9815  # amu
    position1 = np.array([0.0, 0.0, 0.0])
    position2 = np.array([2.025, 0.0, 0.0])  # 2.025 Å
    atom1 = Atom(id=0, symbol="Al", mass_amu=mass_amu, position=position1)
    atom2 = Atom(id=1, symbol="Al", mass_amu=mass_amu, position=position2)
    cell = Cell(lattice_vectors, [atom1, atom2], pbc_enabled=True)
    return cell


def test_force_calculation(lj_potential, two_atom_cell):
    """
    @brief 测试 Lennard-Jones 势的力计算功能
    """
    lj_potential.calculate_forces(two_atom_cell)
    # 检查力是否非零且相反
    force1 = two_atom_cell.atoms[0].force
    force2 = two_atom_cell.atoms[1].force
    np.testing.assert_array_almost_equal(force1, -force2, decimal=10)
    assert not np.allclose(force1, 0)


def test_energy_calculation(lj_potential, two_atom_cell):
    """
    @brief 测试 Lennard-Jones 势的能量计算功能
    """
    energy = lj_potential.calculate_energy(two_atom_cell)
    # 由于只有两个原子且对称位置，能量应等于 4 * epsilon * ( (sigma/r)^12 - (sigma/r)^6 )
    r = np.linalg.norm(
        two_atom_cell.atoms[1].position - two_atom_cell.atoms[0].position
    )
    expected_energy = (
        4.0
        * lj_potential.epsilon
        * ((lj_potential.sigma / r) ** 12 - (lj_potential.sigma / r) ** 6)
    )
    # 由于能量计算可能包括截断修正，此处仅为基本验证
    np.testing.assert_almost_equal(energy, expected_energy, decimal=10)


# tests/test_structure.py

import pytest
import numpy as np
from python.structure import Atom, Cell


@pytest.fixture
def atom():
    """
    @fixture 创建一个原子实例
    """
    position = np.array([0.0, 0.0, 0.0])
    mass_amu = 26.9815  # amu
    return Atom(id=0, symbol="Al", mass_amu=mass_amu, position=position)


@pytest.fixture
def cell(atom):
    """
    @fixture 创建一个晶胞实例，包含一个原子
    """
    lattice_vectors = np.eye(3) * 4.05  # Å
    return Cell(lattice_vectors, [atom], pbc_enabled=True)


def test_atom_creation(atom):
    """
    @brief 测试原子的创建
    """
    assert atom.id == 0
    assert atom.symbol == "Al"
    np.testing.assert_array_equal(atom.position, np.array([0.0, 0.0, 0.0]))
    assert atom.mass_amu == 26.9815


def test_cell_creation(cell, atom):
    """
    @brief 测试晶胞的创建
    """
    np.testing.assert_array_equal(cell.lattice_vectors, np.eye(3) * 4.05)
    assert len(cell.atoms) == 1
    assert cell.atoms[0] == atom


def test_volume_calculation(cell):
    """
    @brief 测试晶胞体积的计算
    """
    expected_volume = np.linalg.det(cell.lattice_vectors)
    calculated_volume = cell.calculate_volume()
    assert np.isclose(calculated_volume, expected_volume)


def test_apply_periodic_boundary(cell):
    """
    @brief 测试周期性边界条件的应用
    """
    lattice_constant = cell.lattice_vectors[0, 0]  # 假设晶格为立方
    position = np.array(
        [lattice_constant + 1.0, -1.0, lattice_constant + 1.0]
    )  # 超出晶胞范围的坐标
    new_position = cell.apply_periodic_boundary(position)
    # 检查新位置是否在 [0, lattice_constant) 范围内
    assert np.all(new_position >= 0)
    assert np.all(new_position < lattice_constant)


# tests/test_utils.py

import pytest
import numpy as np
from python.utils import TensorConverter, DataCollector
from python.structure import Atom, Cell


def test_tensor_converter_to_voigt():
    """
    @brief 测试 TensorConverter 的 to_voigt 方法
    """
    tensor = np.array([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0]])
    expected_voigt = np.array([1.0, 5.0, 9.0, 6.0, 3.0, 2.0])
    voigt = TensorConverter.to_voigt(tensor)
    np.testing.assert_array_almost_equal(voigt, expected_voigt, decimal=6)


@pytest.fixture
def cell_fixture():
    """
    @fixture 创建一个简单的晶胞，用于数据收集测试
    """
    lattice_vectors = np.eye(3) * 4.05  # Å
    mass_amu = 26.9815  # amu
    position = np.array([0.0, 0.0, 0.0])
    atom = Atom(id=0, symbol="Al", mass_amu=mass_amu, position=position)
    cell = Cell(lattice_vectors, [atom], pbc_enabled=True)
    return cell


def test_data_collector(cell_fixture):
    """
    @brief 测试 DataCollector 的数据收集功能
    """
    collector = DataCollector()
    collector.collect(cell_fixture)
    assert len(collector.data) == 1
    collected = collector.data[0]
    assert "positions" in collected
    assert "velocities" in collected
    assert len(collected["positions"]) == 1
    assert len(collected["velocities"]) == 1
    np.testing.assert_array_equal(
        collected["positions"][0], cell_fixture.atoms[0].position
    )
    np.testing.assert_array_equal(
        collected["velocities"][0], cell_fixture.atoms[0].velocity
    )


# tests/test_visualization.py

import pytest
from python.visualization import Visualizer
from python.structure import Cell, Atom
import numpy as np
import matplotlib
import os

matplotlib.use("Agg")  # 使用无头后端，防止弹出图形窗口
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D  # 导入 Axes3D
from matplotlib.collections import PathCollection  # 导入 PathCollection 类


def test_plot_cell_structure(tmp_path):
    """
    @brief 测试 Visualizer.plot_cell_structure 函数
    """
    # 创建一个简单的晶胞
    atoms = [
        Atom(id=0, mass_amu=26.9815, position=np.array([0.0, 0.0, 0.0]), symbol="Al"),
        Atom(
            id=1, mass_amu=26.9815, position=np.array([2.55, 2.55, 2.55]), symbol="Al"
        ),  # sigma=2.55 Å
    ]
    lattice_vectors = np.eye(3) * 5.1  # 示例晶格向量
    cell = Cell(atoms=atoms, lattice_vectors=lattice_vectors)

    # 创建 Visualizer 实例
    visualizer = Visualizer()

    # 调用绘图函数，捕获图形对象
    try:
        fig, ax = visualizer.plot_cell_structure(cell, show=False)
        assert isinstance(fig, plt.Figure), "返回的对象不是 Matplotlib Figure"
        assert isinstance(ax, Axes3D), "返回的对象不是 Matplotlib Axes3D"

        # 检查是否绘制了正确数量的原子
        scatter = [
            child for child in ax.get_children() if isinstance(child, PathCollection)
        ]
        total_points = 0  # 记录所有散点的数量
        for path_collection in scatter:
            offsets = path_collection._offsets3d
            x_data, y_data, z_data = offsets
            total_points += len(x_data)

        # 检查总的原子散点数是否匹配
        assert total_points == len(
            atoms
        ), f"Expected {len(atoms)} atoms plotted, found {total_points}"

        # 保存图形到指定文件夹
        plot_path = tmp_path / "cell_structure.png"
        fig.savefig(plot_path)
        assert os.path.exists(plot_path), "Plot file was not saved successfully."

    except Exception as e:
        pytest.fail(f"绘图函数抛出异常: {e}")


def test_plot_stress_strain():
    """
    @brief 测试 Visualizer.plot_stress_strain 函数，使用随机数据
    """
    strain_data = np.random.rand(10, 6)  # 生成随机应变数据
    stress_data = np.random.rand(10, 6)  # 生成随机应力数据

    # 创建 Visualizer 实例
    visualizer = Visualizer()

    try:
        fig, ax = visualizer.plot_stress_strain(strain_data, stress_data, show=False)
        assert isinstance(fig, plt.Figure), "返回的对象不是 Matplotlib Figure"
        assert isinstance(ax, plt.Axes), "返回的对象不是 Matplotlib Axes"
    except Exception as e:
        pytest.fail(f"绘图函数抛出异常: {e}")


def test_plot_stress_strain_with_zero_data():
    """
    @brief 测试 Visualizer.plot_stress_strain 函数，使用全零数据
    """
    strain_data = np.zeros((10, 6))  # 全零应变数据
    stress_data = np.zeros((10, 6))  # 全零应力数据

    # 创建 Visualizer 实例
    visualizer = Visualizer()

    try:
        fig, ax = visualizer.plot_stress_strain(strain_data, stress_data, show=False)
        assert isinstance(fig, plt.Figure), "返回的对象不是 Matplotlib Figure"
        assert isinstance(ax, plt.Axes), "返回的对象不是 Matplotlib Axes"
    except Exception as e:
        pytest.fail(f"绘图函数抛出异常: {e}")


def test_plot_stress_strain_with_mismatched_data():
    """
    @brief 测试 Visualizer.plot_stress_strain 函数，使用不匹配大小的数据
    """
    strain_data = np.random.rand(10, 6)  # 10x6 的应变数据
    stress_data = np.random.rand(8, 6)  # 8x6 的应力数据，不匹配

    # 创建 Visualizer 实例
    visualizer = Visualizer()

    with pytest.raises(ValueError):
        visualizer.plot_stress_strain(strain_data, stress_data)


def test_plot_empty_cell_structure():
    """
    @brief 测试空晶胞结构的绘图行为
    """
    atoms = []  # 空原子列表
    lattice_vectors = np.eye(3) * 5.1  # 示例晶格向量
    cell = Cell(atoms=atoms, lattice_vectors=lattice_vectors)

    # 创建 Visualizer 实例
    visualizer = Visualizer()

    # 调用绘图函数，捕获图形对象
    fig, ax = visualizer.plot_cell_structure(cell, show=False)
    assert isinstance(fig, plt.Figure), "返回的对象不是 Matplotlib Figure"
    assert isinstance(ax, Axes3D), "返回的对象不是 Matplotlib Axes3D"

    # 检查没有绘制任何原子
    scatter = [
        child for child in ax.get_children() if isinstance(child, PathCollection)
    ]
    assert len(scatter) == 0, "在空晶胞结构中不应有任何原子绘制"


