tests/
    test_cpp_interface.py
    test_deformation.py
    test_elasticity.py
    test_md.py
    test_mechanics.py
    test_nose_hoover.py
    test_optimizers.py
    test_potentials.py
    test_structure.py
    test_utils.py
    test_visualization.py
# tests/test_cpp_interface.py

import pytest
import numpy as np
from python.interfaces.cpp_interface import CppInterface


@pytest.fixture
def lj_interface():
    """
    @fixture 创建 Lennard-Jones C++ 接口实例
    """
    return CppInterface("lennard_jones")


@pytest.fixture
def stress_interface():
    """
    @fixture 创建 Stress Calculator C++ 接口实例
    """
    return CppInterface("stress_calculator")


@pytest.fixture
def nose_hoover_interface():
    """
    @fixture 创建 Nose-Hoover C++ 接口实例
    """
    return CppInterface("nose_hoover")


def test_calculate_forces(lj_interface):
    """
    @brief 测试 C++ 实现的 Lennard-Jones 力计算函数
    """
    num_atoms = 2
    positions = np.array([0.0, 0.0, 0.0, 2.55, 0.0, 0.0], dtype=np.float64)
    forces = np.zeros_like(positions)
    epsilon = 0.0103
    sigma = 2.55
    cutoff = 2.5 * sigma
    lattice_vectors = np.eye(3, dtype=np.float64).flatten()

    lj_interface.calculate_forces(
        num_atoms,
        positions,
        forces,
        epsilon,
        sigma,
        cutoff,
        lattice_vectors,
    )

    # 检查力是否非零且相反
    force1 = forces[0:3]
    force2 = forces[3:6]
    np.testing.assert_array_almost_equal(force1, -force2, decimal=6)
    assert not np.allclose(force1, 0)


def test_compute_stress(stress_interface):
    """
    @brief 测试 C++ 实现的应力计算函数
    """
    num_atoms = 1
    positions = np.array([0.0, 0.0, 0.0], dtype=np.float64)
    velocities = np.array([0.0, 0.0, 0.0], dtype=np.float64)
    forces = np.array([0.0, 0.0, 0.0], dtype=np.float64)
    masses = np.array([26.9815], dtype=np.float64)
    volume = 4.05**3
    epsilon = 0.0103
    sigma = 2.55
    cutoff = 2.5 * sigma
    lattice_vectors = np.eye(3, dtype=np.float64).flatten()

    stress_tensor = stress_interface.compute_stress(
        num_atoms,
        positions,
        velocities,
        forces,
        masses,
        volume,
        epsilon,
        sigma,
        cutoff,
        lattice_vectors,
    )

    # 检查应力张量是否为 3x3 矩阵
    assert stress_tensor.shape == (3, 3)
    # 由于没有力作用，应力张量应为零
    np.testing.assert_array_almost_equal(stress_tensor, np.zeros((3, 3)), decimal=6)


def test_nose_hoover(nose_hoover_interface):
    """
    @brief 测试 C++ 实现的 Nose-Hoover 恒温器函数
    """
    dt = 1.0
    num_atoms = 2
    masses = np.array([1.0, 1.0], dtype=np.float64)
    velocities = np.array([0.0, 0.0, 0.0, 1.0, 0.0, 0.0], dtype=np.float64)
    forces = np.array([0.0, 0.0, 0.0, -1.0, 0.0, 0.0], dtype=np.float64)
    xi = 0.0
    Q = 10.0
    target_temperature = 300.0

    # 调用 Nose-Hoover
    updated_xi = nose_hoover_interface.nose_hoover(
        dt,
        num_atoms,
        masses,
        velocities,
        forces,
        xi,
        Q,
        target_temperature,
    )

    # 由于初始 xi=0，动能接近 0，xi 应该有变化
    assert isinstance(updated_xi, float)
    assert not np.isclose(updated_xi, xi)


# tests/test_deformation.py

import pytest
import numpy as np
from python.deformation import Deformer


def test_generate_deformation_matrices():
    """
    @brief 测试生成变形矩阵的方法
    """
    delta = 0.01  # 1% 的应变
    deformer = Deformer(delta)
    deformation_matrices = deformer.generate_deformation_matrices()

    # 检查是否生成了 6 个变形矩阵
    assert len(deformation_matrices) == 6

    # 检查每个变形矩阵的正确性
    for i, F in enumerate(deformation_matrices):
        # 检查矩阵是否为 3x3
        assert F.shape == (3, 3)

        # 检查矩阵是否为单位矩阵加上微小变形
        expected_F = np.identity(3)
        if i < 3:
            expected_F[i, i] += delta
        else:
            shear_indices = [(0, 1), (0, 2), (1, 2)]
            idx = i - 3
            i_shear, j_shear = shear_indices[idx]
            expected_F[i_shear, j_shear] += delta / 2
            expected_F[j_shear, i_shear] += delta / 2
        np.testing.assert_array_almost_equal(F, expected_F, decimal=6)


def test_apply_deformation(cell_fixture):
    """
    @brief 测试对晶胞施加变形矩阵的方法
    """
    delta = 0.01
    deformer = Deformer(delta)
    deformation_matrix = deformer.generate_deformation_matrices()[0]  # ε_xx
    original_lattice = cell_fixture.lattice_vectors.copy()
    original_positions = [atom.position.copy() for atom in cell_fixture.atoms]

    deformer.apply_deformation(cell_fixture, deformation_matrix)

    # 检查晶格矢量是否正确更新
    expected_lattice = np.dot(original_lattice, deformation_matrix.T)
    np.testing.assert_array_almost_equal(
        cell_fixture.lattice_vectors, expected_lattice, decimal=6
    )

    # 检查原子位置是否正确更新
    for original_pos, atom in zip(original_positions, cell_fixture.atoms):
        expected_pos = np.dot(deformation_matrix, original_pos)
        np.testing.assert_array_almost_equal(atom.position, expected_pos, decimal=6)


@pytest.fixture
def cell_fixture():
    """
    @fixture 创建一个简单的晶胞，用于测试
    """
    from python.structure import Atom, Cell

    mass = 26.9815  # amu
    position = np.array([0.0, 0.0, 0.0])
    atom = Atom(id=0, symbol="Al", mass=mass, position=position)
    lattice_vectors = np.eye(3) * 4.05  # Å
    cell = Cell(lattice_vectors, [atom], pbc_enabled=True)
    return cell


# tests/test_elasticity.py

import pytest
import numpy as np
from python.structure import Cell, Atom
from python.potentials import LennardJonesPotential
from python.elasticity import ElasticConstantsCalculator


def test_elastic_constants_calculator():
    """
    @brief 测试 ElasticConstantsCalculator 计算弹性常数
    """
    # 创建一个简单的晶胞，例如立方晶格
    atoms = [
        Atom(id=0, mass=2816.78346, position=np.array([0.0, 0.0, 0.0]), symbol="Al"),
        Atom(
            id=1, mass=2816.78346, position=np.array([2.55, 2.55, 2.55]), symbol="Al"
        ),  # sigma=2.55 Å
    ]
    lattice_vectors = np.eye(3) * 5.1  # 示例晶格向量
    cell = Cell(atoms=atoms, lattice_vectors=lattice_vectors)

    # 定义 Lennard-Jones 势
    epsilon = 0.0103  # eV
    sigma = 2.55  # Å
    cutoff = 8.0  # Å, 示例截断半径
    lj_potential = LennardJonesPotential(epsilon=epsilon, sigma=sigma, cutoff=cutoff)

    # 创建 ElasticConstantsCalculator 实例
    elastic_calculator = ElasticConstantsCalculator(
        cell=cell, potential=lj_potential, delta=1e-3
    )

    # 计算弹性常数
    C = elastic_calculator.calculate_elastic_constants()

    # 将弹性常数矩阵转换为 GPa
    C_in_GPa = C * 160.21766208

    # 预期弹性常数矩阵（根据文献或已知值）
    # 请根据实际材料（例如铝）的弹性常数进行调整，以下为示例值
    expected_C = np.array(
        [
            [69.0, 0.0, 0.0, 0.0, 0.0, 0.0],
            [0.0, 69.0, 0.0, 0.0, 0.0, 0.0],
            [0.0, 0.0, 69.0, 0.0, 0.0, 0.0],
            [0.0, 0.0, 0.0, 23.0, 0.0, 0.0],
            [0.0, 0.0, 0.0, 0.0, 23.0, 0.0],
            [0.0, 0.0, 0.0, 0.0, 0.0, 23.0],
        ]
    )  # 示例值，需根据实际情况调整

    # 检查弹性常数矩阵是否接近预期值
    assert np.allclose(
        C_in_GPa, expected_C, atol=1.0
    ), f"弹性常数矩阵不接近预期值。\n计算结果:\n{C_in_GPa}\n预期值:\n{expected_C}"


# tests/test_md.py

import pytest
import numpy as np

from python.structure import Atom, Cell
from python.potentials import LennardJonesPotential
from python.md_simulator import (
    MDSimulator,
    VelocityVerletIntegrator,
    NoseHooverThermostat,
)


@pytest.fixture
def simple_cell(pbc_enabled=True):
    """
    @fixture 创建一个简单的晶胞，包含两个原子
    """
    lattice_vectors = np.eye(3) * 6.0 if pbc_enabled else np.eye(3) * 1e8  # Å
    mass = 2816.78346  # eV·fs²/Å²
    position1 = np.array([0.0, 0.0, 0.0])
    position2 = np.array([2.55, 0.0, 0.0])  # 与原子 1 相距 σ = 2.55 Å
    atom1 = Atom(id=0, symbol="Al", mass=mass, position=position1)
    atom2 = Atom(id=1, symbol="Al", mass=mass, position=position2)
    cell = Cell(lattice_vectors, [atom1, atom2], pbc_enabled=pbc_enabled)
    return cell


@pytest.fixture
def lj_potential():
    """
    @fixture 定义 Lennard-Jones 势
    """
    epsilon = 0.0103  # eV
    sigma = 2.55  # Å
    cutoff = 2.5 * sigma
    return LennardJonesPotential(epsilon=epsilon, sigma=sigma, cutoff=cutoff)


@pytest.fixture
def integrator():
    """
    @fixture 定义积分器
    """
    return VelocityVerletIntegrator()


@pytest.fixture
def thermostat():
    """
    @fixture 定义恒温器
    """
    return NoseHooverThermostat(target_temperature=300, time_constant=100)


def test_md_simulation(simple_cell, lj_potential, integrator):
    """
    @brief 测试分子动力学模拟器的运行
    """
    md_simulator = MDSimulator(
        simple_cell,
        lj_potential,
        integrator,
        thermostat=None,  # 先不加恒温器！！！
    )
    md_simulator.run(steps=10, dt=1.0)  # dt 单位为 fs

    # 检查原子的位置和速度是否发生变化
    atom1 = simple_cell.atoms[0]
    atom2 = simple_cell.atoms[1]
    assert not np.allclose(atom1.position, [0.0, 0.0, 0.0])
    assert not np.allclose(atom2.position, [2.55, 0.0, 0.0])
    assert not np.allclose(atom1.velocity, [0.0, 0.0, 0.0])
    assert not np.allclose(atom2.velocity, [0.0, 0.0, 0.0])


def test_md_simulation_with_thermostat(
    simple_cell, lj_potential, integrator, thermostat
):
    """
    @brief 测试分子动力学模拟器的运行，带恒温器
    """
    md_simulator = MDSimulator(
        simple_cell,
        lj_potential,
        integrator,
        thermostat=thermostat,
    )
    md_simulator.run(steps=10, dt=1.0)  # dt 单位为 fs

    # 检查原子的位置和速度是否发生变化
    atom1 = simple_cell.atoms[0]
    atom2 = simple_cell.atoms[1]
    assert not np.allclose(atom1.position, [0.0, 0.0, 0.0])
    assert not np.allclose(atom2.position, [2.55, 0.0, 0.0])
    assert not np.allclose(atom1.velocity, [0.0, 0.0, 0.0])
    assert not np.allclose(atom2.velocity, [0.0, 0.0, 0.0])


# tests/test_mechanics.py

import pytest
import numpy as np
from python.mechanics import (
    StressCalculatorLJ,
    StrainCalculator,
    ElasticConstantsSolver,
)
from python.structure import Atom, Cell
from python.potentials import LennardJonesPotential


@pytest.fixture
def single_atom_cell():
    """
    @fixture 创建一个简单的晶胞，包含一个原子
    """
    lattice_vectors = np.eye(3) * 4.05  # Å
    mass = 26.9815  # 原子量，amu
    position = np.array([0.0, 0.0, 0.0])
    atom = Atom(id=0, symbol="Al", mass=mass, position=position)
    cell = Cell(lattice_vectors, [atom], pbc_enabled=True)
    return cell


@pytest.fixture
def lj_potential_single():
    """
    @fixture 定义 Lennard-Jones 势
    """
    epsilon = 0.0103  # eV
    sigma = 2.55  # Å
    cutoff = 2.5 * sigma
    return LennardJonesPotential(epsilon=epsilon, sigma=sigma, cutoff=cutoff)


def test_stress_calculation(single_atom_cell, lj_potential_single):
    """
    @brief 测试应力计算器的功能
    """
    stress_calculator = StressCalculatorLJ()
    lj_potential_single.calculate_forces(single_atom_cell)
    stress_tensor = stress_calculator.compute_stress(
        single_atom_cell, lj_potential_single
    )
    # 检查应力张量是否为 3x3 矩阵
    assert stress_tensor.shape == (3, 3)


def test_strain_calculation():
    """
    @brief 测试应变计算器的功能
    """
    strain_calculator = StrainCalculator()
    F = np.array([[1.01, 0, 0], [0, 1, 0], [0, 0, 1]])
    strain_tensor = strain_calculator.compute_strain(F)
    # 检查应变张量是否为 3x3 矩阵
    assert strain_tensor.shape == (3, 3)
    # 检查应变计算是否正确
    expected_strain = 0.5 * (np.dot(F.T, F) - np.identity(3))
    np.testing.assert_array_almost_equal(strain_tensor, expected_strain, decimal=6)


def test_elastic_constants_solver():
    """
    @brief 测试弹性常数求解器的功能
    """
    strains = [np.zeros(6), np.ones(6) * 0.01]
    stresses = [np.zeros(6), np.ones(6)]
    solver = ElasticConstantsSolver()
    C = solver.solve(strains, stresses)
    # 检查 C 是否为 6x6 矩阵
    assert C.shape == (6, 6)
    # 由于输入为线性关系，C 应接近单位矩阵乘以某常数
    expected_C = np.linalg.lstsq(strains, stresses, rcond=None)[0]
    np.testing.assert_array_almost_equal(C, expected_C, decimal=6)


# tests/test_nose_hoover.py

import pytest
import numpy as np
from python.interfaces.cpp_interface import CppInterface


@pytest.fixture
def nose_hoover_interface():
    """
    @fixture 创建 Nose-Hoover C++ 接口实例
    """
    return CppInterface("nose_hoover")


def test_nose_hoover(nose_hoover_interface):
    """
    @brief 测试 C++ 实现的 Nose-Hoover 恒温器函数
    """
    dt = 1.0
    num_atoms = 2
    masses = np.array([1.0, 1.0], dtype=np.float64)
    velocities = np.array([0.0, 0.0, 0.0, 1.0, 0.0, 0.0], dtype=np.float64)
    forces = np.array([0.0, 0.0, 0.0, -1.0, 0.0, 0.0], dtype=np.float64)
    xi = 0.0
    Q = 10.0
    target_temperature = 300.0

    # 调用 Nose-Hoover
    updated_xi = nose_hoover_interface.nose_hoover(
        dt,
        num_atoms,
        masses,
        velocities,
        forces,
        xi,
        Q,
        target_temperature,
    )

    # 由于初始 xi=0，动能接近 0，xi 应该有变化
    assert isinstance(updated_xi, float)
    assert not np.isclose(updated_xi, xi)


# tests/test_optimizers.py

import pytest
import numpy as np
from python.optimizers import GradientDescentOptimizer
from python.structure import Atom, Cell
from python.potentials import LennardJonesPotential


@pytest.fixture
def optimizer():
    """
    @fixture 定义梯度下降优化器
    """
    return GradientDescentOptimizer(max_steps=5000, tol=1e-8, step_size=0.1)


@pytest.fixture
def optimization_cell(pbc_enabled=False):
    """
    @fixture 创建一个简单的晶胞，包含两个原子
    """
    if pbc_enabled:
        lattice_vectors = np.eye(3) * 6.0  # Å, 以确保最小镜像距离 >= 2^(1/6)*sigma
    else:
        lattice_vectors = np.eye(3) * 1e8  # Å, 以禁用 PBC

    mass = 2816.78346  # eV·fs²/Å²
    position1 = np.array([0.0, 0.0, 0.0])
    position2 = np.array([2.55, 0.0, 0.0])  # 初始距离为 σ = 2.55 Å
    atom1 = Atom(id=0, symbol="Al", mass=mass, position=position1)
    atom2 = Atom(id=1, symbol="Al", mass=mass, position=position2)
    cell = Cell(lattice_vectors, [atom1, atom2], pbc_enabled=pbc_enabled)
    return cell


@pytest.fixture
def lj_potential_optim():
    """
    @fixture 定义 Lennard-Jones 势
    """
    epsilon = 0.0103  # eV
    sigma = 2.55  # Å
    cutoff = 2.5 * sigma
    return LennardJonesPotential(epsilon=epsilon, sigma=sigma, cutoff=cutoff)


def test_gradient_descent_optimizer(optimizer, optimization_cell, lj_potential_optim):
    """
    @brief 测试梯度下降优化器
    """
    optimizer.optimize(optimization_cell, lj_potential_optim)

    # 获取优化后的原子位置
    optimized_position1 = optimization_cell.atoms[0].position
    optimized_position2 = optimization_cell.atoms[1].position

    # 计算优化后的距离
    optimized_distance = np.linalg.norm(optimized_position2 - optimized_position1)

    # 预期优化后的距离应接近 2^(1/6) * sigma ≈ 2.857 Å
    equilibrium_distance = 2 ** (1 / 6) * lj_potential_optim.sigma
    assert np.isclose(optimized_distance, equilibrium_distance, atol=2e-3)


def test_optimizer_convergence(optimizer, optimization_cell, lj_potential_optim):
    """
    @brief 测试优化器是否能收敛
    """
    optimizer.optimize(optimization_cell, lj_potential_optim)

    # 计算优化后的距离
    optimized_distance = np.linalg.norm(
        optimization_cell.atoms[1].position - optimization_cell.atoms[0].position
    )

    # 预期优化后的距离应接近 2^(1/6) * sigma ≈ 2.857 Å
    equilibrium_distance = 2 ** (1 / 6) * lj_potential_optim.sigma
    assert np.abs(optimized_distance - equilibrium_distance) < 2e-3


def test_force_direction():
    """
    @brief 验证力的方向是否为负梯度方向
    """
    # 创建一个简单的晶胞
    atoms = [
        Atom(id=0, mass=2816.78346, position=np.array([0.0, 0.0, 0.0]), symbol="Al"),
        Atom(id=1, mass=2816.78346, position=np.array([2.55, 2.55, 2.55]), symbol="Al"),
    ]
    lattice_vectors = np.eye(3) * 5.1  # 示例晶格向量
    cell = Cell(atoms=atoms, lattice_vectors=lattice_vectors)

    # 定义 Lennard-Jones 势
    epsilon = 0.0103  # eV
    sigma = 2.55  # Å
    cutoff = 8.0  # Å
    lj_potential = LennardJonesPotential(epsilon=epsilon, sigma=sigma, cutoff=cutoff)

    # 计算力
    lj_potential.calculate_forces(cell)

    force_on_atom0 = cell.atoms[0].force
    force_on_atom1 = cell.atoms[1].force

    # 计算梯度方向并包括力的截断偏移
    r_vec = atoms[1].position - atoms[0].position
    r = np.linalg.norm(r_vec)
    if r >= cutoff:
        # 截断距离外，力为零
        expected_force = np.zeros(3)
    else:
        sr = sigma / r
        sr6 = sr**6
        sr12 = sr6**2
        F_LJ = 24.0 * epsilon * (2.0 * sr12 - sr6) / r
        sr_cutoff = sigma / cutoff
        sr6_cutoff = sr_cutoff**6
        sr12_cutoff = sr6_cutoff**2
        F_LJ_cutoff = 24.0 * epsilon * (2.0 * sr12_cutoff - sr6_cutoff) / cutoff
        F_total = F_LJ - F_LJ_cutoff
        expected_force = F_total * (r_vec / r)

    # 断言计算的力是否接近预期力
    assert np.allclose(
        force_on_atom0, expected_force, atol=1e-5
    ), f"Atom 0 的力方向错误: {force_on_atom0} != {expected_force}"
    assert np.allclose(
        force_on_atom1, -expected_force, atol=1e-5
    ), f"Atom 1 的力方向错误: {force_on_atom1} != {-expected_force}"


# tests/test_potentials.py

import pytest
import numpy as np
from python.potentials import LennardJonesPotential
from python.structure import Atom, Cell


@pytest.fixture
def lj_potential():
    """
    @fixture 定义 Lennard-Jones 势
    """
    epsilon = 0.0103  # eV
    sigma = 2.55  # Å
    cutoff = 2.5 * sigma
    return LennardJonesPotential(epsilon=epsilon, sigma=sigma, cutoff=cutoff)


@pytest.fixture
def two_atom_cell():
    """
    @fixture 创建一个简单的系统，包含两个原子
    """
    lattice_vectors = np.eye(3) * 4.05  # Å
    mass = 26.9815  # amu
    position1 = np.array([0.0, 0.0, 0.0])
    position2 = np.array([2.025, 0.0, 0.0])  # 2.025 Å
    atom1 = Atom(id=0, symbol="Al", mass=mass, position=position1)
    atom2 = Atom(id=1, symbol="Al", mass=mass, position=position2)
    cell = Cell(lattice_vectors, [atom1, atom2], pbc_enabled=True)
    return cell


def test_force_calculation(lj_potential, two_atom_cell):
    """
    @brief 测试 Lennard-Jones 势的力计算功能
    """
    lj_potential.calculate_forces(two_atom_cell)
    # 检查力是否非零且相反
    force1 = two_atom_cell.atoms[0].force
    force2 = two_atom_cell.atoms[1].force
    np.testing.assert_array_almost_equal(force1, -force2, decimal=10)
    assert not np.allclose(force1, 0)


# tests/test_structure.py

import pytest
import numpy as np
from python.structure import Atom, Cell


@pytest.fixture
def atom():
    """
    @fixture 创建一个原子实例
    """
    position = np.array([0.0, 0.0, 0.0])
    mass = 26.9815  # 原子量，amu
    return Atom(id=0, symbol="Al", mass=mass, position=position)


@pytest.fixture
def cell(atom):
    """
    @fixture 创建一个晶胞实例，包含一个原子
    """
    lattice_vectors = np.eye(3) * 4.05  # Å
    return Cell(lattice_vectors, [atom], pbc_enabled=True)


def test_atom_creation(atom):
    """
    @brief 测试原子的创建
    """
    assert atom.id == 0
    assert atom.symbol == "Al"
    np.testing.assert_array_equal(atom.position, np.array([0.0, 0.0, 0.0]))
    assert atom.mass == 26.9815


def test_cell_creation(cell, atom):
    """
    @brief 测试晶胞的创建
    """
    np.testing.assert_array_equal(cell.lattice_vectors, np.eye(3) * 4.05)
    assert len(cell.atoms) == 1
    assert cell.atoms[0] == atom


def test_volume_calculation(cell):
    """
    @brief 测试晶胞体积的计算
    """
    expected_volume = np.linalg.det(cell.lattice_vectors)
    calculated_volume = cell.calculate_volume()
    assert np.isclose(calculated_volume, expected_volume)


def test_apply_periodic_boundary(cell):
    """
    @brief 测试周期性边界条件的应用
    """
    position = np.array([5.0, -1.0, 4.0])  # 超出晶胞范围的坐标
    new_position = cell.apply_periodic_boundary(position)
    # 检查新位置是否在 [0, lattice_constant) 范围内
    assert np.all(new_position >= 0)
    assert np.all(new_position < 4.05)


# tests/test_utils.py

import pytest
import numpy as np
from python.utils import TensorConverter, DataCollector
from python.structure import Atom, Cell


def test_tensor_converter_to_voigt():
    """
    @brief 测试 TensorConverter 的 to_voigt 方法
    """
    tensor = np.array([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0]])
    expected_voigt = np.array([1.0, 5.0, 9.0, 2.0, 3.0, 6.0])
    voigt = TensorConverter.to_voigt(tensor)
    np.testing.assert_array_almost_equal(voigt, expected_voigt, decimal=6)


@pytest.fixture
def cell_fixture():
    """
    @fixture 创建一个简单的晶胞，用于数据收集测试
    """
    lattice_vectors = np.eye(3) * 4.05  # Å
    mass = 26.9815  # amu
    position = np.array([0.0, 0.0, 0.0])
    atom = Atom(id=0, symbol="Al", mass=mass, position=position)
    cell = Cell(lattice_vectors, [atom], pbc_enabled=True)
    return cell


def test_data_collector(cell_fixture):
    """
    @brief 测试 DataCollector 的数据收集功能
    """
    collector = DataCollector()
    collector.collect(cell_fixture)
    assert len(collector.data) == 1
    collected = collector.data[0]
    assert "positions" in collected
    assert "velocities" in collected
    assert len(collected["positions"]) == 1
    assert len(collected["velocities"]) == 1
    np.testing.assert_array_equal(
        collected["positions"][0], cell_fixture.atoms[0].position
    )
    np.testing.assert_array_equal(
        collected["velocities"][0], cell_fixture.atoms[0].velocity
    )


# tests/test_visualization.py

import pytest
from python.visualization import Visualizer
from python.structure import Cell, Atom
import numpy as np
import matplotlib

matplotlib.use("Agg")  # 使用无头后端，防止弹出图形窗口
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D  # 导入 Axes3D


def test_plot_cell_structure():
    """
    @brief 测试 Visualizer.plot_cell_structure 函数
    """
    # 创建一个简单的晶胞
    atoms = [
        Atom(id=0, mass=2816.78346, position=np.array([0.0, 0.0, 0.0]), symbol="Al"),
        Atom(
            id=1, mass=2816.78346, position=np.array([2.55, 2.55, 2.55]), symbol="Al"
        ),  # sigma=2.55 Å
    ]
    lattice_vectors = np.eye(3) * 5.1  # 示例晶格向量
    cell = Cell(atoms=atoms, lattice_vectors=lattice_vectors)

    # 创建 Visualizer 实例
    visualizer = Visualizer()

    # 调用绘图函数，捕获图形对象
    try:
        fig, ax = visualizer.plot_cell_structure(cell, show=False)
        assert isinstance(fig, plt.Figure), "返回的对象不是 Matplotlib Figure"
        assert isinstance(ax, Axes3D), "返回的对象不是 Matplotlib Axes3D"
    except Exception as e:
        pytest.fail(f"绘图函数抛出异常: {e}")


def test_plot_stress_strain():
    """
    @brief 测试 Visualizer.plot_stress_strain 函数
    """
    # 创建应变和应力数据
    strain_data = np.random.rand(10, 6)  # 示例数据
    stress_data = np.random.rand(10, 6)  # 示例数据

    # 创建 Visualizer 实例
    visualizer = Visualizer()

    # 调用绘图函数，确保不抛出异常
    try:
        fig, ax = visualizer.plot_stress_strain(strain_data, stress_data, show=False)
        assert isinstance(fig, plt.Figure), "返回的对象不是 Matplotlib Figure"
        assert isinstance(ax, plt.Axes), "返回的对象不是 Matplotlib Axes"
    except Exception as e:
        pytest.fail(f"绘图函数抛出异常: {e}")


