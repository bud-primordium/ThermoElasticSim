src/
    cpp/
        lennard_jones.cpp
        nose_hoover.cpp
        nose_hoover_chain.cpp
        parrinello_rahman_hoover.cpp
        stress_calculator.cpp
    lib/
        lennard_jones.dll
        nose_hoover.dll
        nose_hoover_chain.dll
        parrinello_rahman_hoover.dll
        stress_calculator.dll
    python/
        barostats.py
        config.py
        deformation.py
        elasticity.py
        integrators.py
        md_simulator.py
        mechanics.py
        optimizers.py
        ploy_test.py
        potentials.py
        structure.py
        thermostats.py
        utils.py
        visualization.py
        __init__.py
// src/cpp/lennard_jones.cpp

#include <cmath>
#include <vector>

extern "C"
{
    /**
     * @brief 使用三次多项式计算截断区域的系数 a, b, c, d
     *
     * 满足以下条件：
     * 1. V(r0) = V0
     * 2. V'(r0) = F0
     * 3. V(cutoff) = 0
     * 4. V'(cutoff) = 0
     *
     * @param cutoff 截断半径
     * @param r0 过渡起点
     * @param sigma LJ势参数 σ
     * @param epsilon LJ势参数 ε
     * @param a 三次项系数
     * @param b 二次项系数
     * @param c 一次项系数
     * @param d 常数项
     */
    void solve_cutoff_cubic(
        double cutoff, double r0, double sigma, double epsilon,
        double &a, double &b, double &c, double &d)
    {
        // 计算 r0 处的势能 V0 和力 F0
        double r0_inv = 1.0 / r0;
        double sigma_r0_inv = sigma * r0_inv;
        double sigma_r0_inv_6 = pow(sigma_r0_inv, 6);
        double sigma_r0_inv_12 = pow(sigma_r0_inv, 12);
        double V0 = 4.0 * epsilon * (sigma_r0_inv_12 - sigma_r0_inv_6);
        double F0 = 24.0 * epsilon * (2.0 * sigma_r0_inv_12 - sigma_r0_inv_6) * r0_inv;

        // 按照 Mathematica 的解更新三次多项式系数 a, b, c, d
        double denom = pow(r0 - cutoff, 3);
        a = -(F0 * r0 - F0 * cutoff + 2.0 * V0) / denom;
        b = -((-F0 * pow(r0, 2)) - F0 * r0 * cutoff + 2.0 * F0 * pow(cutoff, 2) - 3.0 * r0 * V0 - 3.0 * cutoff * V0) / denom;
        c = -(cutoff * (2.0 * F0 * pow(r0, 2) - F0 * r0 * cutoff - F0 * pow(cutoff, 2) + 6.0 * r0 * V0)) / denom;
        d = -((-F0 * pow(r0, 2) * pow(cutoff, 2)) + F0 * r0 * pow(cutoff, 3) - 3.0 * r0 * pow(cutoff, 2) * V0 + pow(cutoff, 3) * V0) / denom;
    }

    void calculate_forces(
        int num_atoms,
        const double *positions,
        double *forces,
        double epsilon,
        double sigma,
        double cutoff,
        const double *box_lengths)
    {
        // 清零力数组
        for (int i = 0; i < 3 * num_atoms; ++i)
        {
            forces[i] = 0.0;
        }

        double cutoff_sq = cutoff * cutoff;
        double r0 = 0.9 * cutoff; // 统一设置平滑过渡的起点

        // 预计算三次多项式系数
        double a, b, c, d;
        solve_cutoff_cubic(cutoff, r0, sigma, epsilon, a, b, c, d);

        // 力的计算
        for (int i = 0; i < num_atoms; ++i)
        {
            const double *ri = &positions[3 * i];
            for (int j = i + 1; j < num_atoms; ++j)
            {
                const double *rj = &positions[3 * j];
                double rij[3];
                for (int k = 0; k < 3; ++k)
                {
                    rij[k] = ri[k] - rj[k];
                    // 最小镜像法
                    if (rij[k] > 0.5 * box_lengths[k])
                        rij[k] -= box_lengths[k];
                    else if (rij[k] < -0.5 * box_lengths[k])
                        rij[k] += box_lengths[k];
                }

                double r2 = rij[0] * rij[0] + rij[1] * rij[1] + rij[2] * rij[2];

                if (r2 < cutoff_sq)
                {
                    double r = sqrt(r2);
                    double force_scalar;

                    if (r < r0)
                    {
                        double r_inv = 1.0 / r;
                        double r6_inv = pow(sigma * r_inv, 6); // (σ/r)^6
                        force_scalar = 24.0 * epsilon * (2.0 * r6_inv * r6_inv - r6_inv) * r_inv;
                    }
                    else
                    {
                        // 使用三次多项式过渡区的力 F(r) = -dV/dr = -(3a*r^2 + 2b*r + c)
                        force_scalar = -(3.0 * a * r * r + 2.0 * b * r + c);
                    }

                    for (int k = 0; k < 3; ++k)
                    {
                        double fij = force_scalar * rij[k];
                        forces[3 * i + k] -= fij;
                        forces[3 * j + k] += fij;
                    }
                }
            }
        }
    }

    /**
     * @brief 计算 Lennard-Jones 势能，使用最小镜像法处理周期性边界条件
     *
     * @param num_atoms 原子数量
     * @param positions 原子位置数组（长度为 3*num_atoms）
     * @param epsilon Lennard-Jones 势参数 ε，单位为 eV
     * @param sigma Lennard-Jones 势参数 σ，单位为 Å
     * @param cutoff 截断半径，单位为 Å
     * @param box_lengths 模拟盒子在每个维度的长度（长度为 3）
     * @return 总 Lennard-Jones 势能，单位为 eV
     */
    double calculate_energy(
        int num_atoms,
        const double *positions,
        double epsilon,
        double sigma,
        double cutoff,
        const double *box_lengths)
    {
        double energy = 0.0;
        double cutoff_sq = cutoff * cutoff;
        double r0 = 0.9 * cutoff; // 统一设置平滑过渡的起点

        // 预计算三次多项式系数
        double a, b, c, d;
        solve_cutoff_cubic(cutoff, r0, sigma, epsilon, a, b, c, d);

        // 势能的计算
        for (int i = 0; i < num_atoms; ++i)
        {
            const double *ri = &positions[3 * i];
            for (int j = i + 1; j < num_atoms; ++j)
            {
                const double *rj = &positions[3 * j];
                double rij[3];
                for (int k = 0; k < 3; ++k)
                {
                    rij[k] = ri[k] - rj[k];
                    // 最小镜像法
                    if (rij[k] > 0.5 * box_lengths[k])
                        rij[k] -= box_lengths[k];
                    else if (rij[k] < -0.5 * box_lengths[k])
                        rij[k] += box_lengths[k];
                }

                double r2 = rij[0] * rij[0] + rij[1] * rij[1] + rij[2] * rij[2];

                if (r2 < cutoff_sq)
                {
                    double r = sqrt(r2);
                    double potential;

                    if (r < r0)
                    {
                        double r_inv = 1.0 / r;
                        double r6_inv = pow(sigma * r_inv, 6); // (σ/r)^6
                        potential = 4.0 * epsilon * (r6_inv * r6_inv - r6_inv);
                    }
                    else
                    {
                        // 使用三次多项式过渡区的势能 V(r) = a*r^3 + b*r^2 + c*r + d
                        potential = a * pow(r, 3) + b * pow(r, 2) + c * r + d;
                    }

                    energy += potential;
                }
            }
        }

        return energy;
    }
}


// src/cpp/nose_hoover.cpp

#include <cmath>
#include <vector>

extern "C"
{
    /**
     * @brief 应用 Nose-Hoover 恒温器
     *
     * @param dt 时间步长
     * @param num_atoms 原子数量
     * @param masses 原子质量数组（长度为 num_atoms）
     * @param velocities 原子速度数组（长度为 3*num_atoms）
     * @param forces 原子力数组（长度为 3*num_atoms）
     * @param xi 热浴变量
     * @param Q 热浴质量参数
     * @param target_temperature 目标温度
     */
    void nose_hoover(
        double dt,
        int num_atoms,
        const double *masses,
        double *velocities,
        const double *forces,
        double *xi,
        double Q,
        double target_temperature)
    {
        double dt_half = dt * 0.5;
        double kB = 8.617333262e-5; // 玻尔兹曼常数，单位 eV/K

        // 第一半步：更新速度，考虑力
        for (int i = 0; i < num_atoms; ++i)
        {
            velocities[3 * i] += dt_half * forces[3 * i] / masses[i];
            velocities[3 * i + 1] += dt_half * forces[3 * i + 1] / masses[i];
            velocities[3 * i + 2] += dt_half * forces[3 * i + 2] / masses[i];
        }

        // 更新 xi（热浴变量） - 第一半步
        double kinetic_energy = 0.0;
        for (int i = 0; i < num_atoms; ++i)
        {
            double vx = velocities[3 * i];
            double vy = velocities[3 * i + 1];
            double vz = velocities[3 * i + 2];
            kinetic_energy += 0.5 * masses[i] * (vx * vx + vy * vy + vz * vz);
        }
        double G_xi = (2.0 * kinetic_energy - 3.0 * num_atoms * kB * target_temperature) / Q;
        *xi += dt_half * G_xi;

        // 缩放速度
        double scale = exp(-(*xi) * dt);
        for (int i = 0; i < num_atoms; ++i)
        {
            velocities[3 * i] *= scale;
            velocities[3 * i + 1] *= scale;
            velocities[3 * i + 2] *= scale;
        }

        // 更新 xi（热浴变量） - 第二半步
        kinetic_energy = 0.0;
        for (int i = 0; i < num_atoms; ++i)
        {
            double vx = velocities[3 * i];
            double vy = velocities[3 * i + 1];
            double vz = velocities[3 * i + 2];
            kinetic_energy += 0.5 * masses[i] * (vx * vx + vy * vy + vz * vz);
        }
        G_xi = (2.0 * kinetic_energy - 3.0 * num_atoms * kB * target_temperature) / Q;
        *xi += dt_half * G_xi;

        // 第二半步：更新速度，考虑力
        for (int i = 0; i < num_atoms; ++i)
        {
            velocities[3 * i] += dt_half * forces[3 * i] / masses[i];
            velocities[3 * i + 1] += dt_half * forces[3 * i + 1] / masses[i];
            velocities[3 * i + 2] += dt_half * forces[3 * i + 2] / masses[i];
        }
    }
}


// src/cpp/nose_hoover_chain.cpp

#include <cmath>
#include <vector>

extern "C"
{
    /**
     * @brief 应用 Nose-Hoover 链恒温器
     *
     * @param dt 时间步长
     * @param num_atoms 原子数量
     * @param masses 原子质量数组（长度为 num_atoms）
     * @param velocities 原子速度数组（长度为 3*num_atoms）
     * @param forces 原子力数组（长度为 3*num_atoms）
     * @param xi 热浴变量数组（长度为 chain_length）
     * @param Q 热浴质量参数数组（长度为 chain_length）
     * @param chain_length 热浴链的长度
     * @param target_temperature 目标温度
     */
    void nose_hoover_chain(
        double dt,
        int num_atoms,
        const double *masses,
        double *velocities,
        const double *forces,
        double *xi,
        const double *Q,
        int chain_length,
        double target_temperature)
    {
        // 使用 std::vector 代替动态数组
        std::vector<double> G_chain(chain_length, 0.0);

        double dt_half = dt * 0.5;
        double kB = 8.617333262e-5; // 玻尔兹曼常数，单位 eV/K

        // 计算动能
        double kinetic_energy = 0.0;
        for (int i = 0; i < num_atoms; ++i)
        {
            double vx = velocities[3 * i];
            double vy = velocities[3 * i + 1];
            double vz = velocities[3 * i + 2];
            kinetic_energy += 0.5 * masses[i] * (vx * vx + vy * vy + vz * vz);
        }

        // 递推更新 Nose-Hoover 链
        G_chain[0] = (2.0 * kinetic_energy - 3.0 * num_atoms * kB * target_temperature) / Q[0];
        for (int i = 1; i < chain_length; ++i)
        {
            G_chain[i] = (Q[i - 1] * xi[i - 1] * xi[i - 1] - kB * target_temperature) / Q[i];
        }

        // 更新 xi
        for (int i = chain_length - 1; i >= 0; --i)
        {
            xi[i] += G_chain[i] * dt_half;
        }

        // 缩放速度
        double scale = exp(-xi[0] * dt);
        for (int i = 0; i < num_atoms; ++i)
        {
            velocities[3 * i] *= scale;
            velocities[3 * i + 1] *= scale;
            velocities[3 * i + 2] *= scale;
        }

        // 更新 xi
        for (int i = 0; i < chain_length; ++i)
        {
            xi[i] += G_chain[i] * dt_half;
        }

        // 更新速度，考虑力
        for (int i = 0; i < num_atoms; ++i)
        {
            velocities[3 * i] += dt * forces[3 * i] / masses[i];
            velocities[3 * i + 1] += dt * forces[3 * i + 1] / masses[i];
            velocities[3 * i + 2] += dt * forces[3 * i + 2] / masses[i];
        }
    }
}


// src/cpp/parrinello_rahman_hoover.cpp

#include <cmath>
#include <vector>

extern "C"
{
    /**
     * @brief 应用 Parrinello-Rahman-Hoover 恒压器
     *
     * @param dt 时间步长
     * @param num_atoms 原子数量
     * @param masses 原子质量数组（长度为 num_atoms）
     * @param velocities 原子速度数组（长度为 3*num_atoms）
     * @param forces 原子力数组（长度为 3*num_atoms）
     * @param lattice_vectors 当前晶格矢量（长度为 9, row-major order）
     * @param xi 热浴变量数组（长度为 6}
     * @param Q 热浴质量参数数组（长度为 6}
     * @param target_pressure 目标压力
     */
    void parrinello_rahman_hoover(
        double dt,
        int num_atoms,
        const double *masses,
        double *velocities,
        const double *forces,
        double *lattice_vectors, // 3x3 matrix, row-major
        double *xi,
        const double *Q,
        double target_pressure)
    {
        // 这个是一个简单的实现示例，实际的 PRH 恒温器更复杂
        // 这里只提供一个简单的缩放实现

        // 计算当前压力（简化示例）
        double current_pressure = 0.0;
        for (int i = 0; i < 3; ++i)
        {
            for (int j = 0; j < 3; ++j)
            {
                current_pressure += lattice_vectors[i * 3 + j] * forces[j * 3 + i];
            }
        }
        current_pressure /= 3.0;

        // 计算压力差
        double delta_P = current_pressure - target_pressure;

        // 更新热浴变量
        for (int i = 0; i < 6; ++i)
        {
            xi[i] += (delta_P)*dt / Q[i];
        }

        // 调整晶胞的晶格向量
        for (int i = 0; i < 9; ++i)
        {
            lattice_vectors[i] *= exp(-xi[i % 6] * dt); // 简单缩放
        }

        // 更新原子速度（简化示例）
        for (int i = 0; i < num_atoms; ++i)
        {
            velocities[3 * i] *= exp(-xi[0] * dt);
            velocities[3 * i + 1] *= exp(-xi[1] * dt);
            velocities[3 * i + 2] *= exp(-xi[2] * dt);
        }
    }
}


// src/cpp/stress_calculator.cpp

#include <cmath>
#include <vector>

extern "C"
{
    /**
     * @brief 计算应力张量
     *
     * @param num_atoms 原子数量
     * @param positions 原子位置数组（长度为 3*num_atoms）
     * @param velocities 原子速度数组（长度为 3*num_atoms）
     * @param forces 原子力数组（长度为 3*num_atoms）
     * @param masses 原子质量数组（长度为 num_atoms）
     * @param volume 系统体积
     * @param box_lengths 模拟盒子在每个维度的长度（长度为 3）
     * @param stress_tensor 输出的应力张量（长度为 9，按行主序存储 3x3 矩阵）
     */
    void compute_stress(
        int num_atoms,
        const double *positions,
        const double *velocities,
        const double *forces,
        const double *masses,
        double volume,
        const double *box_lengths,
        double *stress_tensor // 输出
    )
    {
        // 初始化应力张量
        for (int i = 0; i < 9; ++i)
        {
            stress_tensor[i] = 0.0;
        }

        // 动能贡献
        for (int i = 0; i < num_atoms; ++i)
        {
            double m = masses[i];
            const double *v = &velocities[3 * i];
            for (int alpha = 0; alpha < 3; ++alpha)
            {
                for (int beta = 0; beta < 3; ++beta)
                {
                    stress_tensor[3 * alpha + beta] += m * v[alpha] * v[beta];
                }
            }
        }

        // 势能贡献
        for (int i = 0; i < num_atoms; ++i)
        {
            const double *ri = &positions[3 * i];
            const double *fi = &forces[3 * i];
            for (int alpha = 0; alpha < 3; ++alpha)
            {
                for (int beta = 0; beta < 3; ++beta)
                {
                    stress_tensor[3 * alpha + beta] += ri[beta] * fi[alpha];
                }
            }
        }

        // 归一化
        for (int i = 0; i < 9; ++i)
        {
            stress_tensor[i] = (stress_tensor[i]) / volume;
        }
    }
}


# src/python/barostats.py

import numpy as np
from .interfaces.cpp_interface import CppInterface
from .mechanics import StressCalculatorLJ


class Barostat:
    """
    @class Barostat
    @brief 恒压器基类
    """

    def apply(self, cell, dt):
        raise NotImplementedError


class ParrinelloRahmanHooverBarostat(Barostat):
    """
    @class ParrinelloRahmanHooverBarostat
    @brief Parrinello-Rahman-Hoover (PRH) 恒压器的实现
    """

    def __init__(self, target_pressure, time_constant, Qp=None):
        self.target_pressure = target_pressure
        self.time_constant = time_constant
        self.Qp = Qp if Qp is not None else np.ones(6) * (time_constant**2)
        self.xi = np.zeros(6)  # 热浴变量数组
        self.cpp_interface = CppInterface("parrinello_rahman_hoover")

    def apply(self, cell, dt):
        num_atoms = len(cell.atoms)
        masses = np.array([atom.mass for atom in cell.atoms], dtype=np.float64)
        velocities = np.array(
            [atom.velocity for atom in cell.atoms], dtype=np.float64
        ).flatten()
        forces = np.array(
            [atom.force for atom in cell.atoms], dtype=np.float64
        ).flatten()
        lattice_vectors = cell.lattice_vectors.flatten()

        # 调用 C++ PRH 函数
        self.cpp_interface.parrinello_rahman_hoover(
            dt,
            num_atoms,
            masses,
            velocities,
            forces,
            lattice_vectors,
            self.xi,
            self.Qp,
            self.target_pressure,
        )

        # 更新 lattice_vectors
        cell.lattice_vectors = lattice_vectors.reshape((3, 3))

        # 更新 atom velocities
        for i, atom in enumerate(cell.atoms):
            atom.velocity = velocities[3 * i : 3 * i + 3]


# src/python/config.py

import yaml


class ConfigManager:
    """
    @class ConfigManager
    @brief 配置管理器，用于加载和获取配置参数。
    """

    def __init__(self, config_file):
        self.config = self.load_config(config_file)

    @staticmethod
    def load_config(config_file):
        with open(config_file, "r") as f:
            config = yaml.safe_load(f)
        return config

    def get(self, key, default=None):
        return self.config.get(key, default)


# src/python/deformation.py

import numpy as np


class Deformer:
    """
    @class Deformer
    @brief 施加微小应变以生成变形矩阵的类。
    """

    def __init__(self, delta):
        """
        @param delta 微小应变量
        """
        self.delta = delta

    def generate_deformation_matrices(self):
        """
        @brief 生成用于施加应变的变形矩阵列表。

        @return 变形矩阵列表
        """
        delta = self.delta
        F_list = []

        # 六个独立的应变分量
        strain_components = [
            np.array([[delta, 0, 0], [0, 0, 0], [0, 0, 0]]),  # ε_xx
            np.array([[0, 0, 0], [0, delta, 0], [0, 0, 0]]),  # ε_yy
            np.array([[0, 0, 0], [0, 0, 0], [0, 0, delta]]),  # ε_zz
            np.array([[0, delta / 2, 0], [delta / 2, 0, 0], [0, 0, 0]]),  # ε_xy
            np.array([[0, 0, delta / 2], [0, 0, 0], [delta / 2, 0, 0]]),  # ε_xz
            np.array([[0, 0, 0], [0, 0, delta / 2], [0, delta / 2, 0]]),  # ε_yz
        ]

        for epsilon in strain_components:
            F = np.identity(3) + epsilon
            F_list.append(F)

        return F_list

    def apply_deformation(self, cell, deformation_matrix):
        """
        @brief 对晶胞施加变形矩阵。

        @param cell Cell 实例
        @param deformation_matrix 变形矩阵
        """
        cell.apply_deformation(deformation_matrix)


# src/python/elasticity.py

import numpy as np
from .mechanics import StressCalculatorLJ, StrainCalculator
from .deformation import Deformer
from .optimizers import GradientDescentOptimizer, BFGSOptimizer
from .utils import TensorConverter


class ElasticConstantsSolver:
    """
    @class ElasticConstantsSolver
    @brief 计算弹性常数的求解器类。
    """

    def solve(self, strains, stresses):
        """
        @brief 通过最小二乘法求解弹性常数矩阵。

        @param strains 应变数据列表，形状为 (N, 6)
        @param stresses 应力数据列表，形状为 (N, 6)
        @return 弹性常数矩阵，形状为 (6, 6)
        """
        strains = np.array(strains)
        stresses = np.array(stresses)

        # 检查输入数据维度
        if strains.ndim != 2 or stresses.ndim != 2:
            raise ValueError("Strains and stresses must be 2D arrays.")
        if strains.shape[0] != stresses.shape[0]:
            raise ValueError("Number of strain and stress samples must be equal.")
        if strains.shape[1] != 6 or stresses.shape[1] != 6:
            raise ValueError("Strains and stresses must have 6 components each.")

        # 使用最小二乘法求解 C * strains.T = stresses.T
        # 这里 C 是一个 6x6 矩阵，每一行对应一个应力分量的线性组合
        C, residuals, rank, s = np.linalg.lstsq(strains, stresses, rcond=None)
        return C


class ElasticConstantsCalculator:
    """
    @class ElasticConstantsCalculator
    @brief 用于计算弹性常数的类。
    """

    def __init__(self, cell, potential, delta=1e-3, optimizer_type="BFGS"):
        """
        @param cell 晶胞对象
        @param potential 势能对象
        @param delta 变形大小
        @param optimizer_type 优化器类型，支持 'GD'（梯度下降）和 'BFGS'
        """
        self.cell = cell
        self.potential = potential
        self.delta = delta
        self.deformer = Deformer(delta)
        self.stress_calculator = StressCalculatorLJ()
        self.strain_calculator = StrainCalculator()
        if optimizer_type == "GD":
            self.optimizer = GradientDescentOptimizer(
                max_steps=1000, tol=1e-6, step_size=1e-3
            )
        elif optimizer_type == "BFGS":
            self.optimizer = BFGSOptimizer(tol=1e-6)
        else:
            raise ValueError("Unsupported optimizer type. Choose 'GD' or 'BFGS'.")

    def calculate_elastic_constants(self):
        """
        @brief 计算弹性常数矩阵。

        @return 弹性常数矩阵，形状为 (6, 6)。
        """
        F_list = self.deformer.generate_deformation_matrices()
        strains = []
        stresses = []

        for F in F_list:
            # 复制初始晶胞
            deformed_cell = self.cell.copy()
            # 施加变形
            deformed_cell.apply_deformation(F)
            # 优化结构
            self.optimizer.optimize(deformed_cell, self.potential)
            # 计算应力
            self.potential.calculate_forces(deformed_cell)
            stress_tensor = self.stress_calculator.compute_stress(
                deformed_cell, self.potential
            )
            # 计算应变
            strain_voigt = self.strain_calculator.compute_strain(F)
            # 转换应力张量为 Voigt 表示
            stress_voigt = TensorConverter.to_voigt(stress_tensor)
            strains.append(strain_voigt)
            stresses.append(stress_voigt)

        # 使用弹性常数求解器
        elastic_solver = ElasticConstantsSolver()
        C = elastic_solver.solve(strains, stresses)
        return C


# src/python/integrators.py

import numpy as np


class Integrator:
    """
    @class Integrator
    @brief 积分器基类
    """

    def integrate(self, cell, potential, dt):
        raise NotImplementedError


class VelocityVerletIntegrator(Integrator):
    """
    @class VelocityVerletIntegrator
    @brief 速度 Verlet 积分器的实现
    """

    def integrate(self, cell, potential, dt):
        atoms = cell.atoms
        # 第一半步：更新位置
        for atom in atoms:
            atom.position += atom.velocity * dt + 0.5 * atom.force / atom.mass * dt**2
            # 应用周期性边界条件
            atom.position = cell.apply_periodic_boundary(atom.position)
        # 保存旧的力
        forces_old = [atom.force.copy() for atom in atoms]
        # 计算新的力
        potential.calculate_forces(cell)
        # 第二半步：更新速度
        for atom, force_old in zip(atoms, forces_old):
            atom.velocity += 0.5 * (atom.force + force_old) / atom.mass * dt


class RK4Integrator(Integrator):
    """
    @class RK4Integrator
    @brief 四阶 Runge-Kutta 积分器的实现
    """

    def integrate(self, cell, potential, dt):
        def get_state():
            return np.concatenate(
                [atom.position for atom in cell.atoms]
                + [atom.velocity for atom in cell.atoms]
            )

        def set_state(state):
            num_atoms = len(cell.atoms)
            positions = state[: 3 * num_atoms].reshape((num_atoms, 3))
            velocities = state[3 * num_atoms :].reshape((num_atoms, 3))
            for i, atom in enumerate(cell.atoms):
                atom.position = positions[i]
                atom.velocity = velocities[i]

        def compute_derivatives(state):
            # Set the state
            num_atoms = len(cell.atoms)
            positions = state[: 3 * num_atoms].reshape((num_atoms, 3))
            velocities = state[3 * num_atoms :].reshape((num_atoms, 3))
            for i, atom in enumerate(cell.atoms):
                atom.position = positions[i]
                atom.velocity = velocities[i]
            # Compute forces
            potential.calculate_forces(cell)
            # Compute derivatives
            derivatives = np.zeros_like(state)
            for i, atom in enumerate(cell.atoms):
                derivatives[3 * i : 3 * i + 3] = atom.velocity
                derivatives[3 * num_atoms + 3 * i : 3 * num_atoms + 3 * i + 3] = (
                    atom.force / atom.mass
                )
            return derivatives

        state = get_state()
        k1 = compute_derivatives(state)
        k2 = compute_derivatives(state + 0.5 * dt * k1)
        k3 = compute_derivatives(state + 0.5 * dt * k2)
        k4 = compute_derivatives(state + dt * k3)
        new_state = state + (dt / 6.0) * (k1 + 2 * k2 + 2 * k3 + k4)
        set_state(new_state)


# src/python/md_simulator.py


class MDSimulator:
    """
    @class MDSimulator
    @brief 分子动力学模拟器
    """

    def __init__(self, cell, potential, integrator, thermostat=None, barostat=None):
        self.cell = cell
        self.potential = potential
        self.integrator = integrator
        self.thermostat = thermostat
        self.barostat = barostat  # 为 NPT 系综预留

    def run(self, steps, dt, data_collector=None):
        # 初始化力
        self.potential.calculate_forces(self.cell)
        for step in range(steps):
            self.integrator.integrate(self.cell, self.potential, dt)
            # 应用恒温器
            if self.thermostat is not None:
                self.thermostat.apply(self.cell.atoms, dt)
            # 应用压强控制器（如果有）
            if self.barostat is not None:
                self.barostat.apply(self.cell, dt)
            if data_collector is not None:
                data_collector.collect(self.cell)
            print(f"MD Step {step} completed.")


# src/python/mechanics.py

import numpy as np
from .utils import TensorConverter
from .interfaces.cpp_interface import CppInterface


class StressCalculator:
    """
    @class StressCalculator
    @brief 应力计算器基类。
    """

    def compute_stress(self, cell, potential):
        raise NotImplementedError


class StressCalculatorLJ(StressCalculator):
    """
    @class StressCalculatorLJ
    @brief 基于 Lennard-Jones 势的应力计算器。
    """

    def __init__(self):
        self.cpp_interface = CppInterface("stress_calculator")

    def compute_stress(self, cell, potential):
        volume = cell.calculate_volume()
        atoms = cell.atoms
        num_atoms = len(atoms)
        positions = np.array(
            [atom.position for atom in atoms], dtype=np.float64
        ).flatten()
        velocities = np.array(
            [atom.velocity for atom in atoms], dtype=np.float64
        ).flatten()
        forces = np.array([atom.force for atom in atoms], dtype=np.float64).flatten()
        masses = np.array([atom.mass for atom in atoms], dtype=np.float64)
        box_lengths = cell.get_box_lengths()

        # Initialize stress tensor array
        stress_tensor = np.zeros(9, dtype=np.float64)

        # 调用 C++ 实现的应力计算函数
        self.cpp_interface.compute_stress(
            num_atoms,
            positions,
            velocities,
            forces,
            masses,
            volume,
            box_lengths,
            stress_tensor,
        )

        # Reshape the stress tensor to 3x3 matrix
        stress_tensor = stress_tensor.reshape(3, 3)
        return stress_tensor


class StrainCalculator:
    """
    @class StrainCalculator
    @brief 应变计算器类。
    """

    def compute_strain(self, F):
        """
        @brief 计算应变张量。

        @param F 变形矩阵
        @return 应变向量，形状为 (6,)
        """
        strain_tensor = 0.5 * (np.dot(F.T, F) - np.identity(3))
        # 转换为 Voigt 表示
        strain_voigt = TensorConverter.to_voigt(strain_tensor)
        # 对剪切分量乘以 2
        strain_voigt[3:] *= 2
        return strain_voigt


# src/python/optimizers.py

import numpy as np
from scipy.optimize import minimize


class Optimizer:
    """
    @class Optimizer
    @brief 优化器基类
    """

    def optimize(self, cell, potential):
        raise NotImplementedError


class GradientDescentOptimizer(Optimizer):
    """
    @class GradientDescentOptimizer
    @brief 梯度下降优化器
    """

    def __init__(self, max_steps=1000, tol=1e-6, step_size=1e-3):
        self.max_steps = max_steps
        self.tol = tol
        self.step_size = step_size
        self.converged = False  # 添加收敛标志

    def optimize(self, cell, potential):
        atoms = cell.atoms
        potential.calculate_forces(cell)
        for step in range(self.max_steps):
            # 计算最大力
            max_force = max(np.linalg.norm(atom.force) for atom in atoms)
            # print(f"Step {step}: Max force = {max_force}")
            if max_force < self.tol:
                print(f"Converged after {step} steps")
                self.converged = True
                break
            # 更新 position
            for atom in atoms:
                displacement = self.step_size * atom.force
                atom.position += displacement
                # 应用周期性边界条件
                atom.position = cell.apply_periodic_boundary(atom.position)
            # 重新计算力
            potential.calculate_forces(cell)
        else:
            print("Optimization did not converge within the maximum number of steps.")
            self.converged = False


class BFGSOptimizer(Optimizer):
    """
    @class BFGSOptimizer
    @brief BFGS 优化器，使用 scipy.optimize.minimize 实现
    """

    def __init__(self, tol=1e-6):
        self.tol = tol
        self.converged = False  # 添加收敛标志

    def optimize(self, cell, potential):
        num_atoms = cell.num_atoms
        initial_positions = np.ascontiguousarray(
            cell.get_positions(), dtype=np.float64
        ).flatten()

        def objective(x):
            # Set positions
            for i, atom in enumerate(cell.atoms):
                atom.position = x[3 * i : 3 * i + 3]
            # Calculate potential energy
            energy = potential.calculate_energy(cell)
            return energy

        def gradient(x):
            # Set positions
            for i, atom in enumerate(cell.atoms):
                atom.position = x[3 * i : 3 * i + 3]
            # Calculate forces
            potential.calculate_forces(cell)
            # Gradient is -force
            grad = -np.array([atom.force for atom in cell.atoms]).flatten()
            return grad

        result = minimize(
            objective,
            initial_positions,
            method="BFGS",
            jac=gradient,
            options={"gtol": self.tol, "disp": True},
        )

        # Update positions after optimization
        optimized_positions = result.x
        for i, atom in enumerate(cell.atoms):
            atom.position = optimized_positions[3 * i : 3 * i + 3]
        # Recalculate forces
        potential.calculate_forces(cell)

        self.converged = result.success


import numpy as np
import matplotlib.pyplot as plt
from python.potentials import LennardJonesPotential
from python.structure import Cell, Atom  # 假设已有的结构体定义

# 创建 Lennard-Jones 势
epsilon = 0.0103  # eV
sigma = 2.55  # Å
cutoff = 5.1  # Å
lj_potential = LennardJonesPotential(epsilon, sigma, cutoff)

# 创建模拟单元格
atoms = [
    Atom(id=0, symbol="Al", mass=26.9815, position=np.array([0.0, 0.0, 0.0])),
    Atom(id=1, symbol="Al", mass=26.9815, position=np.array([2.5, 0.0, 0.0])),
]
box_lengths = np.array([30.0, 30.0, 30.0])  # 立方体盒子

cell = Cell(atoms=atoms, lattice_vectors=np.eye(3) * 20.0, pbc_enabled=True)

# 准备测试距离
distances = np.linspace(2.4, 6.0, 1000)
forces = []
energies = []

# 修改原子位置，计算不同距离下的力和能量
for d in distances:
    cell.atoms[1].position = np.array([d, 0.0, 0.0])

    # 计算力和能量
    lj_potential.calculate_forces(cell)
    forces.append(cell.atoms[0].force[0])  # 只记录x方向力
    energies.append(lj_potential.calculate_energy(cell))

# 绘制力-距离和能量-距离曲线
plt.figure(figsize=(12, 5))

plt.subplot(1, 2, 1)
plt.plot(distances, forces)
plt.title("Force vs. Distance")
plt.xlabel("Distance (Å)")
plt.ylabel("Force (eV/Å)")

plt.subplot(1, 2, 2)
plt.plot(distances, energies)
plt.title("Energy vs. Distance")
plt.xlabel("Distance (Å)")
plt.ylabel("Energy (eV)")

plt.tight_layout()
plt.show()


# src/python/potentials.py

import numpy as np
from .interfaces.cpp_interface import CppInterface


class Potential:
    """
    @class Potential
    @brief 势能基类
    """

    def __init__(self, parameters, cutoff):
        self.parameters = parameters
        self.cutoff = cutoff

    def calculate_potential(self, cell):
        raise NotImplementedError

    def calculate_forces(self, cell):
        raise NotImplementedError

    def calculate_energy(self, cell):
        raise NotImplementedError


class LennardJonesPotential(Potential):
    """
    @class LennardJonesPotential
    @brief Lennard-Jones 势的实现
    """

    def __init__(self, epsilon, sigma, cutoff):
        parameters = {"epsilon": epsilon, "sigma": sigma}
        super().__init__(parameters, cutoff)
        self.epsilon = epsilon  # 单位 eV
        self.sigma = sigma  # 单位 Å
        self.cutoff = cutoff  # 单位 Å
        self.cpp_interface = CppInterface("lennard_jones")

    def calculate_forces(self, cell):
        num_atoms = cell.num_atoms
        positions = np.ascontiguousarray(
            cell.get_positions(), dtype=np.float64
        ).flatten()
        forces = np.zeros_like(positions, dtype=np.float64)
        box_lengths = np.ascontiguousarray(cell.get_box_lengths(), dtype=np.float64)

        self.cpp_interface.calculate_forces(
            num_atoms,
            positions,
            forces,
            self.epsilon,
            self.sigma,
            self.cutoff,
            box_lengths,
        )
        # 更新原子力
        forces = forces.reshape((num_atoms, 3))
        for i, atom in enumerate(cell.atoms):
            atom.force = forces[i]

    def calculate_energy(self, cell):
        num_atoms = cell.num_atoms
        positions = np.ascontiguousarray(
            cell.get_positions(), dtype=np.float64
        ).flatten()
        box_lengths = np.ascontiguousarray(cell.get_box_lengths(), dtype=np.float64)

        energy = self.cpp_interface.calculate_energy(
            num_atoms,
            positions,
            self.epsilon,
            self.sigma,
            self.cutoff,
            box_lengths,
        )
        return energy


# src/python/structure.py

import numpy as np


class Atom:
    """
    @class Atom
    @brief 原子类，包含原子的信息和属性。
    """

    def __init__(self, id, symbol, mass, position, velocity=None):
        self.id = id
        self.symbol = symbol
        self.mass = mass
        self.position = np.array(position, dtype=np.float64)
        self.velocity = (
            np.zeros(3, dtype=np.float64)
            if velocity is None
            else np.array(velocity, dtype=np.float64)
        )
        self.force = np.zeros(3, dtype=np.float64)

    def update_position(self, delta_r):
        self.position += delta_r

    def update_velocity(self, delta_v):
        self.velocity += delta_v


class Cell:
    """
    @class Cell
    @brief 晶胞类，包含晶格矢量和原子列表。
    """

    def __init__(self, lattice_vectors, atoms, pbc_enabled=True):
        self.lattice_vectors = np.array(lattice_vectors, dtype=np.float64)
        self.atoms = atoms  # 原子列表
        self.volume = self.calculate_volume()
        self.pbc_enabled = pbc_enabled

    def calculate_volume(self):
        return np.linalg.det(self.lattice_vectors)

    def get_box_lengths(self):
        """
        返回模拟盒子在 x、y、z 方向的长度。
        """
        box_lengths = np.linalg.norm(self.lattice_vectors, axis=1)
        return box_lengths

    def apply_deformation(self, deformation_matrix):
        """
        @brief 对晶胞和原子坐标施加变形矩阵。

        @param deformation_matrix 3x3 变形矩阵
        """
        # 更新晶格矢量
        self.lattice_vectors = np.dot(self.lattice_vectors, deformation_matrix.T)
        # 更新原子坐标
        for atom in self.atoms:
            atom.position = np.dot(deformation_matrix, atom.position)

    def apply_periodic_boundary(self, position):
        if self.pbc_enabled:
            # 转换到分数坐标
            fractional = np.linalg.solve(self.lattice_vectors.T, position)
            # 确保在 [0, 1) 范围内
            fractional = fractional % 1.0
            # 转换回笛卡尔坐标
            return np.dot(self.lattice_vectors.T, fractional)
        else:
            return position

    def copy(self):
        atoms_copy = [
            Atom(
                atom.id,
                atom.symbol,
                atom.mass,
                atom.position.copy(),
                atom.velocity.copy(),
            )
            for atom in self.atoms
        ]
        return Cell(self.lattice_vectors.copy(), atoms_copy, self.pbc_enabled)

    @property
    def num_atoms(self):
        """
        @property num_atoms
        @brief 返回原子数量。
        """
        return len(self.atoms)

    def get_positions(self):
        """
        @brief 获取所有原子的位置信息。

        @return numpy.ndarray, 形状为 (num_atoms, 3)
        """
        return np.array([atom.position for atom in self.atoms], dtype=np.float64)

    def get_velocities(self):
        """
        @brief 获取所有原子的速度信息。

        @return numpy.ndarray, 形状为 (num_atoms, 3)
        """
        return np.array([atom.velocity for atom in self.atoms], dtype=np.float64)

    def get_forces(self):
        """
        @brief 获取所有原子的力信息。

        @return numpy.ndarray, 形状为 (num_atoms, 3)
        """
        return np.array([atom.force for atom in self.atoms], dtype=np.float64)


# src/python/thermostats.py

import numpy as np
from .interfaces.cpp_interface import CppInterface


class Thermostat:
    """
    @class Thermostat
    @brief 恒温器基类
    """

    def apply(self, atoms, dt):
        raise NotImplementedError


class NoseHooverThermostat(Thermostat):
    """
    @class NoseHooverThermostat
    @brief Nose-Hoover 恒温器的实现
    """

    def __init__(self, target_temperature, time_constant):
        self.target_temperature = target_temperature
        self.time_constant = time_constant
        self.cpp_interface = CppInterface("nose_hoover")
        self.xi = np.array([0.0], dtype=np.float64)  # 初始热浴变量，改为 NumPy 数组
        self.Q = 10.0  # 热浴质量参数，可根据需要调整

    def apply(self, atoms, dt):
        num_atoms = len(atoms)
        masses = np.array([atom.mass for atom in atoms], dtype=np.float64)
        velocities = np.array(
            [atom.velocity for atom in atoms], dtype=np.float64
        ).flatten()
        forces = np.array([atom.force for atom in atoms], dtype=np.float64).flatten()

        # 调用 C++ Nose-Hoover 函数
        try:
            updated_xi = self.cpp_interface.nose_hoover(
                dt,
                num_atoms,
                masses,
                velocities,
                forces,
                self.xi,  # 传递 NumPy 数组
                self.Q,
                self.target_temperature,
            )
            self.xi[0] = updated_xi  # 更新 xi 的值
        except OSError as e:
            print(f"C++ Nose-Hoover 调用失败: {e}")
            raise

        # 更新原子的速度
        velocities = velocities.reshape((num_atoms, 3))
        for i, atom in enumerate(atoms):
            atom.velocity = velocities[i]


class NoseHooverChainThermostat(Thermostat):
    """
    @class NoseHooverChainThermostat
    @brief Nose-Hoover 链恒温器的实现
    """

    def __init__(self, target_temperature, time_constant, chain_length=2):
        self.target_temperature = target_temperature
        self.time_constant = time_constant
        self.chain_length = chain_length
        self.cpp_interface = CppInterface("nose_hoover_chain")

    def apply_thermostat(self, cell, dt, xi_chain, Q):
        num_atoms = len(cell.atoms)
        masses = np.array([atom.mass for atom in cell.atoms], dtype=np.float64)
        velocities = np.array(
            [atom.velocity for atom in cell.atoms], dtype=np.float64
        ).flatten()
        forces = np.array(
            [atom.force for atom in cell.atoms], dtype=np.float64
        ).flatten()

        self.cpp_interface.nose_hoover_chain(
            dt,
            num_atoms,
            masses,
            velocities,
            forces,
            xi_chain,
            Q,
            self.chain_length,
            self.target_temperature,
        )

        # 更新原子的速度
        velocities = velocities.reshape((num_atoms, 3))
        for i, atom in enumerate(cell.atoms):
            atom.velocity = velocities[i]


# src/python/utils.py

import numpy as np


class TensorConverter:
    """
    @class TensorConverter
    @brief 张量转换工具类。
    """

    @staticmethod
    def to_voigt(tensor):
        """
        @brief 将 3x3 张量转换为 Voigt 表示的 6 元素向量。

        @param tensor 3x3 numpy 数组
        @return 6 元素的 numpy 数组
        """
        voigt = np.array(
            [
                tensor[0, 0],
                tensor[1, 1],
                tensor[2, 2],
                tensor[1, 2],
                tensor[0, 2],
                tensor[0, 1],
            ]
        )
        return voigt

    @staticmethod
    def from_voigt(voigt):
        """
        @brief 将 Voigt 表示的 6 元素向量转换为 3x3 张量。

        @param voigt 6 元素的 numpy 数组
        @return 3x3 numpy 数组
        """
        tensor = np.array(
            [
                [voigt[0], voigt[5], voigt[4]],
                [voigt[5], voigt[1], voigt[3]],
                [voigt[4], voigt[3], voigt[2]],
            ]
        )
        return tensor


class DataCollector:
    """
    @class DataCollector
    @brief 数据收集工具类，用于收集模拟过程中的各种数据。
    """

    def __init__(self):
        self.data = []

    def collect(self, cell):
        """
        @brief 收集晶胞中的原子位置和速度。
        """
        positions = [atom.position.copy() for atom in cell.atoms]
        velocities = [atom.velocity.copy() for atom in cell.atoms]
        self.data.append({"positions": positions, "velocities": velocities})


# 添加单位转换常量
# 单位转换常量
# 1 amu = 104.3968445 eV·fs²/Å²
AMU_TO_EVFSA2 = 104.3968445


# src/python/visualization.py

"""
@file visualization.py
@brief 可视化晶胞结构和模拟结果的模块。
"""

import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
import numpy as np

from .structure import Cell


class Visualizer:
    """
    @class Visualizer
    @brief 可视化晶胞结构和模拟结果的类。
    """

    def __init__(self):
        pass

    def plot_cell_structure(self, cell_structure: Cell, show=True):
        """
        @brief 绘制晶体结构的 3D 图形。

        @param cell_structure Cell 实例。
        @param show 是否显示图形，默认为 True。
        @return 返回绘图对象 fig 和 ax。
        """
        fig = plt.figure()
        ax = fig.add_subplot(111, projection="3d")
        for atom in cell_structure.atoms:
            ax.scatter(*atom.position, label=atom.symbol)
        # 绘制晶格矢量
        origin = [0, 0, 0]
        lattice_vectors = cell_structure.lattice_vectors
        for i in range(3):
            vec = lattice_vectors[:, i]
            ax.quiver(*origin, *vec, color="r", arrow_length_ratio=0.1)
        ax.set_xlabel("X (Å)")
        ax.set_ylabel("Y (Å)")
        ax.set_zlabel("Z (Å)")
        plt.title("Crystal Structure")
        plt.legend()
        if show:
            plt.show()
        return fig, ax

    def plot_stress_strain(
        self, strain_data: np.ndarray, stress_data: np.ndarray, show=True
    ):
        """
        @brief 绘制应力-应变关系图。

        @param strain_data numpy.ndarray: 应变数据，形状为 (N, 6)。
        @param stress_data numpy.ndarray: 应力数据，形状为 (N, 6)。
        @param show 是否显示图形，默认为 True。
        @return 返回绘图对象 fig 和 ax。
        """
        fig, ax = plt.subplots(figsize=(10, 6))
        for i in range(6):
            ax.plot(strain_data[:, i], stress_data[:, i], label=f"Stress {i+1}")
        ax.set_xlabel("Strain")
        ax.set_ylabel("Stress (eV/Å³)")
        ax.set_title("Stress-Strain Relationship")
        ax.legend()
        ax.grid(True)
        plt.tight_layout()
        if show:
            plt.show()
        return fig, ax


# src/python/__init__.py

"""
@package ThermoElasticSim
@brief 初始化 ThermoElasticSim 项目。

该项目包含用于计算和模拟金属铝（Al）和金刚石（Diamond）在不同温度下弹性常数的模块。
"""

# 导入子模块
from .structure import Atom, Cell
from .potentials import Potential, LennardJonesPotential
from .integrators import Integrator, VelocityVerletIntegrator, RK4Integrator
from .thermostats import Thermostat, NoseHooverThermostat, NoseHooverChainThermostat
from .barostats import Barostat, ParrinelloRahmanHooverBarostat
from .mechanics import StressCalculator, StressCalculatorLJ, StrainCalculator
from .elasticity import ElasticConstantsSolver, ElasticConstantsCalculator
from .optimizers import Optimizer, GradientDescentOptimizer, BFGSOptimizer
from .deformation import Deformer
from .utils import TensorConverter, DataCollector
from .visualization import Visualizer
from .md_simulator import MDSimulator
from .config import ConfigManager
from .interfaces.cpp_interface import CppInterface


# src/python/interfaces/cpp_interface.py

import ctypes
import numpy as np
from numpy.ctypeslib import ndpointer
import os

# from ..utils import AMU_TO_EVFSA2  # 如果需要，确保导入单位转换常量


class CppInterface:
    """
    @class CppInterface
    @brief 用于调用 C++ 实现的函数的接口类。
    """

    def __init__(self, lib_name):
        """
        @param lib_name 库的名称，不包括前缀和扩展名
        """
        if os.name == "nt":  # Windows
            lib_extension = ".dll"
            lib_prefix = ""
        else:  # Unix/Linux
            lib_extension = ".so"
            lib_prefix = "lib"

        # 获取当前文件所在目录的绝对路径
        current_dir = os.path.dirname(os.path.abspath(__file__))
        # 获取项目根目录的绝对路径
        project_root = os.path.abspath(os.path.join(current_dir, "..", ".."))
        # 构建库文件的绝对路径
        lib_path = os.path.join(
            project_root, "lib", lib_prefix + lib_name + lib_extension
        )
        # 检查库文件是否存在
        if not os.path.exists(lib_path):
            raise FileNotFoundError(f"无法找到库文件: {lib_path}")

        self.lib = ctypes.CDLL(lib_path)

        # 配置不同库的函数签名
        if lib_name == "stress_calculator":
            self.lib.compute_stress.argtypes = [
                ctypes.c_int,  # num_atoms
                ndpointer(ctypes.c_double, flags="C_CONTIGUOUS"),  # positions
                ndpointer(ctypes.c_double, flags="C_CONTIGUOUS"),  # velocities
                ndpointer(ctypes.c_double, flags="C_CONTIGUOUS"),  # forces
                ndpointer(ctypes.c_double, flags="C_CONTIGUOUS"),  # masses (amu)
                ctypes.c_double,  # volume
                ndpointer(ctypes.c_double, flags="C_CONTIGUOUS"),  # box_lengths
                ndpointer(
                    ctypes.c_double, flags="C_CONTIGUOUS"
                ),  # stress_tensor (output)
            ]
            self.lib.compute_stress.restype = None

        elif lib_name == "lennard_jones":
            self.lib.calculate_forces.argtypes = [
                ctypes.c_int,  # num_atoms
                ndpointer(ctypes.c_double, flags="C_CONTIGUOUS"),  # positions
                ndpointer(ctypes.c_double, flags="C_CONTIGUOUS"),  # forces
                ctypes.c_double,  # epsilon
                ctypes.c_double,  # sigma
                ctypes.c_double,  # cutoff
                ndpointer(ctypes.c_double, flags="C_CONTIGUOUS"),  # box_lengths
            ]
            self.lib.calculate_forces.restype = None

            self.lib.calculate_energy.argtypes = [
                ctypes.c_int,  # num_atoms
                ndpointer(ctypes.c_double, flags="C_CONTIGUOUS"),  # positions
                ctypes.c_double,  # epsilon
                ctypes.c_double,  # sigma
                ctypes.c_double,  # cutoff
                ndpointer(ctypes.c_double, flags="C_CONTIGUOUS"),  # box_lengths
            ]
            self.lib.calculate_energy.restype = ctypes.c_double

        elif lib_name == "nose_hoover":
            self.lib.nose_hoover.argtypes = [
                ctypes.c_double,  # dt
                ctypes.c_int,  # num_atoms
                ndpointer(ctypes.c_double, flags="C_CONTIGUOUS"),  # masses
                ndpointer(ctypes.c_double, flags="C_CONTIGUOUS"),  # velocities
                ndpointer(ctypes.c_double, flags="C_CONTIGUOUS"),  # forces
                ctypes.POINTER(ctypes.c_double),  # xi (input/output)
                ctypes.c_double,  # Q
                ctypes.c_double,  # target_temperature
            ]
            self.lib.nose_hoover.restype = None

        elif lib_name == "nose_hoover_chain":
            self.lib.nose_hoover_chain.argtypes = [
                ctypes.c_double,  # dt
                ctypes.c_int,  # num_atoms
                ndpointer(ctypes.c_double, flags="C_CONTIGUOUS"),  # masses
                ndpointer(ctypes.c_double, flags="C_CONTIGUOUS"),  # velocities
                ndpointer(ctypes.c_double, flags="C_CONTIGUOUS"),  # forces
                ndpointer(ctypes.c_double, flags="C_CONTIGUOUS"),  # xi_chain
                ndpointer(ctypes.c_double, flags="C_CONTIGUOUS"),  # Q
                ctypes.c_int,  # chain_length
                ctypes.c_double,  # target_temperature
            ]
            self.lib.nose_hoover_chain.restype = None

        else:
            raise ValueError(f"未知的库名称: {lib_name}")

    def compute_stress(
        self,
        num_atoms,
        positions,
        velocities,
        forces,
        masses,
        volume,
        box_lengths,
        stress_tensor,
    ):
        """
        计算应力张量。
        """
        self.lib.compute_stress(
            num_atoms,
            positions,
            velocities,
            forces,
            masses,
            volume,
            box_lengths,
            stress_tensor,
        )

    def calculate_energy(
        self,
        num_atoms,
        positions,
        epsilon,
        sigma,
        cutoff,
        box_lengths,
    ):
        """
        计算系统的总 Lennard-Jones 势能。
        """
        energy = self.lib.calculate_energy(
            num_atoms,
            positions,
            epsilon,
            sigma,
            cutoff,
            box_lengths,
        )
        return energy

    def calculate_forces(
        self,
        num_atoms,
        positions,
        forces,
        epsilon,
        sigma,
        cutoff,
        box_lengths,
    ):
        """
        计算系统的力。
        """
        self.lib.calculate_forces(
            num_atoms,
            positions,
            forces,
            epsilon,
            sigma,
            cutoff,
            box_lengths,
        )

    def nose_hoover(
        self,
        dt,
        num_atoms,
        masses,
        velocities,
        forces,
        xi_array,  # 现在接受一个numpy数组
        Q,
        target_temperature,
    ):
        """
        实现 Nose-Hoover 恒温器算法
        """
        if not isinstance(xi_array, np.ndarray) or xi_array.size != 1:
            raise ValueError("xi must be a numpy array with one element.")
        self.lib.nose_hoover(
            dt,
            num_atoms,
            masses,
            velocities,
            forces,
            xi_array.ctypes.data_as(ctypes.POINTER(ctypes.c_double)),
            Q,
            target_temperature,
        )
        return xi_array[0]  # 返回更新后的 xi 值

    def nose_hoover_chain(
        self,
        dt,
        num_atoms,
        masses,
        velocities,
        forces,
        xi_chain,
        Q,
        chain_length,
        target_temperature,
    ):
        """
        实现 Nose-Hoover 链恒温器算法
        """
        self.lib.nose_hoover_chain(
            dt,
            num_atoms,
            masses,
            velocities,
            forces,
            xi_chain,
            Q,
            chain_length,
            target_temperature,
        )


# src/python/interfaces/__init__.py


