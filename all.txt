src/
    cpp/
        lennard_jones.cpp
        nose_hoover.cpp
        nose_hoover_chain.cpp
        parrinello_rahman_hoover.cpp
        stress_calculator.cpp
    lib/
        lennard_jones.dll
        nose_hoover.dll
        nose_hoover_chain.dll
        parrinello_rahman_hoover.dll
        stress_calculator.dll
    python/
        barostats.py
        config.py
        deformation.py
        elasticity.py
        integrators.py
        md_simulator.py
        mechanics.py
        optimizers.py
        potentials.py
        structure.py
        thermostats.py
        utils.py
        visualization.py
        __init__.py
// src/cpp/lennard_jones.cpp

#include <cmath>
#include <vector>
#include <iostream>

extern "C"
{
    /**
     * @brief 计算 Lennard-Jones 力，使用最小镜像法处理周期性边界条件
     *
     * @param num_atoms 原子数量
     * @param positions 原子位置数组（长度为 3*num_atoms）
     * @param forces 输出的力数组（长度为 3*num_atoms）
     * @param epsilon Lennard-Jones 势参数 ε，单位为 eV
     * @param sigma Lennard-Jones 势参数 σ，单位为 Å
     * @param cutoff 截断半径，单位为 Å
     * @param box_lengths 模拟盒子在每个维度的长度（长度为 3）
     */
    void calculate_forces(
        int num_atoms,
        const double *positions,
        double *forces,
        double epsilon,
        double sigma,
        double cutoff,
        const double *box_lengths // 长度为 3
    )
    {
        // 清零力数组
        for (int i = 0; i < 3 * num_atoms; ++i)
        {
            forces[i] = 0.0;
        }

        double cutoff_sq = cutoff * cutoff;
        // 计算力的截断修正
        double force_shift = 48.0 * epsilon * (pow(sigma / cutoff, 12) - 0.5 * pow(sigma / cutoff, 6));

        // 力的计算
        for (int i = 0; i < num_atoms; ++i)
        {
            const double *ri = &positions[3 * i];
            for (int j = i + 1; j < num_atoms; ++j)
            {
                const double *rj = &positions[3 * j];
                double rij[3];
                for (int k = 0; k < 3; ++k)
                {
                    rij[k] = ri[k] - rj[k];
                    // 最小镜像法
                    if (rij[k] > 0.5 * box_lengths[k])
                        rij[k] -= box_lengths[k];
                    else if (rij[k] < -0.5 * box_lengths[k])
                        rij[k] += box_lengths[k];
                }

                double r2 = rij[0] * rij[0] + rij[1] * rij[1] + rij[2] * rij[2];

                if (r2 < cutoff_sq)
                {
                    double r = sqrt(r2);
                    double r2_inv = 1.0 / r2;
                    double r6_inv = pow(sigma * sigma * r2_inv, 3); // (sigma/r)^6
                    double force_scalar = 48.0 * epsilon * r6_inv * (r6_inv - 0.5);

                    // 力的截断修正
                    force_scalar -= force_shift;

                    for (int k = 0; k < 3; ++k)
                    {
                        double fij = force_scalar * rij[k];
                        forces[3 * i + k] += fij;
                        forces[3 * j + k] -= fij;
                    }
                }
            }
        }
    }

    /**
     * @brief 计算 Lennard-Jones 势能，使用最小镜像法处理周期性边界条件
     *
     * @param num_atoms 原子数量
     * @param positions 原子位置数组（长度为 3*num_atoms）
     * @param epsilon Lennard-Jones 势参数 ε，单位为 eV
     * @param sigma Lennard-Jones 势参数 σ，单位为 Å
     * @param cutoff 截断半径，单位为 Å
     * @param box_lengths 模拟盒子在每个维度的长度（长度为 3）
     * @return 总 Lennard-Jones 势能，单位为 eV
     */
    double calculate_energy(
        int num_atoms,
        const double *positions,
        double epsilon,
        double sigma,
        double cutoff,
        const double *box_lengths // 长度为 3
    )
    {
        double energy = 0.0;
        double cutoff_sq = cutoff * cutoff;
        double shift = 4.0 * epsilon * (pow(sigma / cutoff, 12) - pow(sigma / cutoff, 6));

        for (int i = 0; i < num_atoms; ++i)
        {
            const double *ri = &positions[3 * i];
            for (int j = i + 1; j < num_atoms; ++j)
            {
                const double *rj = &positions[3 * j];
                double rij[3];
                for (int k = 0; k < 3; ++k)
                {
                    rij[k] = ri[k] - rj[k];
                    // 最小镜像法
                    if (rij[k] > 0.5 * box_lengths[k])
                        rij[k] -= box_lengths[k];
                    else if (rij[k] < -0.5 * box_lengths[k])
                        rij[k] += box_lengths[k];
                }

                double r2 = rij[0] * rij[0] + rij[1] * rij[1] + rij[2] * rij[2];

                if (r2 < cutoff_sq)
                {
                    double r2_inv = 1.0 / r2;
                    double r6_inv = pow(sigma * sigma * r2_inv, 3); // (sigma/r)^6
                    double potential = 4.0 * epsilon * (r6_inv * r6_inv - r6_inv) - shift;
                    energy += potential;
                }
            }
        }

        return energy;
    }
}


// src/cpp/nose_hoover.cpp

#include <cmath>
#include <vector>

extern "C"
{
    /**
     * @brief 应用 Nose-Hoover 恒温器
     *
     * @param dt 时间步长
     * @param num_atoms 原子数量
     * @param masses 原子质量数组（长度为 num_atoms）
     * @param velocities 原子速度数组（长度为 3*num_atoms）
     * @param forces 原子力数组（长度为 3*num_atoms）
     * @param xi 热浴变量
     * @param Q 热浴质量参数
     * @param target_temperature 目标温度
     */
    void nose_hoover(
        double dt,
        int num_atoms,
        const double *masses,
        double *velocities,
        const double *forces,
        double *xi,
        double Q,
        double target_temperature)
    {
        double dt_half = dt * 0.5;
        double kB = 8.617333262e-5; // 玻尔兹曼常数，单位 eV/K

        // 第一半步：更新速度，考虑力
        for (int i = 0; i < num_atoms; ++i)
        {
            velocities[3 * i] += dt_half * forces[3 * i] / masses[i];
            velocities[3 * i + 1] += dt_half * forces[3 * i + 1] / masses[i];
            velocities[3 * i + 2] += dt_half * forces[3 * i + 2] / masses[i];
        }

        // 更新 xi（热浴变量） - 第一半步
        double kinetic_energy = 0.0;
        for (int i = 0; i < num_atoms; ++i)
        {
            double vx = velocities[3 * i];
            double vy = velocities[3 * i + 1];
            double vz = velocities[3 * i + 2];
            kinetic_energy += 0.5 * masses[i] * (vx * vx + vy * vy + vz * vz);
        }
        double G_xi = (2.0 * kinetic_energy - 3.0 * num_atoms * kB * target_temperature) / Q;
        *xi += dt_half * G_xi;

        // 缩放速度
        double scale = exp(-(*xi) * dt);
        for (int i = 0; i < num_atoms; ++i)
        {
            velocities[3 * i] *= scale;
            velocities[3 * i + 1] *= scale;
            velocities[3 * i + 2] *= scale;
        }

        // 更新 xi（热浴变量） - 第二半步
        kinetic_energy = 0.0;
        for (int i = 0; i < num_atoms; ++i)
        {
            double vx = velocities[3 * i];
            double vy = velocities[3 * i + 1];
            double vz = velocities[3 * i + 2];
            kinetic_energy += 0.5 * masses[i] * (vx * vx + vy * vy + vz * vz);
        }
        G_xi = (2.0 * kinetic_energy - 3.0 * num_atoms * kB * target_temperature) / Q;
        *xi += dt_half * G_xi;

        // 第二半步：更新速度，考虑力
        for (int i = 0; i < num_atoms; ++i)
        {
            velocities[3 * i] += dt_half * forces[3 * i] / masses[i];
            velocities[3 * i + 1] += dt_half * forces[3 * i + 1] / masses[i];
            velocities[3 * i + 2] += dt_half * forces[3 * i + 2] / masses[i];
        }
    }
}


// src/cpp/nose_hoover_chain.cpp

#include <cmath>
#include <vector>

extern "C"
{
    /**
     * @brief 应用 Nose-Hoover 链恒温器
     *
     * @param dt 时间步长
     * @param num_atoms 原子数量
     * @param masses 原子质量数组（长度为 num_atoms）
     * @param velocities 原子速度数组（长度为 3*num_atoms）
     * @param forces 原子力数组（长度为 3*num_atoms）
     * @param xi 热浴变量数组（长度为 chain_length）
     * @param Q 热浴质量参数数组（长度为 chain_length）
     * @param chain_length 热浴链的长度
     * @param target_temperature 目标温度
     */
    void nose_hoover_chain(
        double dt,
        int num_atoms,
        const double *masses,
        double *velocities,
        const double *forces,
        double *xi,
        const double *Q,
        int chain_length,
        double target_temperature)
    {
        // 使用 std::vector 代替动态数组
        std::vector<double> G_chain(chain_length, 0.0);

        double dt_half = dt * 0.5;
        double kB = 8.617333262e-5; // 玻尔兹曼常数，单位 eV/K

        // 计算动能
        double kinetic_energy = 0.0;
        for (int i = 0; i < num_atoms; ++i)
        {
            double vx = velocities[3 * i];
            double vy = velocities[3 * i + 1];
            double vz = velocities[3 * i + 2];
            kinetic_energy += 0.5 * masses[i] * (vx * vx + vy * vy + vz * vz);
        }

        // 递推更新 Nose-Hoover 链
        G_chain[0] = (2.0 * kinetic_energy - 3.0 * num_atoms * kB * target_temperature) / Q[0];
        for (int i = 1; i < chain_length; ++i)
        {
            G_chain[i] = (Q[i - 1] * xi[i - 1] * xi[i - 1] - kB * target_temperature) / Q[i];
        }

        // 更新 xi
        for (int i = chain_length - 1; i >= 0; --i)
        {
            xi[i] += G_chain[i] * dt_half;
        }

        // 缩放速度
        double scale = exp(-xi[0] * dt);
        for (int i = 0; i < num_atoms; ++i)
        {
            velocities[3 * i] *= scale;
            velocities[3 * i + 1] *= scale;
            velocities[3 * i + 2] *= scale;
        }

        // 更新 xi
        for (int i = 0; i < chain_length; ++i)
        {
            xi[i] += G_chain[i] * dt_half;
        }

        // 更新速度，考虑力
        for (int i = 0; i < num_atoms; ++i)
        {
            velocities[3 * i] += dt * forces[3 * i] / masses[i];
            velocities[3 * i + 1] += dt * forces[3 * i + 1] / masses[i];
            velocities[3 * i + 2] += dt * forces[3 * i + 2] / masses[i];
        }
    }
}


// src/cpp/parrinello_rahman_hoover.cpp

#include <cmath>
#include <vector>

extern "C"
{
    /**
     * @brief 应用 Parrinello-Rahman-Hoover 恒压器
     *
     * @param dt 时间步长
     * @param num_atoms 原子数量
     * @param masses 原子质量数组（长度为 num_atoms）
     * @param velocities 原子速度数组（长度为 3*num_atoms）
     * @param forces 原子力数组（长度为 3*num_atoms）
     * @param lattice_vectors 当前晶格矢量（长度为 9, row-major order）
     * @param xi 热浴变量数组（长度为 6}
     * @param Q 热浴质量参数数组（长度为 6}
     * @param target_pressure 目标压力
     */
    void parrinello_rahman_hoover(
        double dt,
        int num_atoms,
        const double *masses,
        double *velocities,
        const double *forces,
        double *lattice_vectors, // 3x3 matrix, row-major
        double *xi,
        const double *Q,
        double target_pressure)
    {
        // 这个是一个简单的实现示例，实际的 PRH 恒温器更复杂
        // 这里只提供一个简单的缩放实现

        // 计算当前压力（简化示例）
        double current_pressure = 0.0;
        for (int i = 0; i < 3; ++i)
        {
            for (int j = 0; j < 3; ++j)
            {
                current_pressure += lattice_vectors[i * 3 + j] * forces[j * 3 + i];
            }
        }
        current_pressure /= 3.0;

        // 计算压力差
        double delta_P = current_pressure - target_pressure;

        // 更新热浴变量
        for (int i = 0; i < 6; ++i)
        {
            xi[i] += (delta_P)*dt / Q[i];
        }

        // 调整晶胞的晶格向量
        for (int i = 0; i < 9; ++i)
        {
            lattice_vectors[i] *= exp(-xi[i % 6] * dt); // 简单缩放
        }

        // 更新原子速度（简化示例）
        for (int i = 0; i < num_atoms; ++i)
        {
            velocities[3 * i] *= exp(-xi[0] * dt);
            velocities[3 * i + 1] *= exp(-xi[1] * dt);
            velocities[3 * i + 2] *= exp(-xi[2] * dt);
        }
    }
}


// src/cpp/stress_calculator.cpp

#include <cmath>
#include <vector>

extern "C"
{
    /**
     * @brief 计算应力张量
     *
     * @param num_atoms 原子数量
     * @param positions 原子位置数组（长度为 3*num_atoms）
     * @param velocities 原子速度数组（长度为 3*num_atoms）
     * @param forces 原子力数组（长度为 3*num_atoms）
     * @param masses 原子质量数组（长度为 num_atoms）
     * @param volume 系统体积
     * @param box_lengths 模拟盒子在每个维度的长度（长度为 3）
     * @param stress_tensor 输出的应力张量（长度为 9，按行主序存储 3x3 矩阵）
     */
    void compute_stress(
        int num_atoms,
        const double *positions,
        const double *velocities,
        const double *forces,
        const double *masses,
        double volume,
        const double *box_lengths,
        double *stress_tensor // 输出
    )
    {
        // 初始化应力张量
        for (int i = 0; i < 9; ++i)
        {
            stress_tensor[i] = 0.0;
        }

        // 动能贡献
        for (int i = 0; i < num_atoms; ++i)
        {
            double m = masses[i];
            const double *v = &velocities[3 * i];
            for (int alpha = 0; alpha < 3; ++alpha)
            {
                for (int beta = 0; beta < 3; ++beta)
                {
                    stress_tensor[3 * alpha + beta] += m * v[alpha] * v[beta];
                }
            }
        }

        // 势能贡献
        for (int i = 0; i < num_atoms; ++i)
        {
            const double *ri = &positions[3 * i];
            const double *fi = &forces[3 * i];
            for (int alpha = 0; alpha < 3; ++alpha)
            {
                for (int beta = 0; beta < 3; ++beta)
                {
                    stress_tensor[3 * alpha + beta] += ri[beta] * fi[alpha];
                }
            }
        }

        // 归一化
        for (int i = 0; i < 9; ++i)
        {
            stress_tensor[i] = (stress_tensor[i]) / volume;
        }
    }
}


# src/python/barostats.py

import numpy as np
from .interfaces.cpp_interface import CppInterface
from .mechanics import StressCalculatorLJ


class Barostat:
    """
    @class Barostat
    @brief 恒压器基类
    """

    def apply(self, cell, dt):
        raise NotImplementedError


class ParrinelloRahmanHooverBarostat(Barostat):
    """
    @class ParrinelloRahmanHooverBarostat
    @brief Parrinello-Rahman-Hoover (PRH) 恒压器的实现
    """

    def __init__(self, target_pressure, time_constant, Qp=None):
        self.target_pressure = target_pressure
        self.time_constant = time_constant
        self.Qp = Qp if Qp is not None else np.ones(6) * (time_constant**2)
        self.xi = np.zeros(6)  # 热浴变量数组
        self.cpp_interface = CppInterface("parrinello_rahman_hoover")

    def apply(self, cell, dt):
        num_atoms = len(cell.atoms)
        masses = np.array([atom.mass for atom in cell.atoms], dtype=np.float64)
        velocities = np.array(
            [atom.velocity for atom in cell.atoms], dtype=np.float64
        ).flatten()
        forces = np.array(
            [atom.force for atom in cell.atoms], dtype=np.float64
        ).flatten()
        lattice_vectors = cell.lattice_vectors.flatten()

        # 调用 C++ PRH 函数
        self.cpp_interface.parrinello_rahman_hoover(
            dt,
            num_atoms,
            masses,
            velocities,
            forces,
            lattice_vectors,
            self.xi,
            self.Qp,
            self.target_pressure,
        )

        # 更新 lattice_vectors
        cell.lattice_vectors = lattice_vectors.reshape((3, 3))

        # 更新 atom velocities
        for i, atom in enumerate(cell.atoms):
            atom.velocity = velocities[3 * i : 3 * i + 3]


# src/python/config.py

import yaml


class ConfigManager:
    """
    @class ConfigManager
    @brief 配置管理器，用于加载和获取配置参数。
    """

    def __init__(self, config_file):
        self.config = self.load_config(config_file)

    @staticmethod
    def load_config(config_file):
        with open(config_file, "r") as f:
            config = yaml.safe_load(f)
        return config

    def get(self, key, default=None):
        return self.config.get(key, default)


# src/python/deformation.py

import numpy as np


class Deformer:
    """
    @class Deformer
    @brief 施加微小应变以生成变形矩阵的类。
    """

    def __init__(self, delta):
        """
        @param delta 微小应变量
        """
        self.delta = delta

    def generate_deformation_matrices(self):
        """
        @brief 生成用于施加应变的变形矩阵列表。

        @return 变形矩阵列表
        """
        delta = self.delta
        F_list = []

        # 六个独立的应变分量
        strain_components = [
            np.array([[delta, 0, 0], [0, 0, 0], [0, 0, 0]]),  # ε_xx
            np.array([[0, 0, 0], [0, delta, 0], [0, 0, 0]]),  # ε_yy
            np.array([[0, 0, 0], [0, 0, 0], [0, 0, delta]]),  # ε_zz
            np.array([[0, delta / 2, 0], [delta / 2, 0, 0], [0, 0, 0]]),  # ε_xy
            np.array([[0, 0, delta / 2], [0, 0, 0], [delta / 2, 0, 0]]),  # ε_xz
            np.array([[0, 0, 0], [0, 0, delta / 2], [0, delta / 2, 0]]),  # ε_yz
        ]

        for epsilon in strain_components:
            F = np.identity(3) + epsilon
            F_list.append(F)

        return F_list

    def apply_deformation(self, cell, deformation_matrix):
        """
        @brief 对晶胞施加变形矩阵。

        @param cell Cell 实例
        @param deformation_matrix 变形矩阵
        """
        cell.apply_deformation(deformation_matrix)


# src/python/elasticity.py

import numpy as np
from .mechanics import StressCalculatorLJ, StrainCalculator
from .deformation import Deformer
from .optimizers import GradientDescentOptimizer, BFGSOptimizer
from .utils import TensorConverter


class ElasticConstantsSolver:
    """
    @class ElasticConstantsSolver
    @brief 计算弹性常数的求解器类。
    """

    def solve(self, strains, stresses):
        """
        @brief 通过最小二乘法求解弹性常数矩阵。

        @param strains 应变数据列表，形状为 (N, 6)
        @param stresses 应力数据列表，形状为 (N, 6)
        @return 弹性常数矩阵，形状为 (6, 6)
        """
        strains = np.array(strains)
        stresses = np.array(stresses)

        # 检查输入数据维度
        if strains.ndim != 2 or stresses.ndim != 2:
            raise ValueError("Strains and stresses must be 2D arrays.")
        if strains.shape[0] != stresses.shape[0]:
            raise ValueError("Number of strain and stress samples must be equal.")
        if strains.shape[1] != 6 or stresses.shape[1] != 6:
            raise ValueError("Strains and stresses must have 6 components each.")

        # 使用最小二乘法求解 C * strains.T = stresses.T
        # 这里 C 是一个 6x6 矩阵，每一行对应一个应力分量的线性组合
        C, residuals, rank, s = np.linalg.lstsq(strains, stresses, rcond=None)
        return C


class ElasticConstantsCalculator:
    """
    @class ElasticConstantsCalculator
    @brief 用于计算弹性常数的类。
    """

    def __init__(self, cell, potential, delta=1e-3, optimizer_type="BFGS"):
        """
        @param cell 晶胞对象
        @param potential 势能对象
        @param delta 变形大小
        @param optimizer_type 优化器类型，支持 'GD'（梯度下降）和 'BFGS'
        """
        self.cell = cell
        self.potential = potential
        self.delta = delta
        self.deformer = Deformer(delta)
        self.stress_calculator = StressCalculatorLJ()
        self.strain_calculator = StrainCalculator()
        if optimizer_type == "GD":
            self.optimizer = GradientDescentOptimizer(
                max_steps=1000, tol=1e-6, step_size=1e-3
            )
        elif optimizer_type == "BFGS":
            self.optimizer = BFGSOptimizer(tol=1e-6)
        else:
            raise ValueError("Unsupported optimizer type. Choose 'GD' or 'BFGS'.")

    def calculate_elastic_constants(self):
        """
        @brief 计算弹性常数矩阵。

        @return 弹性常数矩阵，形状为 (6, 6)。
        """
        F_list = self.deformer.generate_deformation_matrices()
        strains = []
        stresses = []

        for F in F_list:
            # 复制初始晶胞
            deformed_cell = self.cell.copy()
            # 施加变形
            deformed_cell.apply_deformation(F)
            # 优化结构
            self.optimizer.optimize(deformed_cell, self.potential)
            # 计算应力
            self.potential.calculate_forces(deformed_cell)
            stress_tensor = self.stress_calculator.compute_stress(
                deformed_cell, self.potential
            )
            # 计算应变
            strain_voigt = self.strain_calculator.compute_strain(F)
            # 转换应力张量为 Voigt 表示
            stress_voigt = TensorConverter.to_voigt(stress_tensor)
            strains.append(strain_voigt)
            stresses.append(stress_voigt)

        # 使用弹性常数求解器
        elastic_solver = ElasticConstantsSolver()
        C = elastic_solver.solve(strains, stresses)
        return C


# src/python/integrators.py

import numpy as np


class Integrator:
    """
    @class Integrator
    @brief 积分器基类
    """

    def integrate(self, cell, potential, dt):
        raise NotImplementedError


class VelocityVerletIntegrator(Integrator):
    """
    @class VelocityVerletIntegrator
    @brief 速度 Verlet 积分器的实现
    """

    def integrate(self, cell, potential, dt):
        atoms = cell.atoms
        # 第一半步：更新位置
        for atom in atoms:
            atom.position += atom.velocity * dt + 0.5 * atom.force / atom.mass * dt**2
            # 应用周期性边界条件
            atom.position = cell.apply_periodic_boundary(atom.position)
        # 保存旧的力
        forces_old = [atom.force.copy() for atom in atoms]
        # 计算新的力
        potential.calculate_forces(cell)
        # 第二半步：更新速度
        for atom, force_old in zip(atoms, forces_old):
            atom.velocity += 0.5 * (atom.force + force_old) / atom.mass * dt


class RK4Integrator(Integrator):
    """
    @class RK4Integrator
    @brief 四阶 Runge-Kutta 积分器的实现
    """

    def integrate(self, cell, potential, dt):
        def get_state():
            return np.concatenate(
                [atom.position for atom in cell.atoms]
                + [atom.velocity for atom in cell.atoms]
            )

        def set_state(state):
            num_atoms = len(cell.atoms)
            positions = state[: 3 * num_atoms].reshape((num_atoms, 3))
            velocities = state[3 * num_atoms :].reshape((num_atoms, 3))
            for i, atom in enumerate(cell.atoms):
                atom.position = positions[i]
                atom.velocity = velocities[i]

        def compute_derivatives(state):
            # Set the state
            num_atoms = len(cell.atoms)
            positions = state[: 3 * num_atoms].reshape((num_atoms, 3))
            velocities = state[3 * num_atoms :].reshape((num_atoms, 3))
            for i, atom in enumerate(cell.atoms):
                atom.position = positions[i]
                atom.velocity = velocities[i]
            # Compute forces
            potential.calculate_forces(cell)
            # Compute derivatives
            derivatives = np.zeros_like(state)
            for i, atom in enumerate(cell.atoms):
                derivatives[3 * i : 3 * i + 3] = atom.velocity
                derivatives[3 * num_atoms + 3 * i : 3 * num_atoms + 3 * i + 3] = (
                    atom.force / atom.mass
                )
            return derivatives

        state = get_state()
        k1 = compute_derivatives(state)
        k2 = compute_derivatives(state + 0.5 * dt * k1)
        k3 = compute_derivatives(state + 0.5 * dt * k2)
        k4 = compute_derivatives(state + dt * k3)
        new_state = state + (dt / 6.0) * (k1 + 2 * k2 + 2 * k3 + k4)
        set_state(new_state)


# src/python/md_simulator.py


class MDSimulator:
    """
    @class MDSimulator
    @brief 分子动力学模拟器
    """

    def __init__(self, cell, potential, integrator, thermostat=None, barostat=None):
        self.cell = cell
        self.potential = potential
        self.integrator = integrator
        self.thermostat = thermostat
        self.barostat = barostat  # 为 NPT 系综预留

    def run(self, steps, dt, data_collector=None):
        # 初始化力
        self.potential.calculate_forces(self.cell)
        for step in range(steps):
            self.integrator.integrate(self.cell, self.potential, dt)
            # 应用恒温器
            if self.thermostat is not None:
                self.thermostat.apply(self.cell.atoms, dt)
            # 应用压强控制器（如果有）
            if self.barostat is not None:
                self.barostat.apply(self.cell, dt)
            if data_collector is not None:
                data_collector.collect(self.cell)
            print(f"MD Step {step} completed.")


# src/python/mechanics.py

import numpy as np
from .utils import TensorConverter
from .interfaces.cpp_interface import CppInterface


class StressCalculator:
    """
    @class StressCalculator
    @brief 应力计算器基类。
    """

    def compute_stress(self, cell, potential):
        raise NotImplementedError


class StressCalculatorLJ(StressCalculator):
    """
    @class StressCalculatorLJ
    @brief 基于 Lennard-Jones 势的应力计算器。
    """

    def __init__(self):
        self.cpp_interface = CppInterface("stress_calculator")

    def compute_stress(self, cell, potential):
        volume = cell.calculate_volume()
        atoms = cell.atoms
        num_atoms = len(atoms)
        positions = np.array(
            [atom.position for atom in atoms], dtype=np.float64
        ).flatten()
        velocities = np.array(
            [atom.velocity for atom in atoms], dtype=np.float64
        ).flatten()
        forces = np.array([atom.force for atom in atoms], dtype=np.float64).flatten()
        masses = np.array([atom.mass for atom in atoms], dtype=np.float64)
        box_lengths = cell.get_box_lengths()

        # Initialize stress tensor array
        stress_tensor = np.zeros(9, dtype=np.float64)

        # 调用 C++ 实现的应力计算函数
        self.cpp_interface.compute_stress(
            num_atoms,
            positions,
            velocities,
            forces,
            masses,
            volume,
            box_lengths,
            stress_tensor,
        )

        # Reshape the stress tensor to 3x3 matrix
        stress_tensor = stress_tensor.reshape(3, 3)
        return stress_tensor


class StrainCalculator:
    """
    @class StrainCalculator
    @brief 应变计算器类。
    """

    def compute_strain(self, F):
        """
        @brief 计算应变张量。

        @param F 变形矩阵
        @return 应变向量，形状为 (6,)
        """
        strain_tensor = 0.5 * (np.dot(F.T, F) - np.identity(3))
        # 转换为 Voigt 表示
        strain_voigt = TensorConverter.to_voigt(strain_tensor)
        # 对剪切分量乘以 2
        strain_voigt[3:] *= 2
        return strain_voigt


# src/python/optimizers.py

import numpy as np
from scipy.optimize import minimize


class Optimizer:
    """
    @class Optimizer
    @brief 优化器基类
    """

    def optimize(self, cell, potential):
        raise NotImplementedError


class GradientDescentOptimizer(Optimizer):
    """
    @class GradientDescentOptimizer
    @brief 梯度下降优化器
    """

    def __init__(self, max_steps=1000, tol=1e-6, step_size=1e-3):
        self.max_steps = max_steps
        self.tol = tol
        self.step_size = step_size
        self.converged = False  # 添加收敛标志

    def optimize(self, cell, potential):
        atoms = cell.atoms
        potential.calculate_forces(cell)
        for step in range(self.max_steps):
            # 计算最大力
            max_force = max(np.linalg.norm(atom.force) for atom in atoms)
            # print(f"Step {step}: Max force = {max_force}")
            if max_force < self.tol:
                print(f"Converged after {step} steps")
                self.converged = True
                break
            # 更新 position
            for atom in atoms:
                displacement = self.step_size * atom.force
                atom.position += displacement
                # 应用周期性边界条件
                atom.position = cell.apply_periodic_boundary(atom.position)
            # 重新计算力
            potential.calculate_forces(cell)
        else:
            print("Optimization did not converge within the maximum number of steps.")
            self.converged = False


class BFGSOptimizer(Optimizer):
    """
    @class BFGSOptimizer
    @brief BFGS 优化器，使用 scipy.optimize.minimize 实现
    """

    def __init__(self, tol=1e-6):
        self.tol = tol
        self.converged = False  # 添加收敛标志

    def optimize(self, cell, potential):
        num_atoms = cell.num_atoms
        initial_positions = np.ascontiguousarray(
            cell.get_positions(), dtype=np.float64
        ).flatten()

        def objective(x):
            # Set positions
            for i, atom in enumerate(cell.atoms):
                atom.position = x[3 * i : 3 * i + 3]
            # Calculate potential energy
            energy = potential.calculate_energy(cell)
            return energy

        def gradient(x):
            # Set positions
            for i, atom in enumerate(cell.atoms):
                atom.position = x[3 * i : 3 * i + 3]
            # Calculate forces
            potential.calculate_forces(cell)
            # Gradient is -force
            grad = -np.array([atom.force for atom in cell.atoms]).flatten()
            return grad

        result = minimize(
            objective,
            initial_positions,
            method="BFGS",
            jac=gradient,
            options={"gtol": self.tol, "disp": True},
        )

        # Update positions after optimization
        optimized_positions = result.x
        for i, atom in enumerate(cell.atoms):
            atom.position = optimized_positions[3 * i : 3 * i + 3]
        # Recalculate forces
        potential.calculate_forces(cell)

        self.converged = result.success


# src/python/potentials.py

import numpy as np
from .interfaces.cpp_interface import CppInterface


class Potential:
    """
    @class Potential
    @brief 势能基类
    """

    def __init__(self, parameters, cutoff):
        self.parameters = parameters
        self.cutoff = cutoff

    def calculate_potential(self, cell):
        raise NotImplementedError

    def calculate_forces(self, cell):
        raise NotImplementedError

    def calculate_energy(self, cell):
        raise NotImplementedError


class LennardJonesPotential(Potential):
    """
    @class LennardJonesPotential
    @brief Lennard-Jones 势的实现
    """

    def __init__(self, epsilon, sigma, cutoff):
        parameters = {"epsilon": epsilon, "sigma": sigma}
        super().__init__(parameters, cutoff)
        self.epsilon = epsilon  # 单位 eV
        self.sigma = sigma  # 单位 Å
        self.cutoff = cutoff  # 单位 Å
        self.cpp_interface = CppInterface("lennard_jones")

    def calculate_forces(self, cell):
        num_atoms = cell.num_atoms
        positions = np.ascontiguousarray(
            cell.get_positions(), dtype=np.float64
        ).flatten()
        forces = np.zeros_like(positions, dtype=np.float64)
        box_lengths = np.ascontiguousarray(cell.get_box_lengths(), dtype=np.float64)

        self.cpp_interface.calculate_forces(
            num_atoms,
            positions,
            forces,
            self.epsilon,
            self.sigma,
            self.cutoff,
            box_lengths,
        )
        # 更新原子力
        forces = forces.reshape((num_atoms, 3))
        for i, atom in enumerate(cell.atoms):
            atom.force = forces[i]

    def calculate_energy(self, cell):
        num_atoms = cell.num_atoms
        positions = np.ascontiguousarray(
            cell.get_positions(), dtype=np.float64
        ).flatten()
        box_lengths = np.ascontiguousarray(cell.get_box_lengths(), dtype=np.float64)

        energy = self.cpp_interface.calculate_energy(
            num_atoms,
            positions,
            self.epsilon,
            self.sigma,
            self.cutoff,
            box_lengths,
        )
        return energy


# src/python/structure.py

import numpy as np


class Atom:
    """
    @class Atom
    @brief 原子类，包含原子的信息和属性。
    """

    def __init__(self, id, symbol, mass, position, velocity=None):
        self.id = id
        self.symbol = symbol
        self.mass = mass
        self.position = np.array(position, dtype=np.float64)
        self.velocity = (
            np.zeros(3, dtype=np.float64)
            if velocity is None
            else np.array(velocity, dtype=np.float64)
        )
        self.force = np.zeros(3, dtype=np.float64)

    def update_position(self, delta_r):
        self.position += delta_r

    def update_velocity(self, delta_v):
        self.velocity += delta_v


class Cell:
    """
    @class Cell
    @brief 晶胞类，包含晶格矢量和原子列表。
    """

    def __init__(self, lattice_vectors, atoms, pbc_enabled=True):
        self.lattice_vectors = np.array(lattice_vectors, dtype=np.float64)
        self.atoms = atoms  # 原子列表
        self.volume = self.calculate_volume()
        self.pbc_enabled = pbc_enabled

    def calculate_volume(self):
        return np.linalg.det(self.lattice_vectors)

    def get_box_lengths(self):
        """
        返回模拟盒子在 x、y、z 方向的长度。
        """
        box_lengths = np.linalg.norm(self.lattice_vectors, axis=1)
        return box_lengths

    def apply_deformation(self, deformation_matrix):
        """
        @brief 对晶胞和原子坐标施加变形矩阵。

        @param deformation_matrix 3x3 变形矩阵
        """
        # 更新晶格矢量
        self.lattice_vectors = np.dot(self.lattice_vectors, deformation_matrix.T)
        # 更新原子坐标
        for atom in self.atoms:
            atom.position = np.dot(deformation_matrix, atom.position)

    def apply_periodic_boundary(self, position):
        if self.pbc_enabled:
            # 转换到分数坐标
            fractional = np.linalg.solve(self.lattice_vectors.T, position)
            # 确保在 [0, 1) 范围内
            fractional = fractional % 1.0
            # 转换回笛卡尔坐标
            return np.dot(self.lattice_vectors.T, fractional)
        else:
            return position

    def copy(self):
        atoms_copy = [
            Atom(
                atom.id,
                atom.symbol,
                atom.mass,
                atom.position.copy(),
                atom.velocity.copy(),
            )
            for atom in self.atoms
        ]
        return Cell(self.lattice_vectors.copy(), atoms_copy, self.pbc_enabled)

    @property
    def num_atoms(self):
        """
        @property num_atoms
        @brief 返回原子数量。
        """
        return len(self.atoms)

    def get_positions(self):
        """
        @brief 获取所有原子的位置信息。

        @return numpy.ndarray, 形状为 (num_atoms, 3)
        """
        return np.array([atom.position for atom in self.atoms], dtype=np.float64)

    def get_velocities(self):
        """
        @brief 获取所有原子的速度信息。

        @return numpy.ndarray, 形状为 (num_atoms, 3)
        """
        return np.array([atom.velocity for atom in self.atoms], dtype=np.float64)

    def get_forces(self):
        """
        @brief 获取所有原子的力信息。

        @return numpy.ndarray, 形状为 (num_atoms, 3)
        """
        return np.array([atom.force for atom in self.atoms], dtype=np.float64)


# src/python/thermostats.py

import numpy as np
from .interfaces.cpp_interface import CppInterface


class Thermostat:
    """
    @class Thermostat
    @brief 恒温器基类
    """

    def apply(self, atoms, dt):
        raise NotImplementedError


class NoseHooverThermostat(Thermostat):
    """
    @class NoseHooverThermostat
    @brief Nose-Hoover 恒温器的实现
    """

    def __init__(self, target_temperature, time_constant):
        self.target_temperature = target_temperature
        self.time_constant = time_constant
        self.cpp_interface = CppInterface("nose_hoover")
        self.xi = np.array([0.0], dtype=np.float64)  # 初始热浴变量，改为 NumPy 数组
        self.Q = 10.0  # 热浴质量参数，可根据需要调整

    def apply(self, atoms, dt):
        num_atoms = len(atoms)
        masses = np.array([atom.mass for atom in atoms], dtype=np.float64)
        velocities = np.array(
            [atom.velocity for atom in atoms], dtype=np.float64
        ).flatten()
        forces = np.array([atom.force for atom in atoms], dtype=np.float64).flatten()

        # 调用 C++ Nose-Hoover 函数
        try:
            updated_xi = self.cpp_interface.nose_hoover(
                dt,
                num_atoms,
                masses,
                velocities,
                forces,
                self.xi,  # 传递 NumPy 数组
                self.Q,
                self.target_temperature,
            )
            self.xi[0] = updated_xi  # 更新 xi 的值
        except OSError as e:
            print(f"C++ Nose-Hoover 调用失败: {e}")
            raise

        # 更新原子的速度
        velocities = velocities.reshape((num_atoms, 3))
        for i, atom in enumerate(atoms):
            atom.velocity = velocities[i]


class NoseHooverChainThermostat(Thermostat):
    """
    @class NoseHooverChainThermostat
    @brief Nose-Hoover 链恒温器的实现
    """

    def __init__(self, target_temperature, time_constant, chain_length=2):
        self.target_temperature = target_temperature
        self.time_constant = time_constant
        self.chain_length = chain_length
        self.cpp_interface = CppInterface("nose_hoover_chain")

    def apply_thermostat(self, cell, dt, xi_chain, Q):
        num_atoms = len(cell.atoms)
        masses = np.array([atom.mass for atom in cell.atoms], dtype=np.float64)
        velocities = np.array(
            [atom.velocity for atom in cell.atoms], dtype=np.float64
        ).flatten()
        forces = np.array(
            [atom.force for atom in cell.atoms], dtype=np.float64
        ).flatten()

        self.cpp_interface.nose_hoover_chain(
            dt,
            num_atoms,
            masses,
            velocities,
            forces,
            xi_chain,
            Q,
            self.chain_length,
            self.target_temperature,
        )

        # 更新原子的速度
        velocities = velocities.reshape((num_atoms, 3))
        for i, atom in enumerate(cell.atoms):
            atom.velocity = velocities[i]


# src/python/utils.py

import numpy as np


class TensorConverter:
    """
    @class TensorConverter
    @brief 张量转换工具类。
    """

    @staticmethod
    def to_voigt(tensor):
        """
        @brief 将 3x3 张量转换为 Voigt 表示的 6 元素向量。

        @param tensor 3x3 numpy 数组
        @return 6 元素的 numpy 数组
        """
        voigt = np.array(
            [
                tensor[0, 0],
                tensor[1, 1],
                tensor[2, 2],
                tensor[1, 2],
                tensor[0, 2],
                tensor[0, 1],
            ]
        )
        return voigt

    @staticmethod
    def from_voigt(voigt):
        """
        @brief 将 Voigt 表示的 6 元素向量转换为 3x3 张量。

        @param voigt 6 元素的 numpy 数组
        @return 3x3 numpy 数组
        """
        tensor = np.array(
            [
                [voigt[0], voigt[5], voigt[4]],
                [voigt[5], voigt[1], voigt[3]],
                [voigt[4], voigt[3], voigt[2]],
            ]
        )
        return tensor


class DataCollector:
    """
    @class DataCollector
    @brief 数据收集工具类，用于收集模拟过程中的各种数据。
    """

    def __init__(self):
        self.data = []

    def collect(self, cell):
        """
        @brief 收集晶胞中的原子位置和速度。
        """
        positions = [atom.position.copy() for atom in cell.atoms]
        velocities = [atom.velocity.copy() for atom in cell.atoms]
        self.data.append({"positions": positions, "velocities": velocities})


# 添加单位转换常量
# 单位转换常量
# 1 amu = 104.3968445 eV·fs²/Å²
AMU_TO_EVFSA2 = 104.3968445


# src/python/visualization.py

"""
@file visualization.py
@brief 可视化晶胞结构和模拟结果的模块。
"""

import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
import numpy as np

from .structure import Cell


class Visualizer:
    """
    @class Visualizer
    @brief 可视化晶胞结构和模拟结果的类。
    """

    def __init__(self):
        pass

    def plot_cell_structure(self, cell_structure: Cell, show=True):
        """
        @brief 绘制晶体结构的 3D 图形。

        @param cell_structure Cell 实例。
        @param show 是否显示图形，默认为 True。
        @return 返回绘图对象 fig 和 ax。
        """
        fig = plt.figure()
        ax = fig.add_subplot(111, projection="3d")
        for atom in cell_structure.atoms:
            ax.scatter(*atom.position, label=atom.symbol)
        # 绘制晶格矢量
        origin = [0, 0, 0]
        lattice_vectors = cell_structure.lattice_vectors
        for i in range(3):
            vec = lattice_vectors[:, i]
            ax.quiver(*origin, *vec, color="r", arrow_length_ratio=0.1)
        ax.set_xlabel("X (Å)")
        ax.set_ylabel("Y (Å)")
        ax.set_zlabel("Z (Å)")
        plt.title("Crystal Structure")
        plt.legend()
        if show:
            plt.show()
        return fig, ax

    def plot_stress_strain(
        self, strain_data: np.ndarray, stress_data: np.ndarray, show=True
    ):
        """
        @brief 绘制应力-应变关系图。

        @param strain_data numpy.ndarray: 应变数据，形状为 (N, 6)。
        @param stress_data numpy.ndarray: 应力数据，形状为 (N, 6)。
        @param show 是否显示图形，默认为 True。
        @return 返回绘图对象 fig 和 ax。
        """
        fig, ax = plt.subplots(figsize=(10, 6))
        for i in range(6):
            ax.plot(strain_data[:, i], stress_data[:, i], label=f"Stress {i+1}")
        ax.set_xlabel("Strain")
        ax.set_ylabel("Stress (eV/Å³)")
        ax.set_title("Stress-Strain Relationship")
        ax.legend()
        ax.grid(True)
        plt.tight_layout()
        if show:
            plt.show()
        return fig, ax


# src/python/__init__.py

"""
@package ThermoElasticSim
@brief 初始化 ThermoElasticSim 项目。

该项目包含用于计算和模拟金属铝（Al）和金刚石（Diamond）在不同温度下弹性常数的模块。
"""

# 导入子模块
from .structure import Atom, Cell
from .potentials import Potential, LennardJonesPotential
from .integrators import Integrator, VelocityVerletIntegrator, RK4Integrator
from .thermostats import Thermostat, NoseHooverThermostat, NoseHooverChainThermostat
from .barostats import Barostat, ParrinelloRahmanHooverBarostat
from .mechanics import StressCalculator, StressCalculatorLJ, StrainCalculator
from .elasticity import ElasticConstantsSolver, ElasticConstantsCalculator
from .optimizers import Optimizer, GradientDescentOptimizer, BFGSOptimizer
from .deformation import Deformer
from .utils import TensorConverter, DataCollector
from .visualization import Visualizer
from .md_simulator import MDSimulator
from .config import ConfigManager
from .interfaces.cpp_interface import CppInterface


# src/python/interfaces/cpp_interface.py

import ctypes
import numpy as np
from numpy.ctypeslib import ndpointer
import os

# from ..utils import AMU_TO_EVFSA2  # 如果需要，确保导入单位转换常量


class CppInterface:
    """
    @class CppInterface
    @brief 用于调用 C++ 实现的函数的接口类。
    """

    def __init__(self, lib_name):
        """
        @param lib_name 库的名称，不包括前缀和扩展名
        """
        if os.name == "nt":  # Windows
            lib_extension = ".dll"
            lib_prefix = ""
        else:  # Unix/Linux
            lib_extension = ".so"
            lib_prefix = "lib"

        # 获取当前文件所在目录的绝对路径
        current_dir = os.path.dirname(os.path.abspath(__file__))
        # 获取项目根目录的绝对路径
        project_root = os.path.abspath(os.path.join(current_dir, "..", ".."))
        # 构建库文件的绝对路径
        lib_path = os.path.join(
            project_root, "lib", lib_prefix + lib_name + lib_extension
        )
        # 检查库文件是否存在
        if not os.path.exists(lib_path):
            raise FileNotFoundError(f"无法找到库文件: {lib_path}")

        self.lib = ctypes.CDLL(lib_path)

        # 配置不同库的函数签名
        if lib_name == "stress_calculator":
            self.lib.compute_stress.argtypes = [
                ctypes.c_int,  # num_atoms
                ndpointer(ctypes.c_double, flags="C_CONTIGUOUS"),  # positions
                ndpointer(ctypes.c_double, flags="C_CONTIGUOUS"),  # velocities
                ndpointer(ctypes.c_double, flags="C_CONTIGUOUS"),  # forces
                ndpointer(ctypes.c_double, flags="C_CONTIGUOUS"),  # masses (amu)
                ctypes.c_double,  # volume
                ndpointer(ctypes.c_double, flags="C_CONTIGUOUS"),  # box_lengths
                ndpointer(
                    ctypes.c_double, flags="C_CONTIGUOUS"
                ),  # stress_tensor (output)
            ]
            self.lib.compute_stress.restype = None

        elif lib_name == "lennard_jones":
            self.lib.calculate_forces.argtypes = [
                ctypes.c_int,  # num_atoms
                ndpointer(ctypes.c_double, flags="C_CONTIGUOUS"),  # positions
                ndpointer(ctypes.c_double, flags="C_CONTIGUOUS"),  # forces
                ctypes.c_double,  # epsilon
                ctypes.c_double,  # sigma
                ctypes.c_double,  # cutoff
                ndpointer(ctypes.c_double, flags="C_CONTIGUOUS"),  # box_lengths
            ]
            self.lib.calculate_forces.restype = None

            self.lib.calculate_energy.argtypes = [
                ctypes.c_int,  # num_atoms
                ndpointer(ctypes.c_double, flags="C_CONTIGUOUS"),  # positions
                ctypes.c_double,  # epsilon
                ctypes.c_double,  # sigma
                ctypes.c_double,  # cutoff
                ndpointer(ctypes.c_double, flags="C_CONTIGUOUS"),  # box_lengths
            ]
            self.lib.calculate_energy.restype = ctypes.c_double

        elif lib_name == "nose_hoover":
            self.lib.nose_hoover.argtypes = [
                ctypes.c_double,  # dt
                ctypes.c_int,  # num_atoms
                ndpointer(ctypes.c_double, flags="C_CONTIGUOUS"),  # masses
                ndpointer(ctypes.c_double, flags="C_CONTIGUOUS"),  # velocities
                ndpointer(ctypes.c_double, flags="C_CONTIGUOUS"),  # forces
                ctypes.POINTER(ctypes.c_double),  # xi (input/output)
                ctypes.c_double,  # Q
                ctypes.c_double,  # target_temperature
            ]
            self.lib.nose_hoover.restype = None

        elif lib_name == "nose_hoover_chain":
            self.lib.nose_hoover_chain.argtypes = [
                ctypes.c_double,  # dt
                ctypes.c_int,  # num_atoms
                ndpointer(ctypes.c_double, flags="C_CONTIGUOUS"),  # masses
                ndpointer(ctypes.c_double, flags="C_CONTIGUOUS"),  # velocities
                ndpointer(ctypes.c_double, flags="C_CONTIGUOUS"),  # forces
                ndpointer(ctypes.c_double, flags="C_CONTIGUOUS"),  # xi_chain
                ndpointer(ctypes.c_double, flags="C_CONTIGUOUS"),  # Q
                ctypes.c_int,  # chain_length
                ctypes.c_double,  # target_temperature
            ]
            self.lib.nose_hoover_chain.restype = None

        else:
            raise ValueError(f"未知的库名称: {lib_name}")

    def compute_stress(
        self,
        num_atoms,
        positions,
        velocities,
        forces,
        masses,
        volume,
        box_lengths,
        stress_tensor,
    ):
        """
        计算应力张量。
        """
        self.lib.compute_stress(
            num_atoms,
            positions,
            velocities,
            forces,
            masses,
            volume,
            box_lengths,
            stress_tensor,
        )

    def calculate_energy(
        self,
        num_atoms,
        positions,
        epsilon,
        sigma,
        cutoff,
        box_lengths,
    ):
        """
        计算系统的总 Lennard-Jones 势能。
        """
        energy = self.lib.calculate_energy(
            num_atoms,
            positions,
            epsilon,
            sigma,
            cutoff,
            box_lengths,
        )
        return energy

    def calculate_forces(
        self,
        num_atoms,
        positions,
        forces,
        epsilon,
        sigma,
        cutoff,
        box_lengths,
    ):
        """
        计算系统的力。
        """
        self.lib.calculate_forces(
            num_atoms,
            positions,
            forces,
            epsilon,
            sigma,
            cutoff,
            box_lengths,
        )

    def nose_hoover(
        self,
        dt,
        num_atoms,
        masses,
        velocities,
        forces,
        xi_array,  # 现在接受一个numpy数组
        Q,
        target_temperature,
    ):
        """
        实现 Nose-Hoover 恒温器算法
        """
        if not isinstance(xi_array, np.ndarray) or xi_array.size != 1:
            raise ValueError("xi must be a numpy array with one element.")
        self.lib.nose_hoover(
            dt,
            num_atoms,
            masses,
            velocities,
            forces,
            xi_array.ctypes.data_as(ctypes.POINTER(ctypes.c_double)),
            Q,
            target_temperature,
        )
        return xi_array[0]  # 返回更新后的 xi 值

    def nose_hoover_chain(
        self,
        dt,
        num_atoms,
        masses,
        velocities,
        forces,
        xi_chain,
        Q,
        chain_length,
        target_temperature,
    ):
        """
        实现 Nose-Hoover 链恒温器算法
        """
        self.lib.nose_hoover_chain(
            dt,
            num_atoms,
            masses,
            velocities,
            forces,
            xi_chain,
            Q,
            chain_length,
            target_temperature,
        )


# src/python/interfaces/__init__.py


tests/
    test_cpp_interface.py
    test_deformation.py
    test_elasticity.py
    test_md.py
    test_mechanics.py
    test_nose_hoover.py
    test_optimizers.py
    test_potentials.py
    test_structure.py
    test_utils.py
    test_visualization.py
# tests/test_cpp_interface.py

import pytest
import numpy as np
from python.interfaces.cpp_interface import CppInterface
from python.structure import Atom, Cell
from python.potentials import LennardJonesPotential


@pytest.fixture
def lj_interface():
    return CppInterface("lennard_jones")


@pytest.fixture
def stress_calculator_interface():
    return CppInterface("stress_calculator")


@pytest.fixture
def nose_hoover_interface():
    return CppInterface("nose_hoover")


@pytest.fixture
def nose_hoover_chain_interface():
    return CppInterface("nose_hoover_chain")


def test_calculate_energy(lj_interface):
    """
    测试 C++ 实现的 Lennard-Jones 势能计算函数
    """
    num_atoms = 2
    positions = np.array([0.0, 0.0, 0.0, 2.55, 0.0, 0.0], dtype=np.float64)
    box_lengths = np.array([5.1, 5.1, 5.1], dtype=np.float64)

    energy = lj_interface.calculate_energy(
        num_atoms,
        positions,
        epsilon=0.0103,
        sigma=2.55,
        cutoff=2.5 * 2.55,
        box_lengths=box_lengths,
    )

    # 检查能量是否为浮点数
    assert isinstance(energy, float), "Energy is not a float."
    # 根据 r = sigma，能量应为 -shift，即正值
    expected_shift = (
        4.0 * 0.0103 * ((2.55 / (2.5 * 2.55)) ** 12 - (2.55 / (2.5 * 2.55)) ** 6)
    )
    expected_energy = (
        -expected_shift
    )  # 因为 U(r) = 4ε[(σ/r)^12 - (σ/r)^6] - shift, 在 r=σ, U(r)=-shift
    assert np.isclose(
        energy, expected_energy, atol=1e-6
    ), f"Energy {energy} is not close to expected {expected_energy}."


def test_calculate_forces(lj_interface):
    """
    测试 C++ 实现的 Lennard-Jones 势能计算力函数
    """
    num_atoms = 2
    positions = np.array([0.0, 0.0, 0.0, 2.55, 0.0, 0.0], dtype=np.float64)
    box_lengths = np.array([5.1, 5.1, 5.1], dtype=np.float64)
    forces = np.zeros_like(positions, dtype=np.float64)

    lj_interface.calculate_forces(
        num_atoms,
        positions,
        forces,
        epsilon=0.0103,
        sigma=2.55,
        cutoff=2.5 * 2.55,
        box_lengths=box_lengths,
    )

    # 重新形状为 (num_atoms, 3)
    forces = forces.reshape((num_atoms, 3))

    # 计算期望的力
    epsilon = 0.0103
    expected_force_scalar = (
        48.0
        * epsilon
        * (pow(2.55 / (2.5 * 2.55), 12) - 0.5 * pow(2.55 / (2.5 * 2.55), 6))
    )
    expected_force = (
        48.0 * epsilon * (pow(2.55 / 2.55, 12) - 0.5 * pow(2.55 / 2.55, 6)) / 2.55
    )  # At r = sigma

    # 理论上，在 r = sigma，力 = 24 * epsilon
    expected_force_theory = 24.0 * epsilon  # 0.2472 eV/Å

    # 检查力是否接近理论值
    np.testing.assert_allclose(forces[0, 0], expected_force_theory, atol=1e-6)
    np.testing.assert_allclose(forces[1, 0], -expected_force_theory, atol=1e-6)
    # 其他方向的力应为零
    np.testing.assert_allclose(forces[:, 1:], 0.0, atol=1e-6)


def test_nose_hoover(nose_hoover_interface):
    """
    测试 C++ 实现的 Nose-Hoover 恒温器函数
    """
    dt = 1.0
    num_atoms = 2
    masses = np.array([1.0, 1.0], dtype=np.float64)
    velocities = np.array([0.0, 0.0, 0.0, 1.0, 0.0, 0.0], dtype=np.float64)
    forces = np.array([0.0, 0.0, 0.0, -1.0, 0.0, 0.0], dtype=np.float64)
    xi = 0.0
    Q = 10.0
    target_temperature = 300.0

    # C++ 函数 expects a pointer to xi, so create a mutable array
    xi_array = np.array([xi], dtype=np.float64)

    updated_xi = nose_hoover_interface.nose_hoover(
        dt,
        num_atoms,
        masses,
        velocities,
        forces,
        xi_array,  # 传递数组
        Q,
        target_temperature,
    )

    # Check that xi has been updated
    assert isinstance(updated_xi, float), "xi is not a float."
    # 根据实现，xi 应该有变化
    assert (
        updated_xi != xi
    ), f"xi was not updated. Original: {xi}, Updated: {updated_xi}"


def test_nose_hoover_chain(nose_hoover_chain_interface):
    """
    测试 C++ 实现的 Nose-Hoover 链恒温器函数
    """
    dt = 1.0
    num_atoms = 2
    masses = np.array([1.0, 1.0], dtype=np.float64)
    velocities = np.array([0.0, 0.0, 0.0, 1.0, 0.0, 0.0], dtype=np.float64)
    forces = np.array([0.0, 0.0, 0.0, -1.0, 0.0, 0.0], dtype=np.float64)
    xi_chain = np.zeros(2, dtype=np.float64)  # 假设链长度为 2
    Q = np.array([10.0, 10.0], dtype=np.float64)
    chain_length = 2
    target_temperature = 300.0

    nose_hoover_chain_interface.nose_hoover_chain(
        dt,
        num_atoms,
        masses,
        velocities,
        forces,
        xi_chain,
        Q,
        chain_length,
        target_temperature,
    )

    # Check that xi_chain has been updated
    assert isinstance(xi_chain, np.ndarray), "xi_chain is not a numpy array."
    assert xi_chain.shape == (chain_length,), "xi_chain shape mismatch."
    # 检查是否有变化
    assert not np.all(xi_chain == 0.0), "xi_chain was not updated."


# tests/test_deformation.py

import pytest
import numpy as np
from python.deformation import Deformer


def test_generate_deformation_matrices():
    """
    @brief 测试生成变形矩阵的方法
    """
    delta = 0.01  # 1% 的应变
    deformer = Deformer(delta)
    deformation_matrices = deformer.generate_deformation_matrices()

    # 检查是否生成了 6 个变形矩阵
    assert len(deformation_matrices) == 6

    # 检查每个变形矩阵的正确性
    for i, F in enumerate(deformation_matrices):
        # 检查矩阵是否为 3x3
        assert F.shape == (3, 3)

        # 检查矩阵是否为单位矩阵加上微小变形
        expected_F = np.identity(3)
        if i < 3:
            expected_F[i, i] += delta
        else:
            shear_indices = [(0, 1), (0, 2), (1, 2)]
            idx = i - 3
            i_shear, j_shear = shear_indices[idx]
            expected_F[i_shear, j_shear] += delta / 2
            expected_F[j_shear, i_shear] += delta / 2
        np.testing.assert_array_almost_equal(F, expected_F, decimal=6)


def test_apply_deformation(cell_fixture):
    """
    @brief 测试对晶胞施加变形矩阵的方法
    """
    delta = 0.01
    deformer = Deformer(delta)
    deformation_matrix = deformer.generate_deformation_matrices()[0]  # ε_xx
    original_lattice = cell_fixture.lattice_vectors.copy()
    original_positions = [atom.position.copy() for atom in cell_fixture.atoms]

    deformer.apply_deformation(cell_fixture, deformation_matrix)

    # 检查晶格矢量是否正确更新
    expected_lattice = np.dot(original_lattice, deformation_matrix.T)
    np.testing.assert_array_almost_equal(
        cell_fixture.lattice_vectors, expected_lattice, decimal=6
    )

    # 检查原子位置是否正确更新
    for original_pos, atom in zip(original_positions, cell_fixture.atoms):
        expected_pos = np.dot(deformation_matrix, original_pos)
        np.testing.assert_array_almost_equal(atom.position, expected_pos, decimal=6)


@pytest.fixture
def cell_fixture():
    """
    @fixture 创建一个简单的晶胞，用于测试
    """
    from python.structure import Atom, Cell

    mass = 26.9815  # amu
    position = np.array([0.0, 0.0, 0.0])
    atom = Atom(id=0, symbol="Al", mass=mass, position=position)
    lattice_vectors = np.eye(3) * 4.05  # Å
    cell = Cell(lattice_vectors, [atom], pbc_enabled=True)
    return cell


# tests/test_elasticity.py

import numpy as np
from python.structure import Atom, Cell
from python.potentials import LennardJonesPotential
from python.elasticity import ElasticConstantsCalculator


def test_elastic_constants_calculator():
    """
    @brief 测试 ElasticConstantsCalculator 计算弹性常数
    """
    # 创建一个简单的晶胞，例如立方晶格
    atoms = [
        Atom(id=0, mass=26.9815, position=np.array([0.0, 0.0, 0.0]), symbol="Al"),
        Atom(id=1, mass=26.9815, position=np.array([2.55, 2.55, 2.55]), symbol="Al"),
    ]
    lattice_vectors = np.eye(3) * 5.1  # 示例晶格向量
    cell = Cell(lattice_vectors=lattice_vectors, atoms=atoms, pbc_enabled=True)

    # 定义 Lennard-Jones 势
    epsilon = 0.0103  # eV
    sigma = 2.55  # Å
    cutoff = 2.5 * sigma  # Å
    lj_potential = LennardJonesPotential(epsilon=epsilon, sigma=sigma, cutoff=cutoff)

    # 创建 ElasticConstantsCalculator 实例
    elastic_calculator = ElasticConstantsCalculator(
        cell=cell, potential=lj_potential, delta=1e-3, optimizer_type="BFGS"
    )

    # 计算弹性常数
    C = elastic_calculator.calculate_elastic_constants()

    # 将弹性常数矩阵转换为 GPa
    # 假设单位转换正确，此处示例可能需要根据实际单位调整
    C_in_GPa = C * 160.21766208  # eV/Å^3 转 GPa

    # 预期弹性常数矩阵（根据你的测试数据调整）
    expected_C = np.array(
        [
            [69.0, 0.0, 0.0, 0.0, 0.0, 0.0],
            [0.0, 69.0, 0.0, 0.0, 0.0, 0.0],
            [0.0, 0.0, 69.0, 0.0, 0.0, 0.0],
            [0.0, 0.0, 0.0, 23.0, 0.0, 0.0],
            [0.0, 0.0, 0.0, 0.0, 23.0, 0.0],
            [0.0, 0.0, 0.0, 0.0, 0.0, 23.0],
        ]
    )  # 示例值，需根据实际情况调整

    # 检查弹性常数矩阵是否接近预期值
    np.testing.assert_array_almost_equal(C_in_GPa, expected_C, decimal=1)


# tests/test_md.py

import pytest
import numpy as np

from python.md_simulator import MDSimulator
from python.integrators import VelocityVerletIntegrator
from python.thermostats import NoseHooverThermostat

from python.structure import Atom, Cell
from python.potentials import LennardJonesPotential


@pytest.fixture
def simple_cell(pbc_enabled=True):
    """
    @fixture 创建一个简单的晶胞，包含两个原子。
    """
    lattice_vectors = np.eye(3) * 6.0 if pbc_enabled else np.eye(3) * 1e8  # Å
    mass = 26.9815  # amu (Aluminum)
    position1 = np.array([0.0, 0.0, 0.0])
    position2 = np.array([2.55, 0.0, 0.0])  # 与原子1相距 σ = 2.55 Å
    atom1 = Atom(id=0, symbol="Al", mass=mass, position=position1)
    atom2 = Atom(id=1, symbol="Al", mass=mass, position=position2)
    cell = Cell(
        lattice_vectors=lattice_vectors, atoms=[atom1, atom2], pbc_enabled=pbc_enabled
    )
    return cell


@pytest.fixture
def lj_potential():
    """
    @fixture 定义 Lennard-Jones 势。
    """
    epsilon = 0.0103  # eV
    sigma = 2.55  # Å
    cutoff = 2.5 * sigma
    return LennardJonesPotential(epsilon=epsilon, sigma=sigma, cutoff=cutoff)


@pytest.fixture
def integrator():
    """
    @fixture 定义积分器。
    """
    return VelocityVerletIntegrator()


@pytest.fixture
def thermostat():
    """
    @fixture 定义恒温器。
    """
    return NoseHooverThermostat(target_temperature=300, time_constant=100)


def test_md_simulation(simple_cell, lj_potential, integrator):
    """
    @brief 测试分子动力学模拟器的运行。
    """
    md_simulator = MDSimulator(
        cell=simple_cell,
        potential=lj_potential,
        integrator=integrator,
        thermostat=None,  # 先不加恒温器。
    )
    md_simulator.run(steps=10, dt=1.0)  # dt 单位为 fs

    # 检查原子的位置和速度是否发生变化
    atom1 = simple_cell.atoms[0]
    atom2 = simple_cell.atoms[1]
    assert not np.allclose(atom1.position, [0.0, 0.0, 0.0]), "原子1的位置未发生变化。"
    assert not np.allclose(atom2.position, [2.55, 0.0, 0.0]), "原子2的位置未发生变化。"
    assert not np.allclose(atom1.velocity, [0.0, 0.0, 0.0]), "原子1的速度未发生变化。"
    assert not np.allclose(atom2.velocity, [0.0, 0.0, 0.0]), "原子2的速度未发生变化。"


def test_md_simulation_with_thermostat(
    simple_cell, lj_potential, integrator, thermostat
):
    """
    @brief 测试分子动力学模拟器的运行，带恒温器。
    """
    md_simulator = MDSimulator(
        cell=simple_cell,
        potential=lj_potential,
        integrator=integrator,
        thermostat=thermostat,
    )
    md_simulator.run(steps=10, dt=1.0)  # dt 单位为 fs

    # 检查原子的位置和速度是否发生变化
    atom1 = simple_cell.atoms[0]
    atom2 = simple_cell.atoms[1]
    assert not np.allclose(atom1.position, [0.0, 0.0, 0.0]), "原子1的位置未发生变化。"
    assert not np.allclose(atom2.position, [2.55, 0.0, 0.0]), "原子2的位置未发生变化。"
    assert not np.allclose(atom1.velocity, [0.0, 0.0, 0.0]), "原子1的速度未发生变化。"
    assert not np.allclose(atom2.velocity, [0.0, 0.0, 0.0]), "原子2的速度未发生变化。"

    # 检查 xi 是否被更新
    assert thermostat.xi[0] != 0.0, "xi 未被更新。"


# tests/test_mechanics.py

import pytest
import numpy as np
from python.structure import Atom, Cell
from python.potentials import LennardJonesPotential
from python.elasticity import ElasticConstantsSolver  # 确保导入
from python.mechanics import StressCalculatorLJ


@pytest.fixture
def single_atom_cell():
    atoms = [Atom(id=0, mass=26.9815, position=np.array([0.0, 0.0, 0.0]), symbol="Al")]
    lattice_vectors = np.eye(3) * 5.1
    return Cell(lattice_vectors=lattice_vectors, atoms=atoms, pbc_enabled=True)


@pytest.fixture
def lj_potential_single():
    return LennardJonesPotential(epsilon=0.0103, sigma=2.55, cutoff=2.5 * 2.55)


def test_stress_calculation(single_atom_cell, lj_potential_single):
    """
    @brief 测试应力计算器的功能。
    """
    stress_calculator = StressCalculatorLJ()
    # 计算力
    lj_potential_single.calculate_forces(single_atom_cell)
    # 计算应力
    stress_tensor = stress_calculator.compute_stress(
        single_atom_cell, lj_potential_single
    )
    # 由于只有一个原子，理论上应力张量应为零
    expected_stress = np.zeros((3, 3))
    np.testing.assert_array_almost_equal(stress_tensor, expected_stress, decimal=6)


def test_elastic_constants_solver():
    """
    @brief 测试弹性常数求解器的功能。
    """
    strains = [
        np.array([0.0, 0.0, 0.0, 0.0, 0.0, 0.0]),
        np.array([0.01, 0.0, 0.0, 0.0, 0.0, 0.0]),
        np.array([0.0, 0.01, 0.0, 0.0, 0.0, 0.0]),
        np.array([0.0, 0.0, 0.01, 0.0, 0.0, 0.0]),
        np.array([0.0, 0.0, 0.0, 0.01, 0.0, 0.0]),
        np.array([0.0, 0.0, 0.0, 0.0, 0.01, 0.0]),
        np.array([0.0, 0.0, 0.0, 0.0, 0.0, 0.01]),
    ]
    stresses = [
        np.array([0.0, 0.0, 0.0, 0.0, 0.0, 0.0]),
        np.array([69.0, 0.0, 0.0, 0.0, 0.0, 0.0]),
        np.array([0.0, 69.0, 0.0, 0.0, 0.0, 0.0]),
        np.array([0.0, 0.0, 69.0, 0.0, 0.0, 0.0]),
        np.array([0.0, 0.0, 0.0, 23.0, 0.0, 0.0]),
        np.array([0.0, 0.0, 0.0, 0.0, 23.0, 0.0]),
        np.array([0.0, 0.0, 0.0, 0.0, 0.0, 23.0]),
    ]
    solver = ElasticConstantsSolver()
    C = solver.solve(strains, stresses)
    # 检查 C 是否为 6x6 矩阵
    assert C.shape == (6, 6), "Elastic constants matrix shape mismatch."
    # 预期弹性常数矩阵（示例值）
    expected_C = np.array(
        [
            [69.0, 0.0, 0.0, 0.0, 0.0, 0.0],
            [0.0, 69.0, 0.0, 0.0, 0.0, 0.0],
            [0.0, 0.0, 69.0, 0.0, 0.0, 0.0],
            [0.0, 0.0, 0.0, 23.0, 0.0, 0.0],
            [0.0, 0.0, 0.0, 0.0, 23.0, 0.0],
            [0.0, 0.0, 0.0, 0.0, 0.0, 23.0],
        ]
    )
    # 检查弹性常数矩阵是否接近预期值
    np.testing.assert_array_almost_equal(C, expected_C, decimal=2)


def test_force_direction():
    """
    @brief 验证力的方向是否为负梯度方向。
    """
    # 创建一个简单的晶胞
    atoms = [
        Atom(id=0, mass=26.9815, position=np.array([0.0, 0.0, 0.0]), symbol="Al"),
        Atom(id=1, mass=26.9815, position=np.array([2.55, 2.55, 2.55]), symbol="Al"),
    ]
    lattice_vectors = np.eye(3) * 5.1  # 示例晶格向量
    cell = Cell(lattice_vectors=lattice_vectors, atoms=atoms, pbc_enabled=True)

    # 定义 Lennard-Jones 势
    epsilon = 0.0103  # eV
    sigma = 2.55  # Å
    cutoff = 2.5 * sigma  # Å
    lj_potential = LennardJonesPotential(epsilon=epsilon, sigma=sigma, cutoff=cutoff)

    # 计算初始能量和力
    initial_energy = lj_potential.calculate_energy(cell)
    initial_force = cell.get_forces()

    # 计算能量的数值梯度近似
    delta = 1e-5
    expected_force = np.zeros_like(initial_force)
    for i in range(cell.num_atoms):
        for dim in range(3):
            # 正向微小位移
            displaced = cell.copy()
            displaced.atoms[i].position[dim] += delta
            energy_displaced = lj_potential.calculate_energy(displaced)
            # 负梯度近似
            expected_force[i, dim] = -(energy_displaced - initial_energy) / delta

    # 检查力方向是否接近负梯度方向
    np.testing.assert_array_almost_equal(initial_force, expected_force, decimal=3)


# tests/test_nose_hoover.py

import pytest
import numpy as np
from python.thermostats import NoseHooverThermostat
from python.structure import Atom, Cell
from python.utils import AMU_TO_EVFSA2


@pytest.fixture
def nose_hoover_thermostat():
    """
    @fixture 定义 Nose-Hoover 恒温器。
    """
    return NoseHooverThermostat(target_temperature=300, time_constant=100)


def test_nose_hoover_apply(nose_hoover_thermostat):
    """
    @brief 测试 Nose-Hoover 恒温器的 apply 方法。
    """
    # 创建一个简单的晶胞，包含两个原子
    atoms = [
        Atom(
            id=0,
            symbol="Al",
            mass=26.9815 * AMU_TO_EVFSA2,  # 转换为 eV/fs^2
            position=np.array([0.0, 0.0, 0.0]),
            velocity=np.array([1.0, 0.0, 0.0]),
        ),
        Atom(
            id=1,
            symbol="Al",
            mass=26.9815 * AMU_TO_EVFSA2,  # 转换为 eV/fs^2
            position=np.array([2.55, 0.0, 0.0]),
            velocity=np.array([-1.0, 0.0, 0.0]),
        ),
    ]

    # 初始化力
    for atom in atoms:
        atom.force = np.array([0.0, 0.0, 0.0])

    # 应用恒温器
    dt = 1.0  # fs
    nose_hoover_thermostat.apply(atoms, dt)

    # 检查 xi 是否被更新
    assert nose_hoover_thermostat.xi[0] != 0.0, "xi 未被更新。"

    # 检查速度是否被更新（根据恒温器的实现，速度应被缩放）
    # 由于初始力为零，速度应只受 xi 影响，具体变化取决于 C++ 实现
    # 这里只检查速度是否发生变化
    assert not np.allclose(atoms[0].velocity, [1.0, 0.0, 0.0]), "原子1的速度未被更新。"
    assert not np.allclose(atoms[1].velocity, [-1.0, 0.0, 0.0]), "原子2的速度未被更新。"


# tests/test_optimizers.py

import pytest
import numpy as np
from python.structure import Atom, Cell
from python.potentials import LennardJonesPotential
from python.optimizers import GradientDescentOptimizer, BFGSOptimizer
from python.elasticity import ElasticConstantsSolver  # 确保导入


@pytest.fixture
def lj_potential_optim():
    return LennardJonesPotential(epsilon=0.0103, sigma=2.55, cutoff=2.5 * 2.55)


def test_gradient_descent_optimizer(lj_potential_optim):
    """
    @brief 测试梯度下降优化器。
    """
    optimizer = GradientDescentOptimizer(max_steps=100, tol=1e-5, step_size=1e-3)
    # 创建一个简单的晶胞
    atoms = [
        Atom(id=0, mass=26.9815, position=np.array([0.0, 0.0, 0.0]), symbol="Al"),
        Atom(id=1, mass=26.9815, position=np.array([2.55, 0.0, 0.0]), symbol="Al"),
    ]
    lattice_vectors = np.eye(3) * 5.1
    cell = Cell(lattice_vectors=lattice_vectors, atoms=atoms, pbc_enabled=True)
    optimizer.optimize(cell, lj_potential_optim)
    # 检查优化是否收敛
    assert optimizer.converged, "梯度下降优化器未收敛"


def test_bfgs_optimizer(lj_potential_optim):
    """
    @brief 测试 BFGS 优化器。
    """
    optimizer = BFGSOptimizer(tol=1e-5)
    # 创建一个简单的晶胞
    atoms = [
        Atom(id=0, mass=26.9815, position=np.array([0.0, 0.0, 0.0]), symbol="Al"),
        Atom(id=1, mass=26.9815, position=np.array([2.55, 0.0, 0.0]), symbol="Al"),
    ]
    lattice_vectors = np.eye(3) * 5.1
    cell = Cell(lattice_vectors=lattice_vectors, atoms=atoms, pbc_enabled=True)
    optimizer.optimize(cell, lj_potential_optim)
    # 检查优化是否收敛
    assert optimizer.converged, "BFGS 优化器未收敛"


def test_optimizer_convergence():
    """
    @brief 测试优化器的收敛性。
    """
    optimizer = GradientDescentOptimizer(max_steps=1000, tol=1e-6, step_size=1e-3)
    # 创建一个简单的晶胞
    atoms = [
        Atom(id=0, mass=26.9815, position=np.array([0.0, 0.0, 0.0]), symbol="Al"),
        Atom(id=1, mass=26.9815, position=np.array([2.55, 0.0, 0.0]), symbol="Al"),
    ]
    lattice_vectors = np.eye(3) * 5.1
    cell = Cell(lattice_vectors=lattice_vectors, atoms=atoms, pbc_enabled=True)
    lj_potential = LennardJonesPotential(epsilon=0.0103, sigma=2.55, cutoff=2.5 * 2.55)
    optimizer.optimize(cell, lj_potential)
    # 检查优化是否收敛
    assert optimizer.converged, "优化器未能收敛"


# tests/test_potentials.py

import pytest
import numpy as np
from python.potentials import LennardJonesPotential
from python.structure import Atom, Cell


@pytest.fixture
def lj_potential():
    """
    @fixture 定义 Lennard-Jones 势
    """
    epsilon = 0.0103  # eV
    sigma = 2.55  # Å
    cutoff = 2.5 * sigma
    return LennardJonesPotential(epsilon=epsilon, sigma=sigma, cutoff=cutoff)


@pytest.fixture
def two_atom_cell():
    """
    @fixture 创建一个简单的系统，包含两个原子
    """
    lattice_vectors = np.eye(3) * 4.05  # Å
    mass = 26.9815  # amu
    position1 = np.array([0.0, 0.0, 0.0])
    position2 = np.array([2.025, 0.0, 0.0])  # 2.025 Å
    atom1 = Atom(id=0, symbol="Al", mass=mass, position=position1)
    atom2 = Atom(id=1, symbol="Al", mass=mass, position=position2)
    cell = Cell(lattice_vectors, [atom1, atom2], pbc_enabled=True)
    return cell


def test_force_calculation(lj_potential, two_atom_cell):
    """
    @brief 测试 Lennard-Jones 势的力计算功能
    """
    lj_potential.calculate_forces(two_atom_cell)
    # 检查力是否非零且相反
    force1 = two_atom_cell.atoms[0].force
    force2 = two_atom_cell.atoms[1].force
    np.testing.assert_array_almost_equal(force1, -force2, decimal=10)
    assert not np.allclose(force1, 0)


def test_energy_calculation(lj_potential, two_atom_cell):
    """
    @brief 测试 Lennard-Jones 势的能量计算功能
    """
    energy = lj_potential.calculate_energy(two_atom_cell)
    # 由于只有两个原子且对称位置，能量应等于 4 * epsilon * ( (sigma/r)^12 - (sigma/r)^6 )
    r = np.linalg.norm(
        two_atom_cell.atoms[1].position - two_atom_cell.atoms[0].position
    )
    expected_energy = (
        4.0
        * lj_potential.epsilon
        * ((lj_potential.sigma / r) ** 12 - (lj_potential.sigma / r) ** 6)
    )
    # 由于能量计算可能包括截断修正，此处仅为基本验证
    np.testing.assert_almost_equal(energy, expected_energy, decimal=3)


# tests/test_structure.py

import pytest
import numpy as np
from python.structure import Atom, Cell


@pytest.fixture
def atom():
    """
    @fixture 创建一个原子实例
    """
    position = np.array([0.0, 0.0, 0.0])
    mass = 26.9815  # amu
    return Atom(id=0, symbol="Al", mass=mass, position=position)


@pytest.fixture
def cell(atom):
    """
    @fixture 创建一个晶胞实例，包含一个原子
    """
    lattice_vectors = np.eye(3) * 4.05  # Å
    return Cell(lattice_vectors, [atom], pbc_enabled=True)


def test_atom_creation(atom):
    """
    @brief 测试原子的创建
    """
    assert atom.id == 0
    assert atom.symbol == "Al"
    np.testing.assert_array_equal(atom.position, np.array([0.0, 0.0, 0.0]))
    assert atom.mass == 26.9815


def test_cell_creation(cell, atom):
    """
    @brief 测试晶胞的创建
    """
    np.testing.assert_array_equal(cell.lattice_vectors, np.eye(3) * 4.05)
    assert len(cell.atoms) == 1
    assert cell.atoms[0] == atom


def test_volume_calculation(cell):
    """
    @brief 测试晶胞体积的计算
    """
    expected_volume = np.linalg.det(cell.lattice_vectors)
    calculated_volume = cell.calculate_volume()
    assert np.isclose(calculated_volume, expected_volume)


def test_apply_periodic_boundary(cell):
    """
    @brief 测试周期性边界条件的应用
    """
    lattice_constant = cell.lattice_vectors[0, 0]  # 假设晶格为立方
    position = np.array(
        [lattice_constant + 1.0, -1.0, lattice_constant + 1.0]
    )  # 超出晶胞范围的坐标
    new_position = cell.apply_periodic_boundary(position)
    # 检查新位置是否在 [0, lattice_constant) 范围内
    assert np.all(new_position >= 0)
    assert np.all(new_position < lattice_constant)


# tests/test_utils.py

import pytest
import numpy as np
from python.utils import TensorConverter, DataCollector
from python.structure import Atom, Cell


def test_tensor_converter_to_voigt():
    """
    @brief 测试 TensorConverter 的 to_voigt 方法
    """
    tensor = np.array([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0]])
    expected_voigt = np.array([1.0, 5.0, 9.0, 6.0, 3.0, 2.0])
    voigt = TensorConverter.to_voigt(tensor)
    np.testing.assert_array_almost_equal(voigt, expected_voigt, decimal=6)


@pytest.fixture
def cell_fixture():
    """
    @fixture 创建一个简单的晶胞，用于数据收集测试
    """
    lattice_vectors = np.eye(3) * 4.05  # Å
    mass = 26.9815  # amu
    position = np.array([0.0, 0.0, 0.0])
    atom = Atom(id=0, symbol="Al", mass=mass, position=position)
    cell = Cell(lattice_vectors, [atom], pbc_enabled=True)
    return cell


def test_data_collector(cell_fixture):
    """
    @brief 测试 DataCollector 的数据收集功能
    """
    collector = DataCollector()
    collector.collect(cell_fixture)
    assert len(collector.data) == 1
    collected = collector.data[0]
    assert "positions" in collected
    assert "velocities" in collected
    assert len(collected["positions"]) == 1
    assert len(collected["velocities"]) == 1
    np.testing.assert_array_equal(
        collected["positions"][0], cell_fixture.atoms[0].position
    )
    np.testing.assert_array_equal(
        collected["velocities"][0], cell_fixture.atoms[0].velocity
    )


# tests/test_visualization.py

import pytest
from python.visualization import Visualizer
from python.structure import Cell, Atom
import numpy as np
import matplotlib

matplotlib.use("Agg")  # 使用无头后端，防止弹出图形窗口
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D  # 导入 Axes3D


def test_plot_cell_structure():
    """
    @brief 测试 Visualizer.plot_cell_structure 函数
    """
    # 创建一个简单的晶胞
    atoms = [
        Atom(id=0, mass=26.9815, position=np.array([0.0, 0.0, 0.0]), symbol="Al"),
        Atom(
            id=1, mass=26.9815, position=np.array([2.55, 2.55, 2.55]), symbol="Al"
        ),  # sigma=2.55 Å
    ]
    lattice_vectors = np.eye(3) * 5.1  # 示例晶格向量
    cell = Cell(atoms=atoms, lattice_vectors=lattice_vectors)

    # 创建 Visualizer 实例
    visualizer = Visualizer()

    # 调用绘图函数，捕获图形对象
    try:
        fig, ax = visualizer.plot_cell_structure(cell, show=False)
        assert isinstance(fig, plt.Figure), "返回的对象不是 Matplotlib Figure"
        assert isinstance(ax, Axes3D), "返回的对象不是 Matplotlib Axes3D"
    except Exception as e:
        pytest.fail(f"绘图函数抛出异常: {e}")


def test_plot_stress_strain():
    """
    @brief 测试 Visualizer.plot_stress_strain 函数
    """
    # 创建应变和应力数据
    strain_data = np.random.rand(10, 6)  # 示例数据
    stress_data = np.random.rand(10, 6)  # 示例数据

    # 创建 Visualizer 实例
    visualizer = Visualizer()

    # 调用绘图函数，确保不抛出异常
    try:
        fig, ax = visualizer.plot_stress_strain(strain_data, stress_data, show=False)
        assert isinstance(fig, plt.Figure), "返回的对象不是 Matplotlib Figure"
        assert isinstance(ax, plt.Axes), "返回的对象不是 Matplotlib Axes"
    except Exception as e:
        pytest.fail(f"绘图函数抛出异常: {e}")


