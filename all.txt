// src/cpp/lennard_jones.cpp

#include <cmath>
#include <vector>
#include <iostream>

extern "C"
{
    /**
     * @brief 计算 Lennard-Jones 力
     *
     * @param num_atoms 原子数量
     * @param positions 原子位置数组（长度为 3*num_atoms）
     * @param forces 输出的力数组（长度为 3*num_atoms）
     * @param epsilon Lennard-Jones 势参数 ε，单位为 eV
     * @param sigma Lennard-Jones 势参数 σ，单位为 Å
     * @param cutoff 截断半径，单位为 Å
     * @param lattice_vectors 晶格矢量（长度为 9，按列存储 3x3 矩阵）
     */
    void calculate_forces(
        int num_atoms,
        const double *positions,
        double *forces,
        double epsilon,
        double sigma,
        double cutoff,
        const double *lattice_vectors // 9 个元素：H = [a1, a2, a3] 作为列
    )
    {
        // 清零力数组
        for (int i = 0; i < 3 * num_atoms; ++i)
        {
            forces[i] = 0.0;
        }

        // 构建晶格矩阵 H 和逆矩阵 H_inv
        double H[3][3];
        for (int i = 0; i < 3; ++i)
        {
            H[0][i] = lattice_vectors[3 * i];
            H[1][i] = lattice_vectors[3 * i + 1];
            H[2][i] = lattice_vectors[3 * i + 2];
        }
        // 计算 H_inv
        double det = H[0][0] * (H[1][1] * H[2][2] - H[1][2] * H[2][1]) -
                     H[0][1] * (H[1][0] * H[2][2] - H[1][2] * H[2][0]) +
                     H[0][2] * (H[1][0] * H[2][1] - H[1][1] * H[2][0]);
        if (det == 0)
        {
            std::cerr << "错误：晶格矩阵的行列式为零，无法求逆。" << std::endl;
            return;
        }
        double H_inv[3][3];
        H_inv[0][0] = (H[1][1] * H[2][2] - H[1][2] * H[2][1]) / det;
        H_inv[0][1] = (H[0][2] * H[2][1] - H[0][1] * H[2][2]) / det;
        H_inv[0][2] = (H[0][1] * H[1][2] - H[0][2] * H[1][1]) / det;
        H_inv[1][0] = (H[1][2] * H[2][0] - H[1][0] * H[2][2]) / det;
        H_inv[1][1] = (H[0][0] * H[2][2] - H[0][2] * H[2][0]) / det;
        H_inv[1][2] = (H[0][2] * H[1][0] - H[0][0] * H[1][2]) / det;
        H_inv[2][0] = (H[1][0] * H[2][1] - H[1][1] * H[2][0]) / det;
        H_inv[2][1] = (H[0][1] * H[2][0] - H[0][0] * H[2][1]) / det;
        H_inv[2][2] = (H[0][0] * H[1][1] - H[0][1] * H[1][0]) / det;

        // 预计算在截断距离处的力，以用于力的偏移
        double sr_cutoff = sigma / cutoff;
        double sr6_cutoff = pow(sr_cutoff, 6);
        double sr12_cutoff = sr6_cutoff * sr6_cutoff;
        double F_LJ_cutoff = 24.0 * epsilon * (2.0 * sr12_cutoff - sr6_cutoff) / cutoff;

        // 力的计算
        for (int i = 0; i < num_atoms; ++i)
        {
            const double *ri = &positions[3 * i];
            for (int j = i + 1; j < num_atoms; ++j)
            {
                const double *rj = &positions[3 * j];
                double rij[3];
                // 计算 rij = rj - ri
                for (int k = 0; k < 3; ++k)
                {
                    rij[k] = rj[k] - ri[k];
                }

                // 转换到分数坐标 s = H_inv * rij
                double s[3];
                for (int k = 0; k < 3; ++k)
                {
                    s[k] = H_inv[k][0] * rij[0] + H_inv[k][1] * rij[1] + H_inv[k][2] * rij[2];
                    // 映射到 [-0.5, 0.5]
                    s[k] -= round(s[k]);
                }

                // 转换回笛卡尔坐标 rij = H * s
                for (int k = 0; k < 3; ++k)
                {
                    rij[k] = H[0][k] * s[0] + H[1][k] * s[1] + H[2][k] * s[2];
                }

                double r2 = rij[0] * rij[0] + rij[1] * rij[1] + rij[2] * rij[2];
                double r = sqrt(r2);

                // 添加极小距离保护
                if (r < 1e-8)
                {
                    std::cerr << "警告：原子 " << i << " 和原子 " << j << " 太近 (r=" << r << ")，跳过力的计算。" << std::endl;
                    continue;
                }

                if (r < cutoff)
                {
                    double sr = sigma / r;
                    double sr6 = pow(sr, 6);
                    double sr12 = sr6 * sr6;
                    double F_LJ = 24.0 * epsilon * (2.0 * sr12 - sr6) / r;

                    // 力的偏移，使得在截断距离处力为零
                    double force_scalar = F_LJ - F_LJ_cutoff;

                    // 应用力
                    double fij[3];
                    for (int k = 0; k < 3; ++k)
                    {
                        fij[k] = -force_scalar * rij[k] / r;
                        forces[3 * i + k] += fij[k];
                        forces[3 * j + k] -= fij[k];
                    }

                    // 调试输出
                    // std::cout << "原子 " << i << " - 原子 " << j << " 力：[" << fij[0] << ", " << fij[1] << ", " << fij[2] << "]" << std::endl;
                }
            }
        }
    }
}


// src/cpp/nose_hoover.cpp

#include <cmath>
#include <vector>

extern "C"
{
    /**
     * @brief 应用 Nose-Hoover 恒温器
     *
     * @param dt 时间步长
     * @param num_atoms 原子数量
     * @param masses 原子质量数组（长度为 num_atoms）
     * @param velocities 原子速度数组（长度为 3*num_atoms）
     * @param forces 原子力数组（长度为 3*num_atoms）
     * @param xi 热浴变量
     * @param Q 热浴质量参数
     * @param target_temperature 目标温度
     */
    void nose_hoover(
        double dt,
        int num_atoms,
        const double *masses,
        double *velocities,
        const double *forces,
        double *xi,
        double Q,
        double target_temperature)
    {
        double dt2 = dt / 2.0;
        double kB = 8.617333262e-5; // 玻尔兹曼常数，单位 eV/K
        double kT = kB * target_temperature;

        // 第一半步：更新速度
        for (int i = 0; i < num_atoms; ++i)
        {
            velocities[3 * i] += dt2 * (forces[3 * i] / masses[i]);
            velocities[3 * i + 1] += dt2 * (forces[3 * i + 1] / masses[i]);
            velocities[3 * i + 2] += dt2 * (forces[3 * i + 2] / masses[i]);
        }

        // 计算动能
        double kinetic_energy = 0.0;
        for (int i = 0; i < num_atoms; ++i)
        {
            double vx = velocities[3 * i];
            double vy = velocities[3 * i + 1];
            double vz = velocities[3 * i + 2];
            kinetic_energy += 0.5 * masses[i] * (vx * vx + vy * vy + vz * vz);
        }

        // 更新热浴变量 xi
        double Gxi = (2.0 * kinetic_energy - 3.0 * num_atoms * kT) / Q;
        *xi += dt * Gxi;

        // 第二半步：更新速度，考虑热浴变量的影响
        double exp_factor = exp(-dt * (*xi));
        for (int i = 0; i < num_atoms; ++i)
        {
            velocities[3 * i] = velocities[3 * i] * exp_factor + dt2 * (forces[3 * i] / masses[i]);
            velocities[3 * i + 1] = velocities[3 * i + 1] * exp_factor + dt2 * (forces[3 * i + 1] / masses[i]);
            velocities[3 * i + 2] = velocities[3 * i + 2] * exp_factor + dt2 * (forces[3 * i + 2] / masses[i]);
        }
    }
}


// src/cpp/stress_calculator.cpp

#include <cmath>
#include <vector>

extern "C"
{
    /**
     * @brief 计算应力张量
     *
     * @param num_atoms 原子数量
     * @param positions 原子位置数组（长度为 3*num_atoms）
     * @param velocities 原子速度数组（长度为 3*num_atoms）
     * @param forces 原子力数组（长度为 3*num_atoms）
     * @param masses 原子质量数组（长度为 num_atoms）
     * @param volume 系统体积
     * @param epsilon Lennard-Jones 势参数 ε，单位为 eV
     * @param sigma Lennard-Jones 势参数 σ，单位为 Å
     * @param cutoff 截断半径，单位为 Å
     * @param lattice_vectors 晶格矢量（长度为 9，按列存储 3x3 矩阵）
     * @param stress_tensor 输出的应力张量（长度为 9，按行主序存储 3x3 矩阵）
     */
    void compute_stress(
        int num_atoms,
        const double *positions,
        const double *velocities,
        const double *forces,
        const double *masses,
        double volume,
        double epsilon,
        double sigma,
        double cutoff,
        const double *lattice_vectors,
        double *stress_tensor // 输出
    )
    {
        // 初始化应力张量
        for (int i = 0; i < 9; ++i)
        {
            stress_tensor[i] = 0.0;
        }

        // 构建晶格矩阵 H 和逆矩阵 H_inv
        double H[3][3];
        for (int i = 0; i < 3; ++i)
        {
            H[0][i] = lattice_vectors[3 * i];
            H[1][i] = lattice_vectors[3 * i + 1];
            H[2][i] = lattice_vectors[3 * i + 2];
        }
        // 计算 H_inv
        double det = H[0][0] * (H[1][1] * H[2][2] - H[1][2] * H[2][1]) -
                     H[0][1] * (H[1][0] * H[2][2] - H[1][2] * H[2][0]) +
                     H[0][2] * (H[1][0] * H[2][1] - H[1][1] * H[2][0]);
        double H_inv[3][3];
        H_inv[0][0] = (H[1][1] * H[2][2] - H[1][2] * H[2][1]) / det;
        H_inv[0][1] = (H[0][2] * H[2][1] - H[0][1] * H[2][2]) / det;
        H_inv[0][2] = (H[0][1] * H[1][2] - H[0][2] * H[1][1]) / det;
        H_inv[1][0] = (H[1][2] * H[2][0] - H[1][0] * H[2][2]) / det;
        H_inv[1][1] = (H[0][0] * H[2][2] - H[0][2] * H[2][0]) / det;
        H_inv[1][2] = (H[0][2] * H[1][0] - H[0][0] * H[1][2]) / det;
        H_inv[2][0] = (H[1][0] * H[2][1] - H[1][1] * H[2][0]) / det;
        H_inv[2][1] = (H[0][1] * H[2][0] - H[0][0] * H[2][1]) / det;
        H_inv[2][2] = (H[0][0] * H[1][1] - H[0][1] * H[1][0]) / det;

        // 动能项
        for (int i = 0; i < num_atoms; ++i)
        {
            double m = masses[i];
            const double *v = &velocities[3 * i];
            for (int alpha = 0; alpha < 3; ++alpha)
            {
                for (int beta = 0; beta < 3; ++beta)
                {
                    stress_tensor[3 * alpha + beta] += m * v[alpha] * v[beta];
                }
            }
        }

        // 势能项
        for (int i = 0; i < num_atoms; ++i)
        {
            const double *ri = &positions[3 * i];
            for (int j = i + 1; j < num_atoms; ++j)
            {
                const double *rj = &positions[3 * j];
                double rij[3];
                // 计算 rij = rj - ri
                for (int k = 0; k < 3; ++k)
                {
                    rij[k] = rj[k] - ri[k];
                }

                // 转换到分数坐标 s = H_inv * rij
                double s[3];
                for (int k = 0; k < 3; ++k)
                {
                    s[k] = H_inv[k][0] * rij[0] + H_inv[k][1] * rij[1] + H_inv[k][2] * rij[2];
                    // 映射到 [-0.5, 0.5]
                    s[k] -= round(s[k]);
                }

                // 转换回笛卡尔坐标 rij = H * s
                for (int k = 0; k < 3; ++k)
                {
                    rij[k] = H[0][k] * s[0] + H[1][k] * s[1] + H[2][k] * s[2];
                }

                double r2 = rij[0] * rij[0] + rij[1] * rij[1] + rij[2] * rij[2];
                double r = sqrt(r2);

                if (r < cutoff)
                {
                    double sr = sigma / r;
                    double sr6 = pow(sr, 6);
                    double sr12 = sr6 * sr6;
                    double force_scalar = 24.0 * epsilon * (2.0 * sr12 - sr6) / r;
                    double fij[3];
                    for (int k = 0; k < 3; ++k)
                    {
                        fij[k] = force_scalar * rij[k] / r;
                    }
                    for (int alpha = 0; alpha < 3; ++alpha)
                    {
                        for (int beta = 0; beta < 3; ++beta)
                        {
                            stress_tensor[3 * alpha + beta] += rij[alpha] * fij[beta];
                        }
                    }
                }
            }
        }

        // 归一化并取负号
        for (int i = 0; i < 9; ++i)
        {
            stress_tensor[i] = -stress_tensor[i] / volume;
        }
    }
}


# src/python/config.py

import yaml


class ConfigManager:
    """
    @class ConfigManager
    @brief 配置管理器，用于加载和获取配置参数。
    """

    def __init__(self, config_file):
        self.config = self.load_config(config_file)

    @staticmethod
    def load_config(config_file):
        with open(config_file, "r") as f:
            config = yaml.safe_load(f)
        return config

    def get(self, key, default=None):
        return self.config.get(key, default)


# src/python/deformation.py

import numpy as np


class Deformer:
    """
    @class Deformer
    @brief 施加微小应变以生成变形矩阵的类。
    """

    def __init__(self, delta):
        """
        @param delta 微小应变量
        """
        self.delta = delta

    def generate_deformation_matrices(self):
        """
        @brief 生成用于施加应变的变形矩阵列表。

        @return 变形矩阵列表
        """
        delta = self.delta
        F_list = []

        # 六个独立的应变分量
        strain_components = [
            np.array([[delta, 0, 0], [0, 0, 0], [0, 0, 0]]),  # ε_xx
            np.array([[0, 0, 0], [0, delta, 0], [0, 0, 0]]),  # ε_yy
            np.array([[0, 0, 0], [0, 0, 0], [0, 0, delta]]),  # ε_zz
            np.array([[0, delta / 2, 0], [delta / 2, 0, 0], [0, 0, 0]]),  # ε_xy
            np.array([[0, 0, delta / 2], [0, 0, 0], [delta / 2, 0, 0]]),  # ε_xz
            np.array([[0, 0, 0], [0, 0, delta / 2], [0, delta / 2, 0]]),  # ε_yz
        ]

        for epsilon in strain_components:
            F = np.identity(3) + epsilon
            F_list.append(F)

        return F_list

    def apply_deformation(self, cell, deformation_matrix):
        """
        @brief 对晶胞施加变形矩阵。

        @param cell Cell 实例
        @param deformation_matrix 变形矩阵
        """
        cell.apply_deformation(deformation_matrix)


# src/python/elasticity.py

import numpy as np
from .mechanics import StressCalculatorLJ, ElasticConstantsSolver
from .deformation import Deformer
from .optimizers import GradientDescentOptimizer
from .utils import TensorConverter


class ElasticConstantsCalculator:
    """
    @class ElasticConstantsCalculator
    @brief 用于计算弹性常数的类
    """

    def __init__(self, cell, potential, delta=1e-3):
        self.cell = cell
        self.potential = potential
        self.delta = delta
        self.deformer = Deformer(delta)
        self.stress_calculator = StressCalculatorLJ()
        self.optimizer = GradientDescentOptimizer(
            max_steps=1000, tol=1e-6, step_size=1e-4
        )

    def calculate_elastic_constants(self):
        """
        @brief 计算弹性常数矩阵

        @return 弹性常数矩阵，形状为 (6, 6)
        """
        F_list = self.deformer.generate_deformation_matrices()
        strains = []
        stresses = []

        for F in F_list:
            # 复制初始晶胞
            deformed_cell = self.cell.copy()
            # 施加变形
            deformed_cell.apply_deformation(F)
            # 优化结构
            self.optimizer.optimize(deformed_cell, self.potential)
            # 计算应力
            self.potential.calculate_forces(deformed_cell)
            stress_tensor = self.stress_calculator.compute_stress(
                deformed_cell, self.potential
            )
            # 计算应变
            strain_tensor = 0.5 * (np.dot(F.T, F) - np.identity(3))
            # 转换为 Voigt 表示
            strain_voigt = TensorConverter.to_voigt(strain_tensor)
            stress_voigt = TensorConverter.to_voigt(stress_tensor)
            strains.append(strain_voigt)
            stresses.append(stress_voigt)

        # 拟合弹性常数矩阵
        strains = np.array(strains)
        stresses = np.array(stresses)
        elastic_solver = ElasticConstantsSolver()
        C = elastic_solver.solve(strains, stresses)
        return C


# src/python/md.py

import numpy as np
from .interfaces.cpp_interface import CppInterface


class Integrator:
    """
    @class Integrator
    @brief 积分器基类
    """

    def integrate(self, cell, potential, thermostat, dt):
        raise NotImplementedError


class VelocityVerletIntegrator(Integrator):
    """
    @class VelocityVerletIntegrator
    @brief 速度 Verlet 积分器的实现
    """

    def integrate(self, cell, potential, thermostat, dt):
        atoms = cell.atoms
        # 第一半步：更新位置
        for atom in atoms:
            atom.position += atom.velocity * dt + 0.5 * atom.force / atom.mass * dt**2
            # 应用周期性边界条件
            atom.position = cell.apply_periodic_boundary(atom.position)
        # 保存旧的力
        forces_old = [atom.force.copy() for atom in atoms]
        # 计算新的力
        potential.calculate_forces(cell)
        # 第二半步：更新速度
        for atom, force_old in zip(atoms, forces_old):
            atom.velocity += 0.5 * (atom.force + force_old) / atom.mass * dt
        # 应用恒温器
        if thermostat is not None:
            thermostat.apply(atoms, dt)


class Thermostat:
    """
    @class Thermostat
    @brief 恒温器基类
    """

    def apply(self, atoms, dt):
        raise NotImplementedError


class NoseHooverThermostat(Thermostat):
    """
    @class NoseHooverThermostat
    @brief Nose-Hoover 恒温器的实现
    """

    def __init__(self, target_temperature, time_constant):
        self.target_temperature = target_temperature
        self.Q = time_constant  # 热浴质量参数
        self.xi = 0.0  # 热浴变量初始值
        self.cpp_interface = CppInterface("nose_hoover")

    def apply(self, atoms, dt):
        num_atoms = len(atoms)
        masses = np.array([atom.mass for atom in atoms], dtype=np.float64)
        velocities = np.array(
            [atom.velocity for atom in atoms], dtype=np.float64
        ).flatten()
        forces = np.array([atom.force for atom in atoms], dtype=np.float64).flatten()
        # 调用 C++ 函数
        self.xi = self.cpp_interface.nose_hoover(
            dt,
            num_atoms,
            masses,
            velocities,
            forces,
            self.xi,
            self.Q,
            self.target_temperature,
        )
        # 更新原子速度
        for i, atom in enumerate(atoms):
            atom.velocity = velocities[3 * i : 3 * i + 3]


class MDSimulator:
    """
    @class MDSimulator
    @brief 分子动力学模拟器
    """

    def __init__(self, cell, potential, integrator, thermostat=None):
        self.cell = cell
        self.potential = potential
        self.integrator = integrator
        self.thermostat = thermostat

    def run(self, steps, dt, data_collector=None):
        # 初始化力
        self.potential.calculate_forces(self.cell)
        for step in range(steps):
            self.integrator.integrate(self.cell, self.potential, self.thermostat, dt)
            if data_collector is not None:
                data_collector.collect(self.cell)
            print(f"MD Step {step} completed.")


# src/python/mechanics.py

import numpy as np
from .utils import TensorConverter
from .interfaces.cpp_interface import CppInterface


class StressCalculator:
    """
    @class StressCalculator
    @brief 应力计算器基类
    """

    def compute_stress(self, cell, potential):
        raise NotImplementedError


class StressCalculatorLJ(StressCalculator):
    """
    @class StressCalculatorLJ
    @brief 基于 Lennard-Jones 势的应力计算器
    """

    def __init__(self):
        self.cpp_interface = CppInterface("stress_calculator")

    def compute_stress(self, cell, potential):
        volume = cell.calculate_volume()
        atoms = cell.atoms
        num_atoms = len(atoms)
        positions = np.array(
            [atom.position for atom in atoms], dtype=np.float64
        ).flatten()
        velocities = np.array(
            [atom.velocity for atom in atoms], dtype=np.float64
        ).flatten()
        forces = np.array([atom.force for atom in atoms], dtype=np.float64).flatten()
        masses = np.array([atom.mass for atom in atoms], dtype=np.float64)
        epsilon = potential.epsilon
        sigma = potential.sigma
        cutoff = potential.cutoff
        lattice_vectors = cell.lattice_vectors.flatten()
        # 调用 C++ 实现的应力计算函数
        stress_tensor = self.cpp_interface.compute_stress(
            num_atoms,
            positions,
            velocities,
            forces,
            masses,
            volume,
            epsilon,
            sigma,
            cutoff,
            lattice_vectors,
        )
        return stress_tensor


class StrainCalculator:
    """
    @class StrainCalculator
    @brief 应变计算器
    """

    def compute_strain(self, deformation_gradient):
        C = np.dot(deformation_gradient.T, deformation_gradient)
        strain_tensor = 0.5 * (C - np.identity(3))
        return strain_tensor


class ElasticConstantsSolver:
    """
    @class ElasticConstantsSolver
    @brief 弹性常数求解器
    """

    def solve(self, strains, stresses):
        """
        @brief 求解弹性常数矩阵

        @param strains 应变列表，形状为 (N, 6)
        @param stresses 应力列表，形状为 (N, 6)

        @return 弹性常数矩阵，形状为 (6, 6)
        """
        strains = np.array(strains)
        stresses = np.array(stresses)
        C, residuals, rank, s = np.linalg.lstsq(strains, stresses, rcond=None)
        return C


# src/python/optimizers.py

import numpy as np


class Optimizer:
    """
    @class Optimizer
    @brief 优化器基类
    """

    def optimize(self, cell, potential):
        raise NotImplementedError


class GradientDescentOptimizer(Optimizer):
    """
    @class GradientDescentOptimizer
    @brief 梯度下降优化器
    """

    def __init__(self, max_steps=1000, tol=1e-6, step_size=1e-4):
        self.max_steps = max_steps
        self.tol = tol
        self.step_size = step_size

    def optimize(self, cell, potential):
        atoms = cell.atoms
        potential.calculate_forces(cell)
        for step in range(self.max_steps):
            # 计算最大力
            max_force = max(np.linalg.norm(atom.force) for atom in atoms)
            print(f"Step {step}: Max force = {max_force}")
            if max_force < self.tol:
                print(f"Converged after {step} steps")
                break
            # 更新位置
            for atom in atoms:
                displacement = self.step_size * atom.force
                atom.position += displacement
                # 应用周期性边界条件
                atom.position = cell.apply_periodic_boundary(atom.position)
                # print(f"Atom {atom.id} Position: {atom.position}")
            # 重新计算力
            potential.calculate_forces(cell)
            # 打印新力
            # for atom in atoms:
            #     print(f"Atom {atom.id} Force: {atom.force}")
        else:
            print("Optimization did not converge within the maximum number of steps.")


# src/python/potentials.py

import numpy as np
from .interfaces.cpp_interface import CppInterface


class Potential:
    """
    @class Potential
    @brief 势能基类
    """

    def __init__(self, parameters, cutoff):
        self.parameters = parameters
        self.cutoff = cutoff

    def calculate_potential(self, cell):
        raise NotImplementedError

    def calculate_forces(self, cell):
        raise NotImplementedError


class LennardJonesPotential(Potential):
    """
    @class LennardJonesPotential
    @brief Lennard-Jones 势的实现
    """

    def __init__(self, epsilon, sigma, cutoff):
        parameters = {"epsilon": epsilon, "sigma": sigma}
        super().__init__(parameters, cutoff)
        self.epsilon = epsilon  # 单位 eV
        self.sigma = sigma  # 单位 Å
        self.cutoff = cutoff  # 单位 Å
        self.cpp_interface = CppInterface("lennard_jones")

    def calculate_forces(self, cell):
        num_atoms = len(cell.atoms)
        positions = np.array(
            [atom.position for atom in cell.atoms], dtype=np.float64
        ).flatten()
        forces = np.zeros_like(positions)
        lattice_vectors = cell.lattice_vectors.flatten()
        self.cpp_interface.calculate_forces(
            num_atoms,
            positions,
            forces,
            self.epsilon,
            self.sigma,
            self.cutoff,
            lattice_vectors,
        )
        # 检查 forces 数组是否更新
        if np.allclose(forces, 0):
            print("警告：计算得到的力全为零")
        else:
            print("计算得到的力非零")
            # print("计算得到的力数组：", forces)
        # 更新原子力
        for i, atom in enumerate(cell.atoms):
            atom.force = forces[3 * i : 3 * i + 3]


# src/python/structure.py

import numpy as np


class Atom:
    """
    @class Atom
    @brief 原子类，包含原子的信息和属性。
    """

    def __init__(self, id, symbol, mass, position, velocity=None):
        self.id = id
        self.symbol = symbol
        self.mass = mass
        self.position = np.array(position)
        self.velocity = np.zeros(3) if velocity is None else np.array(velocity)
        self.force = np.zeros(3)

    def update_position(self, delta_r):
        self.position += delta_r

    def update_velocity(self, delta_v):
        self.velocity += delta_v


class Cell:
    """
    @class Cell
    @brief 晶胞类，包含晶格矢量和原子列表。
    """

    def __init__(self, lattice_vectors, atoms, pbc_enabled=True):
        self.lattice_vectors = np.array(lattice_vectors)
        self.atoms = atoms  # 原子列表
        self.volume = self.calculate_volume()
        self.pbc_enabled = pbc_enabled

    def calculate_volume(self):
        return np.linalg.det(self.lattice_vectors)

    def apply_deformation(self, deformation_matrix):
        """
        @brief 对晶胞和原子坐标施加变形矩阵。

        @param deformation_matrix 3x3 变形矩阵
        """
        # 更新晶格矢量
        self.lattice_vectors = np.dot(self.lattice_vectors, deformation_matrix.T)
        # 更新原子坐标
        for atom in self.atoms:
            atom.position = np.dot(deformation_matrix, atom.position)

    def apply_periodic_boundary(self, position):
        if self.pbc_enabled:
            # 转换到分数坐标
            fractional = np.linalg.solve(self.lattice_vectors.T, position)
            # 确保在 [0, 1) 范围内
            fractional = fractional % 1.0
            # 转换回笛卡尔坐标
            return np.dot(self.lattice_vectors.T, fractional)
        else:
            return position

    def copy(self):
        atoms_copy = [
            Atom(
                atom.id,
                atom.symbol,
                atom.mass,
                atom.position.copy(),
                atom.velocity.copy(),
            )
            for atom in self.atoms
        ]
        return Cell(self.lattice_vectors.copy(), atoms_copy, self.pbc_enabled)


# src/python/utils.py

import numpy as np


class TensorConverter:
    @staticmethod
    def to_voigt(tensor):
        """
        将 3x3 张量转换为 Voigt 表示的长度为6的向量。

        顺序为 [σ_xx, σ_yy, σ_zz, σ_xy, σ_xz, σ_yz]
        """
        voigt = np.array(
            [
                tensor[0, 0],
                tensor[1, 1],
                tensor[2, 2],
                tensor[0, 1],
                tensor[0, 2],
                tensor[1, 2],
            ]
        )
        return voigt


class DataCollector:
    """
    @class DataCollector
    @brief 数据收集器，用于在模拟过程中收集数据。
    """

    def __init__(self):
        self.data = []

    def collect(self, cell):
        # 收集需要的数据
        positions = [atom.position.copy() for atom in cell.atoms]
        velocities = [atom.velocity.copy() for atom in cell.atoms]
        self.data.append({"positions": positions, "velocities": velocities})


# src/python/visualization.py

"""
@file visualization.py
@brief 可视化晶胞结构和模拟结果的模块。
"""

import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
import numpy as np

from .structure import Cell


class Visualizer:
    """
    @class Visualizer
    @brief 可视化晶胞结构和模拟结果的类。
    """

    def __init__(self):
        pass

    def plot_cell_structure(self, cell_structure: Cell, show=True):
        """
        @brief 绘制晶体结构的 3D 图形。

        @param cell_structure Cell 实例。
        @param show 是否显示图形，默认为 True。
        @return 返回绘图对象 fig 和 ax。
        """
        fig = plt.figure()
        ax = fig.add_subplot(111, projection="3d")
        for atom in cell_structure.atoms:
            ax.scatter(*atom.position, label=atom.symbol)
        # 绘制晶格矢量
        origin = [0, 0, 0]
        lattice_vectors = cell_structure.lattice_vectors
        for i in range(3):
            vec = lattice_vectors[:, i]
            ax.quiver(*origin, *vec, color="r", arrow_length_ratio=0.1)
        ax.set_xlabel("X (Å)")
        ax.set_ylabel("Y (Å)")
        ax.set_zlabel("Z (Å)")
        plt.title("Crystal Structure")
        plt.legend()
        if show:
            plt.show()
        return fig, ax

    def plot_stress_strain(
        self, strain_data: np.ndarray, stress_data: np.ndarray, show=True
    ):
        """
        @brief 绘制应力-应变关系图。

        @param strain_data numpy.ndarray: 应变数据，形状为 (N, 6)。
        @param stress_data numpy.ndarray: 应力数据，形状为 (N, 6)。
        @param show 是否显示图形，默认为 True。
        @return 返回绘图对象 fig 和 ax。
        """
        fig, ax = plt.subplots(figsize=(10, 6))
        for i in range(6):
            ax.plot(strain_data[:, i], stress_data[:, i], label=f"Stress {i+1}")
        ax.set_xlabel("Strain")
        ax.set_ylabel("Stress (eV/Å³)")
        ax.set_title("Stress-Strain Relationship")
        ax.legend()
        ax.grid(True)
        plt.tight_layout()
        if show:
            plt.show()
        return fig, ax


# src/python/__init__.py

"""
@package ThermoElasticSim
@brief 初始化 ThermoElasticSim 项目。

该项目包含用于计算和模拟金属铝（Al）和金刚石（Diamond）在不同温度下弹性常数的模块。
"""

# 导入子模块
from .structure import Atom, Cell
from .potentials import Potential, LennardJonesPotential
from .md import (
    MDSimulator,
    Integrator,
    VelocityVerletIntegrator,
    Thermostat,
    NoseHooverThermostat,
)
from .mechanics import (
    StressCalculator,
    StressCalculatorLJ,
    StrainCalculator,
    ElasticConstantsSolver,
)
from .optimizers import Optimizer, GradientDescentOptimizer
from .deformation import Deformer
from .utils import TensorConverter, DataCollector
from .visualization import Visualizer
from .config import ConfigManager


# src/python/interfaces/cpp_interface.py

import ctypes
import numpy as np
from numpy.ctypeslib import ndpointer
import os


class CppInterface:
    """
    @class CppInterface
    @brief 用于调用 C++ 实现的函数的接口类。
    """

    def __init__(self, lib_name):
        """
        @param lib_name 库的名称
        """
        if os.name == "nt":  # Windows
            lib_extension = ".dll"
            lib_prefix = ""
        else:  # Unix/Linux
            lib_extension = ".so"
            lib_prefix = "lib"
        # 获取当前文件所在目录的绝对路径
        current_dir = os.path.dirname(os.path.abspath(__file__))
        # 获取项目根目录的绝对路径
        project_root = os.path.abspath(os.path.join(current_dir, "..", ".."))
        # 构建库文件的绝对路径
        lib_path = os.path.join(
            project_root, "lib", lib_prefix + lib_name + lib_extension
        )
        # 检查库文件是否存在
        if not os.path.exists(lib_path):
            raise FileNotFoundError(f"无法找到库文件: {lib_path}")
        self.lib = ctypes.CDLL(lib_path)

        if lib_name == "nose_hoover":
            self.lib.nose_hoover.argtypes = [
                ctypes.c_double,  # dt
                ctypes.c_int,  # num_atoms
                ndpointer(ctypes.c_double, flags="C_CONTIGUOUS"),  # masses
                ndpointer(ctypes.c_double, flags="C_CONTIGUOUS"),  # velocities
                ndpointer(ctypes.c_double, flags="C_CONTIGUOUS"),  # forces
                ctypes.POINTER(ctypes.c_double),  # xi
                ctypes.c_double,  # Q
                ctypes.c_double,  # target_temperature
            ]
            self.lib.nose_hoover.restype = None
        elif lib_name == "lennard_jones":
            self.lib.calculate_forces.argtypes = [
                ctypes.c_int,  # num_atoms
                ndpointer(ctypes.c_double, flags="C_CONTIGUOUS"),  # positions
                ndpointer(ctypes.c_double, flags="C_CONTIGUOUS"),  # forces
                ctypes.c_double,  # epsilon
                ctypes.c_double,  # sigma
                ctypes.c_double,  # cutoff
                ndpointer(ctypes.c_double, flags="C_CONTIGUOUS"),  # lattice_vectors
            ]
            self.lib.calculate_forces.restype = None
        elif lib_name == "stress_calculator":
            self.lib.compute_stress.argtypes = [
                ctypes.c_int,  # num_atoms
                ndpointer(ctypes.c_double, flags="C_CONTIGUOUS"),  # positions
                ndpointer(ctypes.c_double, flags="C_CONTIGUOUS"),  # velocities
                ndpointer(ctypes.c_double, flags="C_CONTIGUOUS"),  # forces
                ndpointer(ctypes.c_double, flags="C_CONTIGUOUS"),  # masses
                ctypes.c_double,  # volume
                ctypes.c_double,  # epsilon
                ctypes.c_double,  # sigma
                ctypes.c_double,  # cutoff
                ndpointer(ctypes.c_double, flags="C_CONTIGUOUS"),  # lattice_vectors
                ndpointer(
                    ctypes.c_double, flags="C_CONTIGUOUS"
                ),  # stress_tensor (output)
            ]
            self.lib.compute_stress.restype = None

    def nose_hoover(
        self, dt, num_atoms, masses, velocities, forces, xi, Q, target_temperature
    ):
        xi_c = ctypes.c_double(xi)
        self.lib.nose_hoover(
            dt,
            num_atoms,
            masses,
            velocities,
            forces,
            ctypes.byref(xi_c),
            Q,
            target_temperature,
        )
        return xi_c.value

    def calculate_forces(
        self,
        num_atoms,
        positions,
        forces,
        epsilon,
        sigma,
        cutoff,
        lattice_vectors,
    ):
        self.lib.calculate_forces(
            num_atoms,
            positions,
            forces,
            epsilon,
            sigma,
            cutoff,
            lattice_vectors,
        )

    def compute_stress(
        self,
        num_atoms,
        positions,
        velocities,
        forces,
        masses,
        volume,
        epsilon,
        sigma,
        cutoff,
        lattice_vectors,
    ):
        stress_tensor = np.zeros(9, dtype=np.float64)
        self.lib.compute_stress(
            num_atoms,
            positions,
            velocities,
            forces,
            masses,
            volume,
            epsilon,
            sigma,
            cutoff,
            lattice_vectors,
            stress_tensor,
        )
        return stress_tensor.reshape((3, 3))


# src/python/interfaces/__init__.py


# tests/test_cpp_interface.py

import pytest
import numpy as np
from python.interfaces.cpp_interface import CppInterface


@pytest.fixture
def lj_interface():
    """
    @fixture 创建 Lennard-Jones C++ 接口实例
    """
    return CppInterface("lennard_jones")


@pytest.fixture
def stress_interface():
    """
    @fixture 创建 Stress Calculator C++ 接口实例
    """
    return CppInterface("stress_calculator")


@pytest.fixture
def nose_hoover_interface():
    """
    @fixture 创建 Nose-Hoover C++ 接口实例
    """
    return CppInterface("nose_hoover")


def test_calculate_forces(lj_interface):
    """
    @brief 测试 C++ 实现的 Lennard-Jones 力计算函数
    """
    num_atoms = 2
    positions = np.array([0.0, 0.0, 0.0, 2.55, 0.0, 0.0], dtype=np.float64)
    forces = np.zeros_like(positions)
    epsilon = 0.0103
    sigma = 2.55
    cutoff = 2.5 * sigma
    lattice_vectors = np.eye(3, dtype=np.float64).flatten()

    lj_interface.calculate_forces(
        num_atoms,
        positions,
        forces,
        epsilon,
        sigma,
        cutoff,
        lattice_vectors,
    )

    # 检查力是否非零且相反
    force1 = forces[0:3]
    force2 = forces[3:6]
    np.testing.assert_array_almost_equal(force1, -force2, decimal=6)
    assert not np.allclose(force1, 0)


def test_compute_stress(stress_interface):
    """
    @brief 测试 C++ 实现的应力计算函数
    """
    num_atoms = 1
    positions = np.array([0.0, 0.0, 0.0], dtype=np.float64)
    velocities = np.array([0.0, 0.0, 0.0], dtype=np.float64)
    forces = np.array([0.0, 0.0, 0.0], dtype=np.float64)
    masses = np.array([26.9815], dtype=np.float64)
    volume = 4.05**3
    epsilon = 0.0103
    sigma = 2.55
    cutoff = 2.5 * sigma
    lattice_vectors = np.eye(3, dtype=np.float64).flatten()

    stress_tensor = stress_interface.compute_stress(
        num_atoms,
        positions,
        velocities,
        forces,
        masses,
        volume,
        epsilon,
        sigma,
        cutoff,
        lattice_vectors,
    )

    # 检查应力张量是否为 3x3 矩阵
    assert stress_tensor.shape == (3, 3)
    # 由于没有力作用，应力张量应为零
    np.testing.assert_array_almost_equal(stress_tensor, np.zeros((3, 3)), decimal=6)


def test_nose_hoover(nose_hoover_interface):
    """
    @brief 测试 C++ 实现的 Nose-Hoover 恒温器函数
    """
    dt = 1.0
    num_atoms = 2
    masses = np.array([1.0, 1.0], dtype=np.float64)
    velocities = np.array([0.0, 0.0, 0.0, 1.0, 0.0, 0.0], dtype=np.float64)
    forces = np.array([0.0, 0.0, 0.0, -1.0, 0.0, 0.0], dtype=np.float64)
    xi = 0.0
    Q = 10.0
    target_temperature = 300.0

    # 调用 Nose-Hoover
    updated_xi = nose_hoover_interface.nose_hoover(
        dt,
        num_atoms,
        masses,
        velocities,
        forces,
        xi,
        Q,
        target_temperature,
    )

    # 由于初始 xi=0，动能接近 0，xi 应该有变化
    assert isinstance(updated_xi, float)
    assert not np.isclose(updated_xi, xi)


# tests/test_deformation.py

import pytest
import numpy as np
from python.deformation import Deformer


def test_generate_deformation_matrices():
    """
    @brief 测试生成变形矩阵的方法
    """
    delta = 0.01  # 1% 的应变
    deformer = Deformer(delta)
    deformation_matrices = deformer.generate_deformation_matrices()

    # 检查是否生成了 6 个变形矩阵
    assert len(deformation_matrices) == 6

    # 检查每个变形矩阵的正确性
    for i, F in enumerate(deformation_matrices):
        # 检查矩阵是否为 3x3
        assert F.shape == (3, 3)

        # 检查矩阵是否为单位矩阵加上微小变形
        expected_F = np.identity(3)
        if i < 3:
            expected_F[i, i] += delta
        else:
            shear_indices = [(0, 1), (0, 2), (1, 2)]
            idx = i - 3
            i_shear, j_shear = shear_indices[idx]
            expected_F[i_shear, j_shear] += delta / 2
            expected_F[j_shear, i_shear] += delta / 2
        np.testing.assert_array_almost_equal(F, expected_F, decimal=6)


def test_apply_deformation(cell_fixture):
    """
    @brief 测试对晶胞施加变形矩阵的方法
    """
    delta = 0.01
    deformer = Deformer(delta)
    deformation_matrix = deformer.generate_deformation_matrices()[0]  # ε_xx
    original_lattice = cell_fixture.lattice_vectors.copy()
    original_positions = [atom.position.copy() for atom in cell_fixture.atoms]

    deformer.apply_deformation(cell_fixture, deformation_matrix)

    # 检查晶格矢量是否正确更新
    expected_lattice = np.dot(original_lattice, deformation_matrix.T)
    np.testing.assert_array_almost_equal(
        cell_fixture.lattice_vectors, expected_lattice, decimal=6
    )

    # 检查原子位置是否正确更新
    for original_pos, atom in zip(original_positions, cell_fixture.atoms):
        expected_pos = np.dot(deformation_matrix, original_pos)
        np.testing.assert_array_almost_equal(atom.position, expected_pos, decimal=6)


@pytest.fixture
def cell_fixture():
    """
    @fixture 创建一个简单的晶胞，用于测试
    """
    from python.structure import Atom, Cell

    mass = 26.9815  # amu
    position = np.array([0.0, 0.0, 0.0])
    atom = Atom(id=0, symbol="Al", mass=mass, position=position)
    lattice_vectors = np.eye(3) * 4.05  # Å
    cell = Cell(lattice_vectors, [atom], pbc_enabled=True)
    return cell


# tests/test_elasticity.py

import pytest
import numpy as np
from python.structure import Cell, Atom
from python.potentials import LennardJonesPotential
from python.elasticity import ElasticConstantsCalculator


def test_elastic_constants_calculator():
    """
    @brief 测试 ElasticConstantsCalculator 计算弹性常数
    """
    # 创建一个简单的晶胞，例如立方晶格
    atoms = [
        Atom(id=0, mass=2816.78346, position=np.array([0.0, 0.0, 0.0]), symbol="Al"),
        Atom(
            id=1, mass=2816.78346, position=np.array([2.55, 2.55, 2.55]), symbol="Al"
        ),  # sigma=2.55 Å
    ]
    lattice_vectors = np.eye(3) * 5.1  # 示例晶格向量
    cell = Cell(atoms=atoms, lattice_vectors=lattice_vectors)

    # 定义 Lennard-Jones 势
    epsilon = 0.0103  # eV
    sigma = 2.55  # Å
    cutoff = 8.0  # Å, 示例截断半径
    lj_potential = LennardJonesPotential(epsilon=epsilon, sigma=sigma, cutoff=cutoff)

    # 创建 ElasticConstantsCalculator 实例
    elastic_calculator = ElasticConstantsCalculator(
        cell=cell, potential=lj_potential, delta=1e-3
    )

    # 计算弹性常数
    C = elastic_calculator.calculate_elastic_constants()

    # 将弹性常数矩阵转换为 GPa
    C_in_GPa = C * 160.21766208

    # 预期弹性常数矩阵（根据文献或已知值）
    # 请根据实际材料（例如铝）的弹性常数进行调整，以下为示例值
    expected_C = np.array(
        [
            [69.0, 0.0, 0.0, 0.0, 0.0, 0.0],
            [0.0, 69.0, 0.0, 0.0, 0.0, 0.0],
            [0.0, 0.0, 69.0, 0.0, 0.0, 0.0],
            [0.0, 0.0, 0.0, 23.0, 0.0, 0.0],
            [0.0, 0.0, 0.0, 0.0, 23.0, 0.0],
            [0.0, 0.0, 0.0, 0.0, 0.0, 23.0],
        ]
    )  # 示例值，需根据实际情况调整

    # 检查弹性常数矩阵是否接近预期值
    assert np.allclose(
        C_in_GPa, expected_C, atol=1.0
    ), f"弹性常数矩阵不接近预期值。\n计算结果:\n{C_in_GPa}\n预期值:\n{expected_C}"


# tests/test_md.py

import pytest
import numpy as np

from python.structure import Atom, Cell
from python.potentials import LennardJonesPotential
from python.md import MDSimulator, VelocityVerletIntegrator, NoseHooverThermostat


@pytest.fixture
def simple_cell(pbc_enabled=True):
    """
    @fixture 创建一个简单的晶胞，包含两个原子
    """
    lattice_vectors = np.eye(3) * 6.0 if pbc_enabled else np.eye(3) * 1e8  # Å
    mass = 2816.78346  # eV·fs²/Å²
    position1 = np.array([0.0, 0.0, 0.0])
    position2 = np.array([2.55, 0.0, 0.0])  # 与原子 1 相距 σ = 2.55 Å
    atom1 = Atom(id=0, symbol="Al", mass=mass, position=position1)
    atom2 = Atom(id=1, symbol="Al", mass=mass, position=position2)
    cell = Cell(lattice_vectors, [atom1, atom2], pbc_enabled=pbc_enabled)
    return cell


@pytest.fixture
def lj_potential():
    """
    @fixture 定义 Lennard-Jones 势
    """
    epsilon = 0.0103  # eV
    sigma = 2.55  # Å
    cutoff = 2.5 * sigma
    return LennardJonesPotential(epsilon=epsilon, sigma=sigma, cutoff=cutoff)


@pytest.fixture
def integrator():
    """
    @fixture 定义积分器
    """
    return VelocityVerletIntegrator()


@pytest.fixture
def thermostat():
    """
    @fixture 定义恒温器
    """
    return NoseHooverThermostat(target_temperature=300, time_constant=100)


def test_md_simulation(simple_cell, lj_potential, integrator):
    """
    @brief 测试分子动力学模拟器的运行
    """
    md_simulator = MDSimulator(
        simple_cell,
        lj_potential,
        integrator,
        thermostat=None,  # 先不加恒温器！！！
    )
    md_simulator.run(steps=10, dt=1.0)  # dt 单位为 fs

    # 检查原子的位置和速度是否发生变化
    atom1 = simple_cell.atoms[0]
    atom2 = simple_cell.atoms[1]
    assert not np.allclose(atom1.position, [0.0, 0.0, 0.0])
    assert not np.allclose(atom2.position, [2.55, 0.0, 0.0])
    assert not np.allclose(atom1.velocity, [0.0, 0.0, 0.0])
    assert not np.allclose(atom2.velocity, [0.0, 0.0, 0.0])


def test_md_simulation_with_thermostat(
    simple_cell, lj_potential, integrator, thermostat
):
    """
    @brief 测试分子动力学模拟器的运行，带恒温器
    """
    md_simulator = MDSimulator(
        simple_cell,
        lj_potential,
        integrator,
        thermostat=thermostat,
    )
    md_simulator.run(steps=10, dt=1.0)  # dt 单位为 fs

    # 检查原子的位置和速度是否发生变化
    atom1 = simple_cell.atoms[0]
    atom2 = simple_cell.atoms[1]
    assert not np.allclose(atom1.position, [0.0, 0.0, 0.0])
    assert not np.allclose(atom2.position, [2.55, 0.0, 0.0])
    assert not np.allclose(atom1.velocity, [0.0, 0.0, 0.0])
    assert not np.allclose(atom2.velocity, [0.0, 0.0, 0.0])


# tests/test_mechanics.py

import pytest
import numpy as np
from python.mechanics import (
    StressCalculatorLJ,
    StrainCalculator,
    ElasticConstantsSolver,
)
from python.structure import Atom, Cell
from python.potentials import LennardJonesPotential


@pytest.fixture
def single_atom_cell():
    """
    @fixture 创建一个简单的晶胞，包含一个原子
    """
    lattice_vectors = np.eye(3) * 4.05  # Å
    mass = 26.9815  # 原子量，amu
    position = np.array([0.0, 0.0, 0.0])
    atom = Atom(id=0, symbol="Al", mass=mass, position=position)
    cell = Cell(lattice_vectors, [atom], pbc_enabled=True)
    return cell


@pytest.fixture
def lj_potential_single():
    """
    @fixture 定义 Lennard-Jones 势
    """
    epsilon = 0.0103  # eV
    sigma = 2.55  # Å
    cutoff = 2.5 * sigma
    return LennardJonesPotential(epsilon=epsilon, sigma=sigma, cutoff=cutoff)


def test_stress_calculation(single_atom_cell, lj_potential_single):
    """
    @brief 测试应力计算器的功能
    """
    stress_calculator = StressCalculatorLJ()
    lj_potential_single.calculate_forces(single_atom_cell)
    stress_tensor = stress_calculator.compute_stress(
        single_atom_cell, lj_potential_single
    )
    # 检查应力张量是否为 3x3 矩阵
    assert stress_tensor.shape == (3, 3)


def test_strain_calculation():
    """
    @brief 测试应变计算器的功能
    """
    strain_calculator = StrainCalculator()
    F = np.array([[1.01, 0, 0], [0, 1, 0], [0, 0, 1]])
    strain_tensor = strain_calculator.compute_strain(F)
    # 检查应变张量是否为 3x3 矩阵
    assert strain_tensor.shape == (3, 3)
    # 检查应变计算是否正确
    expected_strain = 0.5 * (np.dot(F.T, F) - np.identity(3))
    np.testing.assert_array_almost_equal(strain_tensor, expected_strain, decimal=6)


def test_elastic_constants_solver():
    """
    @brief 测试弹性常数求解器的功能
    """
    strains = [np.zeros(6), np.ones(6) * 0.01]
    stresses = [np.zeros(6), np.ones(6)]
    solver = ElasticConstantsSolver()
    C = solver.solve(strains, stresses)
    # 检查 C 是否为 6x6 矩阵
    assert C.shape == (6, 6)
    # 由于输入为线性关系，C 应接近单位矩阵乘以某常数
    expected_C = np.linalg.lstsq(strains, stresses, rcond=None)[0]
    np.testing.assert_array_almost_equal(C, expected_C, decimal=6)


# tests/test_nose_hoover.py

import pytest
import numpy as np
from python.interfaces.cpp_interface import CppInterface


@pytest.fixture
def nose_hoover_interface():
    """
    @fixture 创建 Nose-Hoover C++ 接口实例
    """
    return CppInterface("nose_hoover")


def test_nose_hoover(nose_hoover_interface):
    """
    @brief 测试 C++ 实现的 Nose-Hoover 恒温器函数
    """
    dt = 1.0
    num_atoms = 2
    masses = np.array([1.0, 1.0], dtype=np.float64)
    velocities = np.array([0.0, 0.0, 0.0, 1.0, 0.0, 0.0], dtype=np.float64)
    forces = np.array([0.0, 0.0, 0.0, -1.0, 0.0, 0.0], dtype=np.float64)
    xi = 0.0
    Q = 10.0
    target_temperature = 300.0

    # 调用 Nose-Hoover
    updated_xi = nose_hoover_interface.nose_hoover(
        dt,
        num_atoms,
        masses,
        velocities,
        forces,
        xi,
        Q,
        target_temperature,
    )

    # 由于初始 xi=0，动能接近 0，xi 应该有变化
    assert isinstance(updated_xi, float)
    assert not np.isclose(updated_xi, xi)


# tests/test_optimizers.py

import pytest
import numpy as np
from python.optimizers import GradientDescentOptimizer
from python.structure import Atom, Cell
from python.potentials import LennardJonesPotential


@pytest.fixture
def optimizer():
    """
    @fixture 定义梯度下降优化器
    """
    return GradientDescentOptimizer(max_steps=5000, tol=1e-8, step_size=0.1)


@pytest.fixture
def optimization_cell(pbc_enabled=False):
    """
    @fixture 创建一个简单的晶胞，包含两个原子
    """
    if pbc_enabled:
        lattice_vectors = np.eye(3) * 6.0  # Å, 以确保最小镜像距离 >= 2^(1/6)*sigma
    else:
        lattice_vectors = np.eye(3) * 1e8  # Å, 以禁用 PBC

    mass = 2816.78346  # eV·fs²/Å²
    position1 = np.array([0.0, 0.0, 0.0])
    position2 = np.array([2.55, 0.0, 0.0])  # 初始距离为 σ = 2.55 Å
    atom1 = Atom(id=0, symbol="Al", mass=mass, position=position1)
    atom2 = Atom(id=1, symbol="Al", mass=mass, position=position2)
    cell = Cell(lattice_vectors, [atom1, atom2], pbc_enabled=pbc_enabled)
    return cell


@pytest.fixture
def lj_potential_optim():
    """
    @fixture 定义 Lennard-Jones 势
    """
    epsilon = 0.0103  # eV
    sigma = 2.55  # Å
    cutoff = 2.5 * sigma
    return LennardJonesPotential(epsilon=epsilon, sigma=sigma, cutoff=cutoff)


def test_gradient_descent_optimizer(optimizer, optimization_cell, lj_potential_optim):
    """
    @brief 测试梯度下降优化器
    """
    optimizer.optimize(optimization_cell, lj_potential_optim)

    # 获取优化后的原子位置
    optimized_position1 = optimization_cell.atoms[0].position
    optimized_position2 = optimization_cell.atoms[1].position

    # 计算优化后的距离
    optimized_distance = np.linalg.norm(optimized_position2 - optimized_position1)

    # 预期优化后的距离应接近 2^(1/6) * sigma ≈ 2.857 Å
    equilibrium_distance = 2 ** (1 / 6) * lj_potential_optim.sigma
    assert np.isclose(optimized_distance, equilibrium_distance, atol=2e-3)


def test_optimizer_convergence(optimizer, optimization_cell, lj_potential_optim):
    """
    @brief 测试优化器是否能收敛
    """
    optimizer.optimize(optimization_cell, lj_potential_optim)

    # 计算优化后的距离
    optimized_distance = np.linalg.norm(
        optimization_cell.atoms[1].position - optimization_cell.atoms[0].position
    )

    # 预期优化后的距离应接近 2^(1/6) * sigma ≈ 2.857 Å
    equilibrium_distance = 2 ** (1 / 6) * lj_potential_optim.sigma
    assert np.abs(optimized_distance - equilibrium_distance) < 2e-3


def test_force_direction():
    """
    @brief 验证力的方向是否为负梯度方向
    """
    # 创建一个简单的晶胞
    atoms = [
        Atom(id=0, mass=2816.78346, position=np.array([0.0, 0.0, 0.0]), symbol="Al"),
        Atom(id=1, mass=2816.78346, position=np.array([2.55, 2.55, 2.55]), symbol="Al"),
    ]
    lattice_vectors = np.eye(3) * 5.1  # 示例晶格向量
    cell = Cell(atoms=atoms, lattice_vectors=lattice_vectors)

    # 定义 Lennard-Jones 势
    epsilon = 0.0103  # eV
    sigma = 2.55  # Å
    cutoff = 8.0  # Å
    lj_potential = LennardJonesPotential(epsilon=epsilon, sigma=sigma, cutoff=cutoff)

    # 计算力
    lj_potential.calculate_forces(cell)

    force_on_atom0 = cell.atoms[0].force
    force_on_atom1 = cell.atoms[1].force

    # 计算梯度方向并包括力的截断偏移
    r_vec = atoms[1].position - atoms[0].position
    r = np.linalg.norm(r_vec)
    if r >= cutoff:
        # 截断距离外，力为零
        expected_force = np.zeros(3)
    else:
        sr = sigma / r
        sr6 = sr**6
        sr12 = sr6**2
        F_LJ = 24.0 * epsilon * (2.0 * sr12 - sr6) / r
        sr_cutoff = sigma / cutoff
        sr6_cutoff = sr_cutoff**6
        sr12_cutoff = sr6_cutoff**2
        F_LJ_cutoff = 24.0 * epsilon * (2.0 * sr12_cutoff - sr6_cutoff) / cutoff
        F_total = F_LJ - F_LJ_cutoff
        expected_force = F_total * (r_vec / r)

    # 断言计算的力是否接近预期力
    assert np.allclose(
        force_on_atom0, expected_force, atol=1e-5
    ), f"Atom 0 的力方向错误: {force_on_atom0} != {expected_force}"
    assert np.allclose(
        force_on_atom1, -expected_force, atol=1e-5
    ), f"Atom 1 的力方向错误: {force_on_atom1} != {-expected_force}"


# tests/test_potentials.py

import pytest
import numpy as np
from python.potentials import LennardJonesPotential
from python.structure import Atom, Cell


@pytest.fixture
def lj_potential():
    """
    @fixture 定义 Lennard-Jones 势
    """
    epsilon = 0.0103  # eV
    sigma = 2.55  # Å
    cutoff = 2.5 * sigma
    return LennardJonesPotential(epsilon=epsilon, sigma=sigma, cutoff=cutoff)


@pytest.fixture
def two_atom_cell():
    """
    @fixture 创建一个简单的系统，包含两个原子
    """
    lattice_vectors = np.eye(3) * 4.05  # Å
    mass = 26.9815  # amu
    position1 = np.array([0.0, 0.0, 0.0])
    position2 = np.array([2.025, 0.0, 0.0])  # 2.025 Å
    atom1 = Atom(id=0, symbol="Al", mass=mass, position=position1)
    atom2 = Atom(id=1, symbol="Al", mass=mass, position=position2)
    cell = Cell(lattice_vectors, [atom1, atom2], pbc_enabled=True)
    return cell


def test_force_calculation(lj_potential, two_atom_cell):
    """
    @brief 测试 Lennard-Jones 势的力计算功能
    """
    lj_potential.calculate_forces(two_atom_cell)
    # 检查力是否非零且相反
    force1 = two_atom_cell.atoms[0].force
    force2 = two_atom_cell.atoms[1].force
    np.testing.assert_array_almost_equal(force1, -force2, decimal=10)
    assert not np.allclose(force1, 0)


# tests/test_structure.py

import pytest
import numpy as np
from python.structure import Atom, Cell


@pytest.fixture
def atom():
    """
    @fixture 创建一个原子实例
    """
    position = np.array([0.0, 0.0, 0.0])
    mass = 26.9815  # 原子量，amu
    return Atom(id=0, symbol="Al", mass=mass, position=position)


@pytest.fixture
def cell(atom):
    """
    @fixture 创建一个晶胞实例，包含一个原子
    """
    lattice_vectors = np.eye(3) * 4.05  # Å
    return Cell(lattice_vectors, [atom], pbc_enabled=True)


def test_atom_creation(atom):
    """
    @brief 测试原子的创建
    """
    assert atom.id == 0
    assert atom.symbol == "Al"
    np.testing.assert_array_equal(atom.position, np.array([0.0, 0.0, 0.0]))
    assert atom.mass == 26.9815


def test_cell_creation(cell, atom):
    """
    @brief 测试晶胞的创建
    """
    np.testing.assert_array_equal(cell.lattice_vectors, np.eye(3) * 4.05)
    assert len(cell.atoms) == 1
    assert cell.atoms[0] == atom


def test_volume_calculation(cell):
    """
    @brief 测试晶胞体积的计算
    """
    expected_volume = np.linalg.det(cell.lattice_vectors)
    calculated_volume = cell.calculate_volume()
    assert np.isclose(calculated_volume, expected_volume)


def test_apply_periodic_boundary(cell):
    """
    @brief 测试周期性边界条件的应用
    """
    position = np.array([5.0, -1.0, 4.0])  # 超出晶胞范围的坐标
    new_position = cell.apply_periodic_boundary(position)
    # 检查新位置是否在 [0, lattice_constant) 范围内
    assert np.all(new_position >= 0)
    assert np.all(new_position < 4.05)


# tests/test_utils.py

import pytest
import numpy as np
from python.utils import TensorConverter, DataCollector
from python.structure import Atom, Cell


def test_tensor_converter_to_voigt():
    """
    @brief 测试 TensorConverter 的 to_voigt 方法
    """
    tensor = np.array([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0]])
    expected_voigt = np.array([1.0, 5.0, 9.0, 2.0, 3.0, 6.0])
    voigt = TensorConverter.to_voigt(tensor)
    np.testing.assert_array_almost_equal(voigt, expected_voigt, decimal=6)


@pytest.fixture
def cell_fixture():
    """
    @fixture 创建一个简单的晶胞，用于数据收集测试
    """
    lattice_vectors = np.eye(3) * 4.05  # Å
    mass = 26.9815  # amu
    position = np.array([0.0, 0.0, 0.0])
    atom = Atom(id=0, symbol="Al", mass=mass, position=position)
    cell = Cell(lattice_vectors, [atom], pbc_enabled=True)
    return cell


def test_data_collector(cell_fixture):
    """
    @brief 测试 DataCollector 的数据收集功能
    """
    collector = DataCollector()
    collector.collect(cell_fixture)
    assert len(collector.data) == 1
    collected = collector.data[0]
    assert "positions" in collected
    assert "velocities" in collected
    assert len(collected["positions"]) == 1
    assert len(collected["velocities"]) == 1
    np.testing.assert_array_equal(
        collected["positions"][0], cell_fixture.atoms[0].position
    )
    np.testing.assert_array_equal(
        collected["velocities"][0], cell_fixture.atoms[0].velocity
    )


# tests/test_visualization.py

import pytest
from python.visualization import Visualizer
from python.structure import Cell, Atom
import numpy as np
import matplotlib

matplotlib.use("Agg")  # 使用无头后端，防止弹出图形窗口
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D  # 导入 Axes3D


def test_plot_cell_structure():
    """
    @brief 测试 Visualizer.plot_cell_structure 函数
    """
    # 创建一个简单的晶胞
    atoms = [
        Atom(id=0, mass=2816.78346, position=np.array([0.0, 0.0, 0.0]), symbol="Al"),
        Atom(
            id=1, mass=2816.78346, position=np.array([2.55, 2.55, 2.55]), symbol="Al"
        ),  # sigma=2.55 Å
    ]
    lattice_vectors = np.eye(3) * 5.1  # 示例晶格向量
    cell = Cell(atoms=atoms, lattice_vectors=lattice_vectors)

    # 创建 Visualizer 实例
    visualizer = Visualizer()

    # 调用绘图函数，捕获图形对象
    try:
        fig, ax = visualizer.plot_cell_structure(cell, show=False)
        assert isinstance(fig, plt.Figure), "返回的对象不是 Matplotlib Figure"
        assert isinstance(ax, Axes3D), "返回的对象不是 Matplotlib Axes3D"
    except Exception as e:
        pytest.fail(f"绘图函数抛出异常: {e}")


def test_plot_stress_strain():
    """
    @brief 测试 Visualizer.plot_stress_strain 函数
    """
    # 创建应变和应力数据
    strain_data = np.random.rand(10, 6)  # 示例数据
    stress_data = np.random.rand(10, 6)  # 示例数据

    # 创建 Visualizer 实例
    visualizer = Visualizer()

    # 调用绘图函数，确保不抛出异常
    try:
        fig, ax = visualizer.plot_stress_strain(strain_data, stress_data, show=False)
        assert isinstance(fig, plt.Figure), "返回的对象不是 Matplotlib Figure"
        assert isinstance(ax, plt.Axes), "返回的对象不是 Matplotlib Axes"
    except Exception as e:
        pytest.fail(f"绘图函数抛出异常: {e}")


